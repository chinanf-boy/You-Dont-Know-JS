
# 你不知道JS: ES6与超越

# 第3章: 组织

编写js代码是一回事,但正确地组织它是另一回事. 利用常见的模式组织和重用有助于提高你的代码的可读性和可理解性. 记住: 代码至少与向其他开发人员通信一样重要,因为它是关于计算机指令的. 

6有几个重要的特征来帮助改善这些模式,包括: 迭代器ㄡ发电机ㄡ模块和类. 

## 遍历器

一个_迭代器_是从在一个时间的时尚源拉动信息结构化模式. 这种模式长期以来一直围绕着编程. 可以肯定的是,js开发人员已经在JS程序中特别设计和实现了迭代器,因为在人们还没记住之前,它根本就不是一个新主题. 

什么6所做的是介绍迭代器隐式接口规范. JavaScript中的许多内置数据结构现在将公开一个实现此标准的迭代器. 您还可以构建自己的迭代器,遵循相同的标准,以获得最大的互操作性. 

迭代器是组织有序的ㄡ连续的ㄡ基于拉动的数据消耗的一种方式. 

例如,您可以实现一个实用程序,每次请求时都会生成一个新的惟一标识符. 或者,你可以产生一系列无限的值,它们以循环的方式通过固定的列表旋转. 或者您可以将迭代器附加到数据库查询结果中,每次一次拉出新行. 

虽然它们通常不以这种方式被用在JS中,但是迭代器也可以被认为是一步一步地控制行为. 考虑发电机时可以清楚地说明这一点(见本章后面的"发电机"),尽管没有发电机也可以这样做. 

### 接口

在写这篇文章的时候,25.1.1.2(6节[http: / /人. Mozilla .org / ~ jorendorff / 6草案. HTML #秒迭代器接口](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface))细节`迭代器`接口具有以下要求: 

    Iterator [required]
    	next() {method}: retrieves next IteratorResult

有两个可选成员,其中一些迭代器是扩展的: 

    Iterator [optional]
    	return() {method}: stops iterator and returns IteratorResult
    	throw() {method}: signals error and returns IteratorResult

这个`iteratorresult`接口指定为: 

    IteratorResult
    	value {property}: current iteration value or final return value
    		(optional if `undefined`)
    	done {property}: boolean, indicates completion status

**注: **我将这些接口称为隐式,并不是因为规范中没有显式调用它们,而是!-但因为它们没有作为代码访问的直接对象公开. JavaScript不,在6,支持任何概念的"接口",为自己的代码是纯粹的传统性. 然而,无论JS期望一个迭代器`对..`例如,您所提供的循环必须遵守这些接口,否则代码将失败. 

还有一个`可迭代的`接口,它描述必须能够产生迭代器的对象: 

    Iterable
    	@@iterator() {method}: produces an Iterator

如果你记得第2章中的"内置符号",`@ @迭代器`是表示可以为对象生成迭代器的方法的特殊内置符号. 

#### iteratorresult

这个`iteratorresult`接口指定从任何迭代器操作返回的值将是表单的对象: 

```js
{ value: .. , done: true / false }
```

内置迭代器总是返回该表单的值,但在必要时允许返回更多的属性. 

例如,自定义迭代器可以向结果对象添加额外的元数据(例如,数据来自何处ㄡ检索需要多长时间ㄡ缓存过期长度ㄡ适当的下一个请求的频率等). 

**注: **技术上,`价值`如果它本来被认为是缺席或设置是可选的,如在价值的案例`未定义`. 因为访问`res.value`会产生`未定义`无论它是存在于这个值还是完全不存在,属性的存在/缺失更多地是一个实现细节或优化(或两者),而不是一个功能问题. 

### `next()`迭代

让我们在一个阵列的看,这是一个迭代器和迭代器,它可以产生消费价值观: 

```js
var arr = [1,2,3];

var it = arr[Symbol.iterator]();

it.next();		// { value: 1, done: false }
it.next();		// { value: 2, done: false }
it.next();		// { value: 3, done: false }

it.next();		// { value: undefined, done: true }
```

每次方法位于`symbol.iterator`(参见第2章和第7章)在此调用`ARR`值,它将生成一个新的新迭代器. 大多数结构都会这样做,包括js中所有内置的数据结构. 

然而,像事件队列消费者这样的结构可能只生成一个迭代器(单件模式). 或者一个结构可能每次只允许一个惟一的迭代器,在创建一个新迭代器之前需要先完成一个迭代器. 

这个`它`上一段代码中的迭代器不报告`做: 真的`当你收到`三`价值. 你必须打电话`next()`再次,本质上超出数组值的结尾,以获得完整的信号. `做: 真的`. 直到本节后面的部分,它可能还不清楚,但这个设计决定通常被认为是最好的做法. 

原始的字符串值也可迭代对象默认: 

```js
var greeting = "hello world";

var it = greeting[Symbol.iterator]();

it.next();		// { value: "h", done: false }
it.next();		// { value: "e", done: false }
..
```

**注: **从技术上讲,原始价值本身不是个,但由于"拳击",`"你好,世界"`被强制/转换为它的`字符串`对象包装器窗体_是_一个iterabl_类型与语法_此系列的标题以获取更多信息. 

6还包括一些新的数据结构,称为集合(见5章). 这些藏品不仅可迭代对象本身,但他们也提供API方法(S)生成一个迭代器,如: 

```js
var m = new Map();
m.set( "foo", 42 );
m.set( { cool: true }, "hello world" );

var it1 = m[Symbol.iterator]();
var it2 = m.entries();

it1.next();		// { value: [ "foo", 42 ], done: false }
it2.next();		// { value: [ "foo", 42 ], done: false }
..
```

这个`下一个(..)`迭代器的方法可以选择一个或多个参数. 内置迭代器通常不执行此功能,尽管生成器的迭代器肯定是这样做的(参见本章后面的"生成器"). 

通过常规约定,包括所有内置迭代器,调用`下一个(..)`在已用尽的迭代器上不是错误,但只会继续返回结果. `{值: 未定义的,已完成的: 真}`. 

### 可选: `返回(..)`和`投掷(ⅆ)`

迭代器接口上的可选方法ℴℴ`返回(..)`和`投掷(ⅆ)`-在大多数内置迭代器上没有实现. 但是,它们肯定意味着生成器中的某些内容,所以请参见"生成器"以获得更详细的信息. 

`返回(..)`定义为向一个迭代器发送一个信号,表示该消耗代码是完整的,不会从中提取更多的值. 此信号可用于通知生产者(迭代器响应`下一个(..)`调用)执行它可能需要做的任何清理工作,例如释放/关闭网络ㄡ数据库或文件句柄资源. 

如果迭代器有一个`返回(..)`当前和任何条件都可以自动解释为异常或提前终止消耗迭代器,`返回(..)`将自动调用. 你可以打电话`返回(..)`手动以及. 

`返回(..)`将返回一个`iteratorresult`对象就像`下一个(..)`做.一般来说,您发送的可选值为`返回(..)`将被送回`价值`在这`iteratorresult`虽然有微妙的情况下,这可能不是真的. 

`投掷(ⅆ)`用于向迭代器发出异常/错误,这可能与迭代器所用的不同,而不是由所隐含的完成信号. `返回(..)`. 它不一定意味着迭代器的完全停止`返回(..)`一般不. 

例如,使用生成器迭代器,`投掷(ⅆ)`实际上在生成器暂停的执行上下文中注入一个抛出异常,该上下文可以用`试试. 赶上`. 未捕获`投掷(ⅆ)`例外会异常中止发电机的迭代器. 

**注: **根据一般约定,迭代器在调用后不应该产生任何结果. `返回(..)`或`投掷(ⅆ)`. 

### 迭代器循环

正如我们在"`对..`"在第一章2节,6`对..`直接消耗一个符合环. 

如果一个迭代器也是一个,可以直接使用`对..`环. 你让一个迭代器迭代器所赋予它的`symbol.iterator`只返回迭代器本身的方法: 

```js
var it = {
	// make the `it` iterator an iterable
	[Symbol.iterator]() { return this; },

	next() { .. },
	..
};

it[Symbol.iterator]() === it;		// true
```

现在我们可以消耗`它`用一个迭代器`对..`环: 

```js
for (var v of it) {
	console.log( v );
}
```

为了充分理解这种循环是如何工作的,请回忆`对于`相当于一个`对..`第2章中的循环: 

```js
for (var v, res; (res = it.next()) && !res.done; ) {
	v = res.value;
	console.log( v );
}
```

如果你仔细看,你就会看到`next()它. `在每次迭代之前调用,然后`res.done`咨询. 如果`res.done`是`真正的`表达式计算为`假`迭代不会发生. 

回想一下,我们建议迭代器一般不返回. `做: 真的`连同迭代器的最终预期值一起. 现在你明白为什么了. 

如果返回迭代器`{已完成: true,值: 42 }`,的`对..`循环将完全丢弃`四十二`价值就会丢失. 出于这个原因,假设您的迭代器可能被诸如`对..`循环或其手册`对于`等价物,您可能应该等待返回. `做: 真的`直到您已经返回所有相关的迭代值为止,完成信令. 

**警告: **当然,您可以有意地设计迭代器以返回相关的内容. `价值`同时返回`做: 真的`. 但不要这样做,除非您已经记录了这种情况,从而隐含地迫使迭代器的使用者使用不同的迭代模式,而不是隐含的. `对..`或者我们描述的手册等价物. 

### 自定义迭代器

除了标准的内置迭代器,您还可以自己创建!所有这一切使他们与6的消费设施互操作(例如,的`对..`环和`ⅆ`运算符)是要遵循正确的接口. 

让我们尝试构造一个在斐波那契序列中产生无穷级数的迭代器: 

```js
var Fib = {
	[Symbol.iterator]() {
		var n1 = 1, n2 = 1;

		return {
			// make the iterator an iterable
			[Symbol.iterator]() { return this; },

			next() {
				var current = n2;
				n2 = n1;
				n1 = n1 + current;
				return { value: current, done: false };
			},

			return(v) {
				console.log(
					"Fibonacci sequence abandoned."
				);
				return { value: v, done: true };
			}
		};
	}
};

for (var v of Fib) {
	console.log( v );

	if (v > 50) break;
}
// 1 1 2 3 5 8 13 21 34 55
// Fibonacci sequence abandoned.
```

**警告: **如果我们没有插入`打破`条件,这`对..`循环将永远运行,这可能不是您想要打破程序的理想结果!

这个`符号[迭代器]`方法调用时返回迭代器对象`next()`和`返回(..)`方法论. 状态保持通过`N1`和`N2`由闭包保存的变量. 

让我们_下一个_考虑一个迭代器,该迭代器被设计为通过动作的一系列(又名队列)运行. 

```js
var tasks = {
	[Symbol.iterator]() {
		var steps = this.actions.slice();

		return {
			// make the iterator an iterable
			[Symbol.iterator]() { return this; },

			next(...args) {
				if (steps.length > 0) {
					let res = steps.shift()( ...args );
					return { value: res, done: false };
				}
				else {
					return { done: true }
				}
			},

			return(v) {
				steps.length = 0;
				return { value: v, done: true };
			}
		};
	},
	actions: []
};
```

迭代器上`任务`在函数中找到的步骤`行动`数组属性,如果有的话,每次执行一个数组,将传入的参数传递给`下一个(..)`并将返回值返回到标准中的任何值. `iteratorresult`对象. 

Here's how we could use this`任务`队列: 

```js
tasks.actions.push(
	function step1(x){
		console.log( "step 1:", x );
		return x * 2;
	},
	function step2(x,y){
		console.log( "step 2:", x, y );
		return x + (y * 2);
	},
	function step3(x,y,z){
		console.log( "step 3:", x, y, z );
		return (x * y) + z;
	}
);

var it = tasks[Symbol.iterator]();

it.next( 10 );			// step 1: 10
						// { value:   20, done: false }

it.next( 20, 50 );		// step 2: 20 50
						// { value:  120, done: false }

it.next( 20, 50, 120 );	// step 3: 20 50 120
						// { value: 1120, done: false }

it.next();				// { done: true }
```

这种特殊用法增强了迭代器可以成为组织功能的模式,而不仅仅是数据. 这也让我们联想到下一节中我们将看到的生成器. 

您甚至可以获得创造性,并定义一个迭代器,该迭代器代表单个数据上的元操作. 例如,我们可以定义一个默认数字范围的迭代器. `零`直至(或向下,以负数)所讨论的数字. 

考虑: 

```js
if (!Number.prototype[Symbol.iterator]) {
	Object.defineProperty(
		Number.prototype,
		Symbol.iterator,
		{
			writable: true,
			configurable: true,
			enumerable: false,
			value: function iterator(){
				var i, inc, done = false, top = +this;

				// iterate positively or negatively?
				inc = 1 * (top < 0 ? -1 : 1);

				return {
					// make the iterator itself an iterable!
					[Symbol.iterator](){ return this; },

					next() {
						if (!done) {
							// initial iteration always 0
							if (i == null) {
								i = 0;
							}
							// iterating positively
							else if (top >= 0) {
								i = Math.min(top,i + inc);
							}
							// iterating negatively
							else {
								i = Math.max(top,i + inc);
							}

							// done after this iteration?
							if (i == top) done = true;

							return { value: i, done: false };
						}
						else {
							return { done: true };
						}
					}
				};
			}
		}
	);
}
```

现在,这个创意给我们提供了什么诀窍?

```js
for (var i of 3) {
	console.log( i );
}
// 0 1 2 3

[...-3];				// [0,-1,-2,-3]
```

这些都是一些有趣的把戏,虽然实用性有点争议. 但是,有人会问为什么6不只是船这样一个小但令人愉快的特征的复活节彩蛋!?

如果我不提醒你,扩大本土原型我在前一段做的事情你必须做的只有谨慎和潜在危害的认识我会失职. 

在这种情况下,您可能会与其他代码或甚至是未来JS功能发生冲突的可能性非常低. 但要小心这种轻微的可能性. 文件你不厌其烦地为子孙后代而做的. 

**注: **我已经在这个博客文章中详细阐述了这个技巧. <http://blog.getify.com/iterating-es6-numbers/>如果你想要更多的细节. 还有这个评论([HTTP: / /博客. getify. COM / iterating-es6-numbers / comment-page-1 / # comment-535294](http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294)甚至建议使用类似的技巧,但要制作字符串字符范围. 

### 迭代器的消费

我们已经显示了一个迭代器项目`对..`环. 但还有其他6结构可消耗的迭代器. 

让我们来考虑这个数组的迭代器(尽管我们选择的迭代器都有以下行为): 

```js
var a = [1,2,3,4,5];
```

这个`ⅆ`扩展操作符完全耗尽迭代器. 考虑: 

```js
function foo(x,y,z,w,p) {
	console.log( x + y + z + w + p );
}

foo( ...a );			// 15
```

`ⅆ`也可以在数组中展开迭代器: 

```js
var b = [ 0, ...a, 6 ];
b;						// [0,1,2,3,4,5,6]
```

阵列的解构(见"解构"2章)可以部分或完全(如果搭配`ⅆ`REST /聚集运算符)使用迭代器: 

```js
var it = a[Symbol.iterator]();

var [x,y] = it;			// take just the first two elements from `it`
var [z, ...w] = it;		// take the third, then the rest all at once

// is `it` fully exhausted? Yep.
it.next();				// { value: undefined, done: true }

x;						// 1
y;						// 2
z;						// 3
w;						// [4,5]
```

## 发电机

所有功能都运行完成,对吗?换句话说,一旦函数开始运行,它就在其他任何东西都可以中断之前完成. 

至少JavaScript的整个历史都是这样的. 截至6,一个新的函数有点异国情调的形式被提出,称为发电机. 生成器可以在执行中暂停,可以立即恢复,也可以稍后恢复. 因此,它显然没有完成正常功能完成的运行保证. 

此外,执行中的每一个暂停/恢复周期都是双向消息传递的机会,在这里,生成器可以返回一个值,而恢复它的控制代码可以返回一个值. 

与前一节中的迭代器一样,有多种方法来考虑生成器是什么,或者更确切地说,它对于什么是最有用的. 没有一个正确的答案,但我们会考虑几个角度. 

**注: **看到_异步和性能_本系列的标题是关于发电机的更多信息,也请参阅本标题的第4章. 

### 语法

生成器函数是用这种新语法声明的: 

```js
function *foo() {
	// ..
}
```

的位置`*`功能无关. 同样的声明可以写成以下任何一项: 

```js
function *foo()  { .. }
function* foo()  { .. }
function * foo() { .. }
function*foo()   { .. }
..
```

这个_只有_不同之处在于文体偏好. 大多数其他文学似乎更喜欢. `函数*(..){ⅆ}`. 我喜欢`函数*(..){ⅆ}`这就是我如何将它们呈现在余下的标题中. 

我的理由纯粹是说教性质的. 在本文中,当提到生成器函数时,我将使用`*富(..)`,相对于`富(ⅆ)`对于正常函数. 我观察到`*富(..)`更紧密地匹配`*`定位`函数*(..){ⅆ}`. 

此外,正如我们在第2章中看到的,用简洁的方法,在对象文本中有一个简明的生成器形式: 

```js
var a = {
	*foo() { .. }
};
```

我想用简洁的生成器,`* foo() { ..}`比ⅆⅆ更自然`* foo() { ..}`. 从而进一步论证匹配的一致性`* foo()`. 

一致性可以简化理解和学习. 

#### 执行一个发电机

尽管发电机是用`*`仍然像正常函数一样执行它: 

```js
foo();
```

您仍然可以传递它的参数,如: 

```js
function *foo(x,y) {
	// ..
}

foo( 5, 10 );
```

主要区别是执行一个生成器,比如`foo(5,10)`不实际运行生成器中的代码. 相反,它生成一个迭代器,它将控制生成器执行其代码. 

稍后我们将在"迭代器控件"中返回这个主题,但简要介绍一下: 

```js
function *foo() {
	// ..
}

var it = foo();

// to start/advanced `*foo()`, call
// `it.next(..)`
```

#### `产量`

生成器也有一个新关键字,您可以在其中使用,以指示暂停点: `产量`. 考虑: 

```js
function *foo() {
	var x = 10;
	var y = 20;

	yield;

	var z = x + y;
}
```

在这`* foo()`生成器,前两行的操作将在开始时运行,然后`产量`将暂停GE`* foo()`将运行. `产量`可以出现任何次数(或者根本不是,技术上的)!发电机中. 

你甚至可以放`产量`在循环中,它可以表示一个重复的停顿点. 事实上,一个永远不会完成的循环仅仅意味着一个永远不会完成的生成器,它是完全有效的,有时完全是你所需要的. 

`产量`不仅仅是一个停顿点. 这是一个表达式,在暂停生成器时发送一个值. 这是一个`而实现的. `循环中的一个生成器,用于每次迭代`产量`一个新的随机数: 

```js
function *foo() {
	while (true) {
		yield Math.random();
	}
}
```

这个`产量. `表达式不仅发送一个值ℴℴ`产量`没有值是一样的`产量未定义`ℴℴ但也会收到(例如,被替换)最终恢复值. 考虑: 

```js
function *foo() {
	var x = yield 10;
	console.log( x );
}
```

这台发电机将首先`产量`的价值`十`暂停时. 当您恢复生成器ℴℴ使用`下一个(..)`我们前面提到过,无论您恢复什么值(如果有的话)都将替换/完成整个操作. `产量10`表达式,意思是该值将被分配给`X`变量. 

一`产量. `表达式可以在正常表达式的任何地方出现. 例如:

```js
function *foo() {
	var arr = [ yield 1, yield 2, yield 3 ];
	console.log( arr, yield 4 );
}
```

`* foo()`这里有四个`产量. `表达.每个`产量`结果在生成器中暂停等待恢复值,然后在各种表达式上下文中使用该值. 

`产量`在技术上不是一个操作符,虽然在使用时`产量1`看起来确实是这样. 因为`产量`可以自己使用`var =收益率;`把它当作一个操作符有时会让人困惑. 

技术上,`产量. `是相同的"表达式优先"ℴℴ概念上与运算符优先级类似ℴℴ作为赋值表达式`= 3`. 这意味着`产量. `基本上可以出现在任何地方`= 3`能有效地出现. 

让我们来说明对称性: 

```js
var a, b;

a = 3;					// valid
b = 2 + a = 3;			// invalid
b = 2 + (a = 3);		// valid

yield 3;				// valid
a = 2 + yield 3;		// invalid
a = 2 + (yield 3);		// valid
```

**注: **如果你想一想,它在某种意义上意味着`产量. `表达式的行为类似于赋值表达式. 当停下来`产量`表达式被恢复,它由恢复值代替,与"赋值"值没有什么不同. 

外卖: 如果你需要的话`产量. `出现在某项任务中`= 3`不允许它本身,它需要被包裹在一个`()`. 

因为`产量`关键字,几乎任何表达式后`产量. `将在被发送之前先计算. `产量`. 只有`ⅆ`扩展运算符和`,`逗号运算符具有较低的优先级,这意味着它们将在`产量`已评价. 

因此,就像在正常语句中的多个操作符一样,另一个情况是`()`可能需要的是覆盖(提升)低优先级的`产量`如这些表达式之间的差异: 

```js
yield 2 + 3;			// same as `yield (2 + 3)`

(yield 2) + 3;			// `yield 2` first, then `+ 3`
```

就像`=`分配,`产量`也是"右联想",这意味着多重. `产量`连续的表达式被当作是`(..)`从右到左分组. 所以,`产量3`作为`产量(收益率(3))`. "左联想"释义`(产量)收率3`毫无意义. 

就像运营商一样,使用它是个好主意. `(..)`分组,即使没有严格的要求,对你的意图,如果`产量`与其他运算符或`产量`S.

**注: **看到_类型与语法_关于运算符的优先级和结合性的更多信息,这一系列的标题. 

#### `产量*`

以同样的方式`*`使一个`功能`宣言`功能*`生成器声明`*`使`产量`进入之内`产量*`这是一个非常不同的机制,叫做_收益率代表团_. 语法,`屈服..`会表现得和A一样`产量. `如前一节所述. 

`屈服..`需要一个;然后调用迭代器的迭代器,并代表自己的主发电机的控制,直到筋疲力尽的迭代器. 考虑: 

```js
function *foo() {
	yield *[1,2,3];
}
```

**注: **与`*`在生成器声明中的位置(前面讨论过)`*`定位`产量*`表达风格由你. 其他大多数文学作品更喜欢`屈服..`但我更喜欢`屈服..`因为已经讨论过的非常对称的原因. 

这个`[1,2,3]`值生成一个迭代器,该迭代器将单步执行其值,因此`* foo()`生成器将在消耗时将这些值输出. 另一种说明行为的方法是将授权委托给另一个生成器: 

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
}

function *bar() {
	yield *foo();
}
```

迭代器在`* bar()`电话`* foo()`委托给通过`产量*`,意思是任何价值. `* foo()`生产将由`* bar()`. 

而`产量. `表达式的完成值来自于生成器的恢复. `下一个(..)`,完成值`屈服..`表达式来自从返回到迭代器的返回值(如果有的话). 

内置迭代器一般没有返回值,正如我们在本章前面的"迭代器循环"部分的结尾所述. 但是,如果您定义了自己的自定义迭代器(或生成器),可以将其设计为`ReTUR`一个值,它`屈服..`将捕获: 

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
	return 4;
}

function *bar() {
	var x = yield *foo();
	console.log( "x:", x );
}

for (var v of bar()) {
	console.log( v );
}
// 1 2 3
// x: 4
```

而`一`,`二`,和`三`值`产量`我离开`* foo()`然后离开`* bar()`,的`四`返回值`* foo()`的完成值是`* foo()产量`表达式,然后分配给`X`. 

因为`产量*`可以调用另一个生成器(通过委派给它的迭代器),它也可以通过调用自身来执行一种生成器递归: 

```js
function *foo(x) {
	if (x < 3) {
		x = yield *foo( x + 1 );
	}
	return x * 2;
}

foo( 1 );
```

结果从`美孚(1)`然后调用迭代器的`next()`要通过递归步骤运行它将是`二十四`. 第一`*富(..)`运行`X`在价值`一`,这是`x<3`. `x + 1`递归地传递给`*富(..)`,所以`X`然后`二`. 另一个递归调用导致`X`属于`三`. 

现在,因为`x<3`失败,递归停止,并且`返回3 * 2`给予`六`回到前一个电话`屈服..`表达式,然后分配给`X`. 另一个`返回6 * 2`返回`十二`回到前一个电话`X`. 最后`12 * 2`,或`二十四`从已完成的运行返回. `*富(..)`发电机. 

### 迭代器的控制

早些时候,我们简要介绍了生成器由迭代器控制的概念. 让我们现在充分挖掘这个问题. 

召回的递归`*富(..)`从上一节. 以下是我们如何运行它: 

```js
function *foo(x) {
	if (x < 3) {
		x = yield *foo( x + 1 );
	}
	return x * 2;
}

var it = foo( 1 );
it.next();				// { value: 24, done: true }
```

在这种情况下,发电机并没有真正停止,因为没有. `产量. `表达. 相反,`产量*`只是通过递归调用保持当前迭代步骤进行. 所以,只需要调用迭代器的`next()`函数完全运行生成器. 

现在让我们考虑一个具有多个步骤和多个生成值的生成器: 

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
}
```

我们已经知道,我们可以使用迭代器,甚至连一个生成器`* foo()`,一个`对..`环: 

```js
for (var v of foo()) {
	console.log( v );
}
// 1 2 3
```

**注: **这个`对..`需要一个环. 生成器函数引用(如`Foo`)本身并不是一种迭代;你必须执行它`foo()`获得迭代器(这也是一个解释,正如我们在本章的前面). 理论上你可以扩展`generatorprototype`(所有生成器函数的原型)`symbol.iterator`基本上就是这样的功能`返回this()`. 那会使`Foo`参考本身的一个,这意味着`对于(var){ⅆ}`(注意不`()`在`Foo`将工作. 

让我们来手动迭代生成器: 

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
}

var it = foo();

it.next();				// { value: 1, done: false }
it.next();				// { value: 2, done: false }
it.next();				// { value: 3, done: false }

it.next();				// { value: undefined, done: true }
```

如果仔细看,有三个. `产量`表四`next()`电话.这似乎是一种奇怪的错配. 事实上,总会有一个. `next()`打电话比`产量`表达式,假设所有都被评估,生成器完全运行到完成. 

但是如果你从相反的角度来看它(内向外而不是外),那么`产量`和`next()`更有意义. 

记得,`产量. `表达式将通过恢复生成器的值来完成. 这意味着你传递的论点`下一个(..)`完成什么`产量. `表达式当前暂停等待完成. 

让我们用这种方式来说明这个观点: 

```js
function *foo() {
	var x = yield 1;
	var y = yield 2;
	var z = yield 3;
	console.log( x, y, z );
}
```

在这个片段中,每个`产量. `正在发送一个值(`一`,`二`,`三`但更直接的是,它暂停生成器等待值. 换句话说,这就像是在问一个问题,"我应该在这里使用什么价值?"我等着听回来. "

现在,我们来谈谈如何控制`* foo()`启动它: 

```js
var it = foo();

it.next();				// { value: 1, done: false }
```

第一`next()`调用是从初始暂停状态启动生成器,并将其运行到第一个状态. `产量`. 现在你先打那个电话`next()`没有`产量. `等待完成的表达式. 如果您将值传递给第一个`next()`打电话,它现在只是被扔掉,因为没有`产量`等待接收这样的值. 

**注: **早期的建议为"超越时间6"_将_让您访问传递给初始值的值. `下一个(..)`通过生成器中的一个单独的元属性(参见第7章)调用. 

现在,让我们回答当前悬而未决的问题,"我应该赋予什么价值?`X`?"我们将通过发送一个值来回答它. _下一个_ `下一个(..)`呼叫: 

```js
it.next( "foo" );		// { value: 2, done: false }
```

现在,该`X`将有价值`"foo"`我们也问了一个新问题,"我应该赋予什么价值?`Y`?"我们回答: 

```js
it.next( "bar" );		// { value: 3, done: false }
```

回答,另一个问题问. 最后的答案: 

```js
it.next( "baz" );		// "foo" "bar" "baz"
						// { value: undefined, done: true }
```

现在应该更清楚每一个`产量. `"问题"由_下一个_ `下一个(..)`呼叫,所以"额外"`next()`我们所观察到的呼唤永远是开始一切事物的起点. 

让我们把所有这些步骤放在一起: 

```js
var it = foo();

// start up the generator
it.next();				// { value: 1, done: false }

// answer first question
it.next( "foo" );		// { value: 2, done: false }

// answer second question
it.next( "bar" );		// { value: 3, done: false }

// answer third question
it.next( "baz" );		// "foo" "bar" "baz"
						// { value: undefined, done: true }
```

您可以把生成器看作值的生产者,在这种情况下,每次迭代都是生成一个要消耗的值. 

但从更一般的意义上来说,将生成器看作控制的ㄡ渐进的代码执行可能是恰当的,非常类似于`任务`来自早期"自定义迭代器"部分的队列示例. 

**注: **这种观点正是我们在第4章中如何重新审视发电机的动机. 具体来说,没有理由`下一个(..)`必须在前一次被调用. `下一个(..)`完成. 而

### 提前完成

正如我们在本章前面所述,连接到生成器的迭代器支持可选的. `返回(..)`和`投掷(ⅆ)`方法.它们都有中止暂停发电机立即的效果. 

考虑: 

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
}

var it = foo();

it.next();				// { value: 1, done: false }

it.return( 42 );		// { value: 42, done: true }

it.next();				// { value: undefined, done: true }
```

`返回(x)`有点像强迫某人`返回x`在那个时刻进行处理,这样你就可以得到指定的值. 一旦生成器完成,无论是正常情况下还是早期显示,它不再处理任何代码或返回任何值. 

除了`返回(..)`被调用的手动,也叫自动在迭代结束的6构建消费迭代器,如`对..`环和`ⅆ`传播算子. 

这个功能的目的是这样,如果控制代码不再在它上面迭代,就可以通知生成器,以便它可以做任何清理任务(释放资源ㄡ重置状态等). 与正常函数清除模式相同,实现这一目标的主要方法是使用`最后`条款:

```js
function *foo() {
	try {
		yield 1;
		yield 2;
		yield 3;
	}
	finally {
		console.log( "cleanup!" );
	}
}

for (var v of foo()) {
	console.log( v );
}
// 1 2 3
// cleanup!

var it = foo();

it.next();				// { value: 1, done: false }
it.return( 42 );		// cleanup!
						// { value: 42, done: true }
```

**警告: **不要放`产量`表内`最后`条款!这是合法的,但这是一个非常糟糕的想法. 它在某种意义上表现为推迟完成`返回(..)`打电话给你,做任何`产量. `中的表达`最后`子句可以暂停并发送消息;您不会像预期的那样立即获得完整的生成器. 基本上没有充分的理由选择那种疯狂. _坏的部分_因此,避免这样做!

除了前面的片段,还展示了如何`返回(..)`中止发电机同时触发`最后`子句,它还演示了一个生成器每次调用时生成一个新的迭代器. 实际上,可以同时使用同一个生成器上的多个迭代器: 

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
}

var it1 = foo();
it1.next();				// { value: 1, done: false }
it1.next();				// { value: 2, done: false }

var it2 = foo();
it2.next();				// { value: 1, done: false }

it1.next();				// { value: 3, done: false }

it2.next();				// { value: 2, done: false }
it2.next();				// { value: 3, done: false }

it2.next();				// { value: undefined, done: true }
it1.next();				// { value: undefined, done: true }
```

#### 早期流产

而不是打电话`返回(..)`你可以打电话`投掷(ⅆ)`. 就像`返回(x)`本质上是注入`返回x`进入发电机的当前暂停点,呼叫`掷(x)`基本上像注射`把X`在暂停点. 

除了异常行为(我们覆盖了它意味着什么)`尝试`下一节的条款),`投掷(ⅆ)`产生早期完成,中止发电机运行在其当前的停顿点的那种. 例如:

```js
function *foo() {
	yield 1;
	yield 2;
	yield 3;
}

var it = foo();

it.next();				// { value: 1, done: false }

try {
	it.throw( "Oops!" );
}
catch (err) {
	console.log( err );	// Exception: Oops!
}

it.next();				// { value: undefined, done: true }
```

因为`投掷(ⅆ)`基本上注入`把..`代替`产量1`生成器的行,没有处理这个异常,它立即传播到调用代码,它用`试试. 赶上`. 

不像`返回(..)`,迭代器的`投掷(ⅆ)`方法从不自动调用. 

当然,虽然没有在前一段代码中显示,如果`最后尝试..`当你打电话时,子句在发电机内部等待. `投掷(ⅆ)`,的`最后`子句在将异常传播回调用代码之前将有机会完成. 

### 错误处理

正如我们已经暗示的,对生成器的错误处理可以用`试试. 赶上`在入站和出站方向上工作: 

```js
function *foo() {
	try {
		yield 1;
	}
	catch (err) {
		console.log( err );
	}

	yield 2;

	throw "Hello!";
}

var it = foo();

it.next();				// { value: 1, done: false }

try {
	it.throw( "Hi!" );	// Hi!
						// { value: 2, done: false }
	it.next();

	console.log( "never gets here" );
}
catch (err) {
	console.log( err );	// Hello!
}
```

错误也可以通过两个方向传播. `产量*`代表团: 

```js
function *foo() {
	try {
		yield 1;
	}
	catch (err) {
		console.log( err );
	}

	yield 2;

	throw "foo: e2";
}

function *bar() {
	try {
		yield *foo();

		console.log( "never gets here" );
	}
	catch (err) {
		console.log( err );
	}
}

var it = bar();

try {
	it.next();			// { value: 1, done: false }

	it.throw( "e1" );	// e1
						// { value: 2, done: false }

	it.next();			// foo: e2
						// { value: undefined, done: true }
}
catch (err) {
	console.log( "never gets here" );
}

it.next();				// { value: undefined, done: true }
```

什么时候`* foo()`电话`产量1`,的`一`价值通过`* bar()`未触及,正如我们已经看到. 

但是这个片段最有趣的是`* foo()`电话`扔"富: E2"`这个错误传播到`* bar()`立即被`* bar()`的`试试. 赶上`块. 这个错误没有通过. `* bar()`像`一`值没有. 

`* bar()`的`抓住`然后正常输出`犯错`(`"E2"`)然后`* bar()`正常完成,这就是为什么`{值: 未定义的,已完成的: 真}`迭代器结果返回`next()它. `. 

如果`* bar()`没有一个`试试. 赶上`围绕`屈服..`表达式,错误当然会传播出去,并通过它的方式仍然会完成(中止). `* bar()`. 

### transpiling发电机

这可能代表了一种发电机的能力之前,6?事实证明它是,而且有几个伟大的工具,这样做,包括最明显的脸谱网的再生工具. <https://facebook.github.io/regenerator/>). 

但是,为了更好地理解发电机,让我们试试手动转换. 基本上,我们将创建一个简单的基于闭包的状态机. 

我们会让源代码非常简单: 

```js
function *foo() {
	var x = yield 42;
	console.log( x );
}
```

首先,我们需要一个名为`foo()`我们可以执行,它需要返回一个迭代器: 

```js
function foo() {
	// ..

	return {
		next: function(v) {
			// ..
		}

		// we'll skip `return(..)` and `throw(..)`
	};
}
```

现在,我们需要一些内部变量来跟踪我们在"生成器"逻辑的步骤中的位置. 我们称之为`状态`. 将有三个州: `零`最初,`一`等着完成`产量`表达,并`二`一旦发电机完成. 

每一次`下一个(..)`调用,我们需要处理下一步,然后增量`状态`. 为了方便起见,我们将每一步放入`案例`条款一`转换`语句,我们将在一个内部函数中调用它`nextstate(..)`那个`下一个(..)`可以打电话. 同时,因为`X`是整个变量. `nextstate(..)`功能. 

这里是一起(显然有些简化,以保持概念说明更清楚): 

```js
function foo() {
	function nextState(v) {
		switch (state) {
			case 0:
				state++;

				// the `yield` expression
				return 42;
			case 1:
				state++;

				// `yield` expression fulfilled
				x = v;
				console.log( x );

				// the implicit `return`
				return undefined;

			// no need to handle state `2`
		}
	}

	var state = 0, x;

	return {
		next: function(v) {
			var ret = nextState( v );

			return { value: ret, done: (state == 2) };
		}

		// we'll skip `return(..)` and `throw(..)`
	};
}
```

最后,让我们来测试我们的pre-es6"发电机": 

```js
var it = foo();

it.next();				// { value: 42, done: false }

it.next( 10 );			// 10
						// { value: undefined, done: true }
```

不错,对吧?希望这个练习巩固在你的心中,其实只是简单的语法生成状态机逻辑. 这使得它们广泛适用. 

### 发电机的使用

所以,现在我们更深入地了解发电机是如何工作的,它们有什么用呢?

我们看到了两种主要模式: 

-   _产生一系列价值观: _这种用法可以是简单的(例如,随机字符串或递增数字),也可以表示更结构化的数据访问(例如,从数据库查询返回的行迭代). 

    无论哪种方式,我们都使用迭代器来控制生成器,以便在每次调用时都可以调用一些逻辑. `下一个(..)`. 数据结构上的正常迭代器只需在没有任何控制逻辑的情况下拉动值. 

-   _连续执行任务的队列: _这种用法通常表示算法中步骤的流程控制,其中每一步都需要从外部源检索数据. 每个数据的实现可以是即时的,也可以是异步延迟的. 

    从发电机内的代码的角度看,同步或异步在细节`产量`完全不透明的点. 此外,这些细节被有意地抽象掉,例如,不掩盖这些实现复杂的步骤的自然顺序表达式. 抽象也意味着实现可以交换/重构往往没有接触代码生成器中的所有. 

当根据这些用途查看生成器时,它们不仅仅是手动状态机的一种不同的或更好的语法. 它们是一种强大的抽象工具,用于组织和控制数据的有序生产和消费. 

## 模块

我不认为夸张地指出所有JavaScript中最重要的代码组织模式是,而且一直是模块. 对于我自己,我认为对于社区的一个大截面来说,模块模式驱动了绝大部分代码. 

### 旧的方式

传统的模块模式是基于一个具有内部变量和函数的外部函数,以及返回的"公共API",其中包含对内部数据和功能关闭的方法. 它经常像这样表达: 

```js
function Hello(name) {
	function greeting() {
		console.log( "Hello " + name + "!" );
	}

	// public API
	return {
		greeting: greeting
	};
}

var me = Hello( "Kyle" );
me.greeting();			// Hello Kyle!
```

这`你好(ⅆ)`模块可以通过调用后续时间生成多个实例. 有时候,一个模块只要求一个单独的(即,它只需要一个实例),在这种情况下,在前一段的轻微变化,使用寿命,是普通: 

```js
var me = (function Hello(name){
	function greeting() {
		console.log( "Hello " + name + "!" );
	}

	// public API
	return {
		greeting: greeting
	};
})( "Kyle" );

me.greeting();			// Hello Kyle!
```

这种模式是经过考验和考验的. 它还具有足够的灵活性,可以为多种不同场景提供多种变体. 

其中最常见的是异步模块定义(AMD),另一个是通用模块定义(UMD). 我们不会介绍这些模式和技术的细节,但它们在很多地方都有广泛的在线解释. 

### 前进

截至6,我们不再需要依靠外围函数和闭包提供模块支持. ES6模块有一流的语法和功能支持. 

在我们进入具体的语法,重要的是要明白一些相当重要的概念差异ES6模块相比,你可能在处理过去的模块: 

-   6采用基于文件的模块,每一模块文件的意义. 此时,没有标准化的方法将多个模块组合成一个文件. 

    这意味着,如果你要直接ES6模块加载到浏览器的Web应用程序,您将加载它们单独不能作为一个大包裹在一个单一的文件已在性能优化的努力. 

    预计在同一个时间到来的HTTP / 2将大大减轻任何这样的性能关注,因为它在一个持久的套接字连接操作,因此可以非常有效地加载多个较小的文件并行,相互交错. 

-   一个6模块API是静态的. 也就是说,静态地定义模块顶层公共API上所有顶层导出的内容,这些不能在以后修改. 

    有些用法习惯于能够提供动态API定义,其中可以根据运行时条件添加/删除/替换方法. 这些应用将不得不改变符合ES6静态API,或者他们会抑制动态变化的二级对象属性/方法. 

-   ES6模块是单身. 也就是说,模块只有一个实例,它保持它的状态. 每次将该模块导入另一个模块时,都会得到一个集中实例的引用. 如果您希望能够生成多个模块实例,那么您的模块将需要提供某种类型的工厂来完成它. 
-   您在模块的公共API上暴露的属性和方法不仅仅是值或引用的常规赋值. 他们是真实的

    在pre-es6模块,如果你把一个属性在您的公共API,拥有原始的价值就像一个数字或字符串,财产分配的值的副本,以及任何内部更新相应的变量是独立的ㄡ不影响公共的API对象复制. 

    与6,出口当地的私有变量,即使它目前持有原始字符串/数字/等,出口的绑定变量. 如果模块更改了变量的值,外部导入绑定现在解析为新值. 

-   导入模块与静态请求加载相同(如果还没有). 如果您在浏览器中,这意味着网络上的阻塞负载. 如果您在服务器上(也就是节点js),它是文件系统的阻塞负载. 

    但是,不要对性能的影响感到恐慌. 因为6模块的静态定义,进口需求可以静态扫描,和负载会发生之前,甚至在你使用的模块. 

    6实际上并没有指定或处理这些请求的工作机制. 有一个模块加载一个单独的概念,其中每个托管环境(浏览器ㄡNode.js等)提供了一个适当的环境默认装载机. 一个模块的导入使用一个字符串值来表示在哪里获取模块(URLㄡ文件路径等),但是这个值在程序中是不透明的,只对装载机本身有意义. 

    如果您想要比默认加载程序提供更多的细粒度控制,您可以定义自己的自定义加载程序ℴℴ这基本上没有,因为它完全隐藏在程序代码中. 

你可以看到,6模块将服务于组织的整体封装代码的使用情况,控制公共API,并引用依赖进口. 但是他们有一种非常特殊的方式,这可能与你多年来一直在做模块的方式很不一致. 

#### CommonJS

有一个类似,但不完全兼容,模块的语法称为CommonJS,即那些在Node.js生态系统熟悉. 

对于一个更委婉的方式说这个不足,从长远来看,ES6模块基本上会取代所有以前的格式和标准模块,甚至CommonJS,因为它们是建立在语言的语法支持. 如果没有别的原因,这将是不可避免的胜利. 

不过,我们面临着相当长的一段路要走到那一步. 字面上有在服务器端JavaScript世界数百数千CommonJS模块和风格,10次不同的格式标准,许多模块(UMDㄡAMDㄡAd Hoc)在浏览器上. 过渡期要花很多年才能取得重大进展. 

在过渡期间,模块transpilers /转换器将是绝对必要的. 你最好还是习惯新的现实. 你是否作者普通模块ㄡAMDㄡUMDㄡCommonJS,或6,这些工具将解析和转换格式,适用于任何环境,你的代码将运行在. 

对于Node.js来说,这可能意味着(现在),目标是CommonJS. 在浏览器中,它可能是UMD或AMD. 随着这些工具的成熟和最佳实践的出现,在接下来的几年里会有很多的变化. 

从这里出发,对模块我的最好的建议是: 无论你一直虔诚地附格式具有很强的亲和力,同时培养欣赏和理解ES6模块,如他们,让你的其他模块倾向褪色. 他们_是_js中的模块的未来,即使现实是有点偏离. 

### 新方式

两个主要的新的关键词,使ES6模块`进口`和`出口`. 语法有很多细微差别,所以让我们深入看看. 

**警告: **一个很容易忽略的重要细节: 两者都`进口`和`出口`必须始终出现在各自使用的顶级范围内. 例如,您不能放置任何一个`进口`或`出口`在一个`如果`条件;它们必须出现在所有块和函数的外面. 

#### `出口`ING API成员

这个`出口`关键字要么放在声明的前面,要么作为一个操作符(种类),导出一个特殊的绑定列表. 考虑: 

```js
export function foo() {
	// ..
}

export var awesome = 42;

var bar = [1,2,3];
export { bar };
```

表达同一出口的另一种方式: 

```js
function foo() {
	// ..
}

var awesome = 42;
var bar = [1,2,3];

export { foo, awesome, bar };
```

这些都叫做_叫出口_因为您实际上导出了变量/函数的名称绑定等. 

任何你不喜欢的_标签_具有`出口`在模块的范围内保持私有. 也就是说,虽然有点像`varⅆ`看起来它在顶级全局范围内声明,顶层范围实际上是模块本身,模块中没有全局范围. 

**注: **模块_做_还有机会`窗口`和所有的"全局"挂了,只是没有词汇层次范围. 但是,你真的应该远离你的模块的全局变量如果在所有可能的. 

还可以在命名导出期间重命名模块成员(又名别名): 

```js
function foo() { .. }

export { foo as bar };
```

当这个模块被导入时,只有`文学士`可以导入成员名;`Foo`隐藏在模块内. 

模块导出不仅仅是值或引用的常规赋值,正如您习惯于`=`赋值操作符. 实际上,当你导出某个东西时,你正在导出一个绑定(像一个指针)到那个东西(变量,等等). 

在模块中,如果更改变量的值,您已经将绑定导出为,即使它已经导入(请参阅下一节),导入的绑定将解析为当前(更新的)值. 

考虑: 

```js
var awesome = 42;
export { awesome };

// later
awesome = 100;
```

当这个模块被导入时,不管它是在之前还是之后`可怕的= 100`设置,一旦赋值发生,导入的绑定将解析为`一百`价值,不`四十二`. 

这是因为绑定本质上是指向或指向`令人惊叹的`变量本身,而不是其值的副本. 这是JS介绍ES6模块绑定是前所未有的概念. 

虽然你可以清楚地使用`出口`多次在一个模块的定义,肯定喜欢ES6模块具有单一出口的方法,其中一种被称为_默认的出口_. 在一些TC39委员会成员的话,你的回报更简单`进口`语法"如果您遵循该模式,反之则"惩罚"更详细的语法,如果你不这样做. 

默认导出将特定导出的绑定设置为导入模块时的默认值. 绑定的名称是字面上的. `违约`. 稍后您将看到,当导入模块绑定时,您也可以重命名它们,因为通常您将使用默认导出. 

只有一个`违约`每个模块定义. 我们将覆盖`进口`在下一节中,您将看到`进口`如果模块具有默认导出,则语法更简洁. 

默认导出语法有一个细微的差别,您应该密切注意. 比较这两个片段: 

```js
function foo(..) {
	// ..
}

export default foo;
```

而这个: 

```js
function foo(..) {
	// ..
}

export { foo as default };
```

在第一段代码中,您正在导出一个到函数表达式值的绑定,_不_该标识符`Foo`. 换言之,`出口默认..`接受表达式. 如果您稍后分配`Foo`对于模块内部的不同值,模块导入仍然显示最初导出的函数,而不是新值. 

顺便说一下,第一段代码也可以写成: 

```js
export default function foo(..) {
	// ..
}
```

**警告: **虽然`函数foo ..`这里的部分技术上是一个函数表达式,为了模块的内部作用域,它被当作一个函数声明,在`Foo`名称绑定在模块的顶级范围(通常称为"提升"). 这同样适用于`导出默认类富ⅆ`. 然而,虽然你_可以_做`导出var =ⅆ`你现在做不到`导出默认值ⅆ`(或`让`或`const`在一个令人沮丧的不一致的情况下. 在写这篇文章的时候,已经有能力在不久的加入,讨论post-es6,一致的缘故. 

再回忆第二段代码: 

```js
function foo(..) {
	// ..
}

export { foo as default };
```

在这个版本的模块导出中,默认导出绑定实际上是`Foo`标识符,而不是它的值,因此您得到前面描述的绑定行为(即,如果您稍后更改)`Foo`的值,在导入方面看到的值也将被更新). 

在默认情况下口语法必须非常小心,这个微妙的问题,尤其是如果你的逻辑要求出口值被更新. 如果您从未计划更新默认导出值,`出口默认..`是好的. 如果确实计划更新值,则必须使用`出口{ ..作为默认}`. 无论哪种方式,一定要注释你的代码来解释你的意图!

因为只有一个`违约`每一个模块,您可能会试图用一个默认的导出对象来设计您的模块,并使用它的所有API方法,例如: 

```js
export default {
	foo() { .. },
	bar() { .. },
	..
};
```

这种模式似乎地图密切如何已经有很多开发商pre-es6模块构成,所以它看起来像一个自然的方法. 不幸的是,它有一些缺点和正式气馁. 

特别是,js引擎不能静态地分析普通对象的内容,这意味着它不能对静态对象进行一些优化. `进口`性能.使每个成员分别显式导出的优点是引擎. _可以_进行静态分析和优化. 

如果您的API已经有一个以上的成员,那么这些原则ℴℴ每个模块的默认导出和所有的API成员作为命名导出ℴℴ都是冲突的,不是吗?但你_可以_有一个默认的导出和其他命名的导出;它们不是互斥的. 

因此,而不是这种(气馁)模式: 

```js
export default function foo() { .. }

foo.bar = function() { .. };
foo.baz = function() { .. };
```

你可以做: 

```js
export default function foo() { .. }

export function bar() { .. }
export function baz() { .. }
```

**注: **在前面的代码段中,我使用了这个名称`Foo`为了那个功能`违约`标签.那`Foo`但是,为了出口目的,名称被忽略了ℴℴ`违约`实际上是导出名称. 导入这个默认绑定时,您可以给它任何您想要的名称,您将在下一节中看到. 

或者,有些将提前. 

```js
function foo() { .. }
function bar() { .. }
function baz() { .. }

export { foo as default, bar, baz, .. };
```

当我们覆盖时,混合缺省和命名导出的效果会更清楚. `进口`不久. 但本质上,这意味着最简洁的默认导入表单只会检索`foo()`功能. 用户还可以手动列出`酒吧`和`巴兹`作为命名导入,如果他们想要它们. 

您可以想象,如果您有许多命名导出绑定,那么模块的使用者将会多么乏味. 有一个通配符导入表单,在一个命名空间对象中导入所有模块的导出,但无法将通配符导入到顶级绑定中. 

再次,ES6模块机制是故意设计来阻止模块大量出口;相对而言,它希望这种方法会困难一点,作为一种社会工程,鼓励在大型/复杂的模块设计,喜欢简单的模块设计. 

我可能建议您不要将默认导出与指定的导出相混合,特别是如果您有一个大型API,而将模块分解为单独的模块是不切实际的. 在这种情况下,只需使用所有命名的导出,并记录您的模块的用户可能应该使用`导入*作为ⅆ`(命名空间导入,在下一节中讨论)使整个API同时出现在一个命名空间上的方法. 

我们早些时候提到过,但让我们更详细地回顾一下. 比其他的`出口默认ⅆ`导出表达式值绑定的表单,所有其他导出表单都将绑定导出到本地标识符. 对于这些绑定,如果在导出后更改模块内的变量的值,则外部导入绑定将访问更新的值: 

```js
var foo = 42;
export { foo as default };

export var bar = "hello world";

foo = 10;
bar = "cool";
```

导入这个模块时,`违约`和`酒吧`导出将绑定到本地变量. `Foo`和`酒吧`意思是他们会显示更新的`十`和`"酷"`价值观. 导出时的值是不相关的. 进口时的值是不相关的. 绑定是动态链接,所以重要的是访问绑定时当前值是什么. 

**警告: **不允许双向绑定. 如果你输入一个`Foo`从模块中,尝试更改导入的值. `Foo`变量,将抛出一个错误!我们将在下一节重新讨论这个问题. 

您还可以重新导出另一个模块的导出,例如: 

```js
export { foo, bar } from "baz";
export { foo as FOO, bar as BAR } from "baz";
export * from "baz";
```

这些表单类似于首次从`"巴兹"`模块然后显式列出它的成员以便从模块导出. 然而,在这些形式中,`"巴兹"`模块永远不会导入到模块的本地范围;它们可以通过非接触的方式. 

#### `进口`ING API成员

要导入一个模块,可以毫不奇怪地使用`进口`声明. 正如`出口`有几个微妙的变化,也`进口`所以,花大量的时间考虑以下问题,并尝试一下你的选择. 

如果希望将模块API的特定命名成员导入顶级范围,则使用此语法: 

```js
import { foo, bar, baz } from "foo";
```

**警告: **这个`{ ..}`语法这可能看起来像一个文字对象,甚至对象解构语法. 然而,它的形式对于模块来说是特别的,所以要小心不要混淆它. `{ ..}`图案的地方. 

这个`"foo"`字符串被称为_模块名_. 因为整个目标是静态分析的句法模块说明符必须是一个字符串;它不可能是一个变量的字符串值. 

从你的角度和6码的JS引擎本身,这个字符串的内容是完全不透明的,毫无意义的. 模块加载器将把这个字符串解释为在哪里找到所需模块的指令,无论是作为URL路径还是本地文件系统路径. 

这个`Foo`,`酒吧`,和`巴兹`列出的标识符必须与模块API上的指定导出匹配(静态分析和错误断言应用). 它们被绑定为当前范围中的顶级标识符: 

```js
import { foo } from "foo";

foo();
```

您可以重命名导入的绑定标识符,如: 

```js
import { foo as theFooFunc } from "foo";

theFooFunc();
```

如果模块只有默认的导出,您希望导入并绑定到标识符,则可以选择跳过`{ ..}`该绑定的周围语法. 这个`进口`在这个优选的情况下,得到了最好的和最简洁的`进口`语法形式: 

```js
import foo from "foo";

// or:
import { default as foo } from "foo";
```

**注: **如前一节所述,`违约`模块中的关键字`出口`指定名称为实际名称的导出. `违约`如第二个更详细的语法选项所示. 重命名的`违约`在这种情况下,`Foo`在后一个语法中是明确的,在前一个语法中是相同的,但却是隐式的. 

如果模块具有这样的定义,也可以导入默认导出和其他命名的导出. 从较早阶段回顾这个模块定义: 

```js
export default function foo() { .. }

export function bar() { .. }
export function baz() { .. }
```

导入该模块的默认导出及其两个指定的导出: 

```js
import FOOFN, { bar, baz as BAZ } from "foo";

FOOFN();
bar();
BAZ();
```

强烈建议的方法从6模块的理念是,你只有进口特定的绑定从模块,你需要. 如果一个模块提供了10种API方法,但您只需要其中两种,有些人认为这是浪费. 

除了代码更明确之外,还有一个好处是,窄的导入使静态分析和错误检测(例如,意外使用错误的绑定名)更健壮. 

当然,这只是标准位置ES6设计理念的影响;什么都需要坚持,方法. 

许多开发人员会很快指出,这种方法可能更繁琐,要求您定期重新访问和更新您的`进口`每当你意识到你需要一个模块的其他东西时. 交换是为了方便. 

在这种情况下,首选项可能是将模块中的所有内容导入单个名称空间,而不是直接导入单个成员,每个成员都直接进入范围. 幸运的是,这`进口`语句有一个语法变体,可以支持这种样式的模块消耗,称为_命名空间导入_. 

考虑一个`"foo"`模块导出为: 

```js
export function bar() { .. }
export var x = 42;
export function baz() { .. }
```

您可以将整个API导入到单个模块名称空间绑定中: 

```js
import * as foo from "foo";

foo.bar();
foo.x;			// 42
foo.baz();
```

**注: **这个`* ..`条款要求`*`通配符. 换句话说,你不能做某事. `从"富"导入{条ㄡx }作为`只引入部分API,但仍然绑定到`Foo`命名空间. 我就喜欢这样的东西,但它的所有或任何与6命名空间导入. 

如果您要导入的模块`* ..`具有默认导出,它被命名为`违约`在指定的命名空间中. 您还可以将命名空间绑定之外的默认导入命名为顶级标识符. 考虑一个`"世界"`模块导出为: 

```js
export default function foo() { .. }
export function bar() { .. }
export function baz() { .. }
```

这`进口`: 

```js
import foofn, * as hello from "world";

foofn();
hello.default();
hello.bar();
hello.baz();
```

虽然这个语法是有效的,但是模块的一种方法(默认导出)绑定在您的作用域的顶层,而其余的命名导出(和一个调用)是相当混乱的. `违约`)以不同名称绑定为属性(`你好`标识符命名空间. 

正如我前面提到的,我的建议是避免用这种方式设计模块导出,以减少模块用户遭受这些奇怪异常的机会. 

所有导入的绑定都是不可变的和/或只读的. 考虑前面的导入;所有这些后续分配尝试都将抛出`TypeError`S: 

```js
import foofn, * as hello from "world";

foofn = 42;			// (runtime) TypeError!
hello.default = 42;	// (runtime) TypeError!
hello.bar = 42;		// (runtime) TypeError!
hello.baz = 42;		// (runtime) TypeError!
```

早些时候在"`出口`我们讨论了如何`酒吧`和`巴兹`绑定绑定到内部的实际标识符. `"世界"`模块. 这意味着如果模块改变了这些值,`hello.bar`和`hello.baz`现在引用更新的值. 

但是,本地导入绑定的不可变/只读特性强制您不能从导入绑定中更改它们,因此`TypeError`这是非常重要的,因为没有这些保护,您的更改将最终影响模块的所有其他用户(记住: 单件),这可能会产生一些非常令人惊讶的副作用!

此外,虽然一个模块_可以_从内部更改它的API成员,您应该非常谨慎地以这种方式故意设计模块. ES6模块_预期_是静态的,所以偏离原则应该是罕见的,应仔细并详细记录. 

**警告: **有一些模块设计理念,您实际上打算让消费者改变API上的属性值,或者模块API被设计成"扩展",将其他"插件"添加到API名称空间中. 我们断言,ES6模块API应该是思想和设计为静态不变的,严重制约和阻碍了这些替代模块的设计模式. 您可以通过导出一个普通对象来绕过这些限制,当然可以随意更改. 但是在走那条路之前要小心,三思而后行. 

由于一个结果而发生的声明`进口`"悬挂"(见_范围和关闭_本系列的标题). 考虑: 

```js
foo();

import { foo } from "foo";
```

`foo()`可以运行,因为不仅静态分辨率的`进口..`语句找出什么`Foo`是在编译过程中,但它也将声明"挂起"到模块的作用域的顶部,从而使它在整个模块中可用. 

最后,最基本的形式`进口`看起来像这样: 

```js
import "foo";
```

此表单实际上不会将任何模块的绑定导入到您的范围. 它加载(如果尚未加载),编译(如果尚未编译),并计算(如果尚未运行)`"foo"`模块. 

一般来说,这种进口可能不会太有用. 可能存在一个模块定义的副作用(例如给`窗口`/全局对象). 你也可以设想使用`导入"富"`作为一种模块的预加载,稍后可能需要. 

### 循环模块依赖

A进口B进口A. 这实际上如何工作?

我要说的是,有意循环依赖的系统设计通常是我试图避免的. 话虽如此,我承认人们这样做是有原因的,它能解决这个问题. 

让我们考虑如何处理这6. 首先,模块`"一个"`: 

```js
import bar from "B";

export default function foo(x) {
	if (x > 10) return bar( x - 1 );
	return x * 2;
}
```

现在,模块`"B"`: 

```js
import foo from "A";

export default function bar(y) {
	if (y > 5) return foo( y / 2 );
	return y * 3;
}
```

这两项职能,`富(ⅆ)`和`酒吧(ⅆ)`如果它们在同一作用域中,则将作为标准函数声明工作,因为这些声明被"提升"到整个范围,因此不管创作顺序如何,都可以相互利用. 

模块,你在完全不同的领域有宣言,所以6要做额外的工作来帮助这些循环引用的工作. 

在一个粗略的概念上,这就是循环. `进口`依赖项被验证和解决: 

-   如果`"一个"`首先加载模块,第一步是扫描文件并分析所有导出,因此它可以注册所有可用的绑定. 然后它处理`进口..从"B"`这表明它需要去取`"B"`. 
-   一旦发动机负荷`"B"`它对导出绑定做了同样的分析. 当它看到`进口..从"A"`它知道`"一个"`这样就可以验证了`进口`是有效的. 现在它知道了`"B"`API,它也可以验证`进口..从"B"`在等待`"一个"`模块. 

实质上是相互导入,同时进行静态验证来验证两者. `进口`语句,实际上构成两个独立的模块作用域(通过绑定),这样`富(ⅆ)`可以打电话`酒吧(ⅆ)`反之亦然. 这是对称的,如果它们最初声明在同一范围内. 

现在让我们一起使用这两个模块. 首先,我们会试试看. `富(ⅆ)`: 

```js
import foo from "foo";
foo( 25 );				// 11
```

或者我们可以试试`酒吧(ⅆ)`: 

```js
import bar from "bar";
bar( 25 );				// 11.5
```

到那时`美孚(25)`或`酒吧(25)`调用已执行,所有模块的分析/编译都已完成. 这意味着`富(ⅆ)`内部直接了解`酒吧(ⅆ)`和`酒吧(ⅆ)`内部直接了解`富(ⅆ)`. 

如果我们需要的只是与`富(ⅆ)`那么我们只需要导入`"foo"`模块. 同样,`酒吧(ⅆ)`和`"酒吧"`模块. 

当然,我们_可以_如果我们想引进和使用它们: 

```js
import foo from "foo";
import bar from "bar";

foo( 25 );				// 11
bar( 25 );				// 11.5
```

的静态加载语义`进口`语句意味着`"foo"`和`"酒吧"`互相依赖`进口`将确保它们在运行之前先加载ㄡ解析和编译. 因此,它们的循环依赖性是静态解决的,这正如您所期望的那样工作. 

### 模块加载

我们在"模块"一节的开头断言`进口`语句使用一个单独的机制,由宿主环境提供的(浏览器,js,等),来解决模块符字符串转化为查找和加载所需的模块的一些有用的教学. 这个机制就是这个系统. _模块加载器_. 

环境所提供的默认模块加载器将解释模块说明符为URL在浏览器,和(通常)作为一个本地文件路径,如果在服务器如Node.js. 默认行为是假设加载的文件撰写的ES6标准模块的格式. 

此外,您还可以通过HTML标记加载模块到浏览器中,类似于当前脚本程序是如何加载的. 在撰写本文的时候,还不完全清楚这个标记是否是`<脚本类型="模块">`或`<模块>`. 6不控制决定的,但是在适当的标准机构的讨论已经沿平行ES6. 

不管标签看起来是什么样子,您可以确信在封面下它将使用默认的加载程序(或者您预先指定的定制的加载程序,我们将在下一节中讨论). 

就像你会用标签标记,模块加载器本身不是由指定的ES6. 这是一个单独的ㄡ平行的标准. <http://whatwg.github.io/loader/>)由WHATWG浏览器标准集团目前控制. 

在撰写本文时,下面的讨论反映了API设计的早期进展,而且情况可能会发生变化. 

#### 模块外加载模块

与模块加载器直接交互的一个用途是如果非模块需要加载模块. 考虑: 

```js
// normal script loaded in browser via `<script>`,
// `import` is illegal here

Reflect.Loader.import( "foo" ) // returns a promise for `"foo"`
.then( function(foo){
	foo.bar();
} );
```

这个`反射载入器. 导入(..)`实用程序将整个模块导入命名参数(作为名称空间),就像`导入*作为ⅆ`我们前面讨论过的命名空间导入. 

**注: **这个`反射载入器. 导入(..)`实用程序返回一个承诺,在模块就绪后完成. 要导入多个模块,您可以从多个`反射载入器. 导入(..)`电话使用`承诺(全部)])`. 有关承诺的更多信息,请参见第4章中的"承诺". 

你也可以用`反射载入器. 导入(..)`在动态/有条件加载模块的实际模块中`进口`本身行不通. 你可以,例如,选择加载一个模块包含一些ES7 +特征polyfill如果特征测试显示它不是由当前引擎定义. 

出于性能原因,您可能希望尽可能避免动态加载,因为这会妨碍js引擎从静态分析中触发早期获取的能力. 

#### 定制的加载

直接与TH交互的另一个用途

在写这篇文章的时候,有一个模块加载器API开发polyfill([https://github.com/moduleloader/es6-module-loader](https://github.com/ModuleLoader/es6-module-loader)). 虽然细节是稀缺的,而且极易发生变化,但我们可以探索最终可能出现的可能性. 

这个`反射载入器. 导入(..)`调用可以支持第二个参数,用于指定各种选项来定制导入/加载任务. 例如:

```js
Reflect.Loader.import( "foo", { address: "/path/to/foo.js" } )
.then( function(foo){
	// ..
} )
```

这也将是一个定制将提供(通过某种手段)连接到加载模块的过程,在翻译/ transpilation能负荷后但在引擎编译模块发生. 

例如,你可以下载东西,不是已经6兼容模块的格式(例如,CoffeeScriptㄡTypeScriptㄡCommonJS,AMD). 你的翻译步骤可以再把它转换为进行发动机ES6标准模块. 

## 类

从JavaScript的开始,语法和开发模式都努力(阅读: 挣扎)以支持面向类的开发. 这样的事情`新的`和`运算符`和一个`构造函数. `物业,谁不能不被嘲笑JS有隐藏在其原型系统内部的地方?

当然,js"类"与经典类几乎不一样. 差异是有据可查的,所以我就不赘述,点再这里. 

**注: **要了解更多关于JS使用的模式来伪造"类",以及另一种原型称为"委托"的视图,请参见_对象原型_本系列的标题. 

### `班`

虽然js的原型机制不象传统类那样工作,但这并不能阻止语言对语言语法扩展的强烈需求,从而表示"类"看起来更像真正的类. 进入6`班`关键字及其关联机制. 

这个特性是一个非常有争议和旷日持久的辩论的结果,代表了对如何接近JS类的几个强烈反对意见的折中. 大多数希望使用js完整类的开发人员会发现新语法的部分非常吸引人,但仍会发现重要的部分仍然丢失. 不过别担心. TC39是已经工作的附加功能,增加在post-es6周期类. 

在新的6类机制的核心是`班`关键字,它标识一个_块_其中内容定义函数原型的成员. 考虑: 

```js
class Foo {
	constructor(a,b) {
		this.x = a;
		this.y = b;
	}

	gimmeXY() {
		return this.x * this.y;
	}
}
```

值得注意的事情: 

-   `类Foo`意味着创建名称的一个(特殊)函数. `Foo`,就像你pre-es6. 
-   `构造函数(..)`标识该签名`富(ⅆ)`函数及其主体内容. 
-   类方法使用与对象文本相同的"简明方法"语法,如第2章所讨论的那样. 这也包括简洁的发电形式本章先前所讨论的,以及ES5的getter和setter语法. 然而,类方法是不可枚举而对象方法默认是枚举. 
-   与对象文本不同,在一个`班`体!事实上,他们甚至不被允许. 

这个`班`在前一段的语法定义,大致可以认为这pre-es6等效,这可能会对那些已经完成了原型编码风格在相当熟悉: 

```js
function Foo(a,b) {
	this.x = a;
	this.y = b;
}

Foo.prototype.gimmeXY = function() {
	return this.x * this.y;
}
```

无论是在pre-es6形式或新的ES6`班`表单,这个"类"现在可以被实例化和使用,正如您所期望的那样: 

```js
var f = new Foo( 5, 15 );

f.x;						// 5
f.y;						// 15
f.gimmeXY();				// 75
```

谨慎!虽然`类Foo`看起来很像`功能foo()`有重要的区别: 

-   一`富(ⅆ)`呼叫`类Foo` _必须_是用`新的`,为pre-es6选项`调用foo(obj). `将_不_工作. 
-   而`函数foo`"悬挂"(见_范围和关闭_本系列的标题),`类Foo`不是;`延伸..`子句指定不能被"挂起"的表达式. 因此,必须声明`班`在您实例化它之前. 
-   `类Foo`在全局范围内创建词法`Foo`此范围内的标识符,但不象`函数foo`不创建该名称的全局对象属性. 

建立`运算符`运营商还与6类,因为`班`只创建同名的构造函数. 然而,6介绍了一种自定义`运算符`作品中,使用`symbol.hasinstance`(见第7章中的"众所周知的符号"). 

另一种思考方式`班`我觉得更方便,是_宏_用于自动填充一个`原型`对象. 此外,它还可以连接`[原型]`如果利用关系`延伸`(见下一节). 

一个6`班`它不是实体本身,而是一个封装在其他具体实体(如函数和属性)并将它们绑定在一起的元概念. 

**提示: **除了申报表外,A`班`也可以是表达式,如: `类=ⅆ}`. 本文通过定义一个类是非常有用的(从技术上讲,构造函数本身)作为函数参数或布置

### `延伸`和`超级的`

6类也有语法糖建立`[原型]`代表团之间的联系,两个函数原型ℴℴ通常贴错标签的"继承"或是"原型继承"ℴℴ使用面向类的常见术语`延伸`: 

```js
class Bar extends Foo {
	constructor(a,b,c) {
		super( a, b );
		this.z = c;
	}

	gimmeXYZ() {
		return super.gimmeXY() * this.z;
	}
}

var b = new Bar( 5, 15, 25 );

b.x;						// 5
b.y;						// 15
b.z;						// 25
b.gimmeXYZ();				// 1875
```

一个重要的新增加是`超级的`,这实际上是不可能的(没有直接pre-es6一些不幸的黑客权衡). 构造函数中,`超级的`自动引用"父构造函数",在前一个示例中`富(ⅆ)`. 在一种方法中,它引用"父对象",这样您就可以使属性/方法访问它,例如`gimmexy()超. `. 

`杆延伸Foo`当然意味着连接`[原型]`属于`bar.prototype`到`foo.prototype`. 所以,`超级的`在类似的方法中`gimmexyz()`具体手段`foo.prototype`,而`超级的`方法`Foo`当用于`酒吧`构造函数. 

**注: ** `超级的`不限于`班`声明. 它也在对象文本中工作,这和我们在这里讨论的方式是一样的. 看到"对象`超级的`"在第2章中获取更多信息. 

#### 有`超级的`龙

注意到这一点并不是微不足道的. `超级的`表现不同,取决于它出现在哪里. 公平地说,大部分时间,这都不是问题. 但如果你偏离一个狭窄的标准,惊喜就等着你. 

可能有一些情况下,您希望引用构造函数中的`foo.prototype`,例如直接访问它的一个属性/方法. 然而,`超级的`在构造函数中不能这样使用;`super.prototype`行不通. `超级(ⅆ)`粗略地调用`新富(..)`,但实际上并不是一个有用的参考. `Foo`本身. 

对称的,您可能需要引用`富(ⅆ)`非构造函数方法中的函数. `super.constructor`将点`富(ⅆ)`函数,但要小心这个函数可以_只有_被调用`新的`. `新建超级构造函数(..)`这将是有效的,但在大多数情况下它不会非常有用,因为您不能使该调用使用或引用当前. `这`对象上下文,这很可能是您想要的. 

也,`超级的`看起来它可能是由函数的上下文驱动的. `这`也就是说,它们都是动态绑定的. 然而,`超级的`不是动态的`这`是.当构造函数或方法生成`超级的`在申报时间内参考(在`班`身体)`超级的`是静态绑定到特定的类层次结构,不能被重写(至少6). 

你什么意思?这意味着,如果你习惯于从一个"类"中提取一个方法,并通过重写它来"借用"另一个类. `这`,说`打电话(ⅆ)`或`应用(ⅆ)`如果你借用的方法有一个,那很可能会创造惊喜. `超级的`在这. 考虑这个类层次结构: 

```js
class ParentA {
	constructor() { this.id = "a"; }
	foo() { console.log( "ParentA:", this.id ); }
}

class ParentB {
	constructor() { this.id = "b"; }
	foo() { console.log( "ParentB:", this.id ); }
}

class ChildA extends ParentA {
	foo() {
		super.foo();
		console.log( "ChildA:", this.id );
	}
}

class ChildB extends ParentB {
	foo() {
		super.foo();
		console.log( "ChildB:", this.id );
	}
}

var a = new ChildA();
a.foo();					// ParentA: a
							// ChildA: a
var b = new ChildB();		// ParentB: b
b.foo();					// ChildB: b
```

在前面的代码段中,所有这些看起来都相当自然和期望. 但是,如果你想借钱`B. foo()`并在上下文中使用`一`ℴℴ凭借动态`这`结合,这样的借贷是很常见的,用在许多不同的方式,包括混合最值得注意的是--你可能会发现一个丑陋的意外结果: 

```js
// borrow `b.foo()` to use in `a` context
b.foo.call( a );			// ParentB: a
							// ChildB: a
```

正如你所看到的,`this.id`参考是动态反弹,使`: 一个`在这两种情况下都有报告. `: B`. 但`B. foo()`的`foo()超. `参考不是动态反弹,所以它仍然报告. `parentb`而不是预期`家长`. 

因为`B. foo()`引用`超级的`它是静态绑定到`childb`/`parentb`层次结构,不能用于反对`ChildA`/`家长`等级制度.没有ES6的解决方法. 

`超级的`如果你有一个没有交叉授粉的静态类层次结构,它似乎能直观地工作. 但平心而论,做某事的主要好处之一是`这`感知编码正是这种灵活性. 简单的,`班`+`超级的`要求你避免这种技术. 

选择可以归结为将对象设计缩小到这些静态层次结构中. `班`,`延伸`,和`超级的`会很好--或丢弃所有试图"假"类而选择灵活的ㄡ动态的ㄡ无阶级的对象`[原型]`委托(参见_对象原型_本系列的标题). 

#### 子类的构造函数

构造函数不需要类或子类;如果省略,构造函数将替换为默认构造函数. 然而,默认的替代构造函数对于直接类和扩展类是不同的. 

具体来说,默认子类构造函数自动调用父构造函数,并传递任何参数. 换句话说,您可以想到类似的默认子类构造函数: 

```js
constructor(...args) {
	super(...args);
}
```

这是一个值得注意的重要细节. 并非所有类语言都有子类构造函数自动调用父构造函数. C++,但java不. 但更重要的是,在pre-es6类,如自动"父类"称不会发生. 小心,当转换成6`班`如果你_不_发生. 

另一个也许令人惊讶的偏差/限制子类的构造函数: ES6构造函数中的一个子类,你不能访问`这`直到`超级(ⅆ)`被称为. 原因是细微的和复杂的,但它归结为一个事实,即父构造函数实际上是创建/初始化实例的一个. `这`. pre-es6,它的相反;`这`对象是由"子类构造函数"创建的,然后您用"子类"的上下文调用一个"父构造函数". `这`. 

让我们举例说明. 这部作品pre-es6: 

```js
function Foo() {
	this.a = 1;
}

function Bar() {
	this.b = 2;
	Foo.call( this );
}

// `Bar` "extends" `Foo`
Bar.prototype = Object.create( Foo.prototype );
```

但这6等效是不允许的: 

```js
class Foo {
	constructor() { this.a = 1; }
}

class Bar extends Foo {
	constructor() {
		this.b = 2;			// not allowed before `super()`
		super();			// to fix swap these two statements
	}
}
```

在这种情况下,修复是简单的. 只需在子类中交换这两个语句`酒吧`构造函数. 然而,如果你一直依赖pre-es6能够跳过调用"父类的构造方法,"小心因为不被允许了. 

#### `延伸`ING的人

这是新产品最受欢迎的好处之一. `班`和`延伸`设计是能力(终于!)内置本地类的子类,比如`阵列`. 考虑: 

```js
class MyCoolArray extends Array {
	first() { return this[0]; }
	last() { return this[this.length - 1]; }
}

var a = new MyCoolArray( 1, 2, 3 );

a.length;					// 3
a;							// [1,2,3]

a.first();					// 1
a.last();					// 3
```

前6,假冒的"类"`阵列`使用手动对象创建和链接`array.prototype`部分工作. 它错过了真实数组的特殊行为,比如自动更新. `长度`财产. 6类应充分与"继承"和增强行为预期!

另一个常见的pre-es6"类"的局限性与`误差`对象,创建自定义错误"子类". `误差`对象被创建,它们自动捕获特殊`堆栈`信息,包括创建错误的行号和文件. pre-es6自定义错误"子"都没有这样的特殊行为,这严重限制了它们的有用性. 

6相救: 

```js
class Oops extends Error {
	constructor(reason) {
		super(reason);
		this.oops = reason;
	}
}

// later:
var ouch = new Oops( "I messed up!" );
throw ouch;
```

这个`哎哟`这段代码中的自定义错误对象将像其他真正的错误对象一样工作,包括捕获. `堆栈`. 这是一个很大的进步!

### `new.target`

介绍了一个新的概念称为6_元的财产_(见第7章),以`new.target`. 

如果这看起来很奇怪,那就是`. `对于js,属性名绝对是一个不正常的模式. 

`new.target`是一个新的"神奇"的价值,可在所有的功能,但在正常的功能,它将永远是`未定义`. 在任何构造函数中,`new.target`总是指向构造函数`新的`实际上直接调用,即使构造函数位于父类中,并且由`超级(ⅆ)`从子构造函数调用. 考虑: 

```js
class Foo {
	constructor() {
		console.log( "Foo: ", new.target.name );
	}
}

class Bar extends Foo {
	constructor() {
		super();
		console.log( "Bar: ", new.target.name );
	}
	baz() {
		console.log( "baz: ", new.target );
	}
}

var a = new Foo();
// Foo: Foo

var b = new Bar();
// Foo: Bar   <-- respects the `new` call-site
// Bar: Bar

b.baz();
// baz: undefined
```

这个`new.target`除了在访问静态属性/方法(见下一节)之外,类属性在类构造函数中没有太多的用途. 

如果`new.target`是`未定义`你知道这个函数没有被调用`新的`. 然后你可以强制`新的`必要时调用. 

### `静止的`

当一个类`酒吧`扩展父类`Foo`我们已经注意到了`bar.prototype`是`[原型]`-链接`foo.prototype`. 但此外,`bar()`是`[原型]`-链接`foo()`. 这一部分可能没有如此明显的推理. 

然而,在您声明的情况下,它非常有用. `静止的`类的方法(不仅仅是属性),因为这些类直接添加到类的函数对象中,而不是函数对象的`原型`对象. 考虑: 

```js
class Foo {
	static cool() { console.log( "cool" ); }
	wow() { console.log( "wow" ); }
}

class Bar extends Foo {
	static awesome() {
		super.cool();
		console.log( "awesome" );
	}
	neat() {
		super.wow();
		console.log( "neat" );
	}
}

Foo.cool();					// "cool"
Bar.cool();					// "cool"
Bar.awesome();				// "cool"
							// "awesome"

var b = new Bar();
b.neat();					// "wow"
							// "neat"

b.awesome;					// undefined
b.cool;						// undefined
```

小心别弄糊涂了. `静止的`成员位于类的原型链上. 它们实际上位于函数构造函数之间的双/并行链中. 

#### `symbol.species`构造函数的吸气剂

一个地方`静止的`有用的是设置`symbol.species`吸气剂(在规范中已知为`@ @物种`)派生(子)类. 此功能允许子类信号父类构造函数应该用什么时候无意子类的构造函数本身--如果任何父类方法需要贩卖的一个新实例. 

例如,许多方法`阵列`创建并返回一个新的`阵列`实例. 如果从派生类定义`阵列`,但你希望这些方法继续鬻实际`阵列`实例,而不是来自派生类,此工作: 

```js
class MyCoolArray extends Array {
	// force `species` to be parent constructor
	static get [Symbol.species]() { return Array; }
}

var a = new MyCoolArray( 1, 2, 3 ),
	b = a.map( function(v){ return v * 2; } );

b instanceof MyCoolArray;	// false
b instanceof Array;			// true
```

为了说明父类方法如何使用子类声明,有些类似. `阵列#地图(..)`正在做,考虑: 

```js
class Foo {
	// defer `species` to derived constructor
	static get [Symbol.species]() { return this; }
	spawn() {
		return new this.constructor[Symbol.species]();
	}
}

class Bar extends Foo {
	// force `species` to be parent constructor
	static get [Symbol.species]() { return Foo; }
}

var a = new Foo();
var b = a.spawn();
b instanceof Foo;					// true

var x = new Bar();
var y = x.spawn();
y instanceof Bar;					// false
y instanceof Foo;					// true
```

父类`symbol.species`做`返回此`按照通常期望的那样,服从任何派生类. `酒吧`然后重写手动声明`Foo`用于此类实例创建. 当然,派生类还可以鬻实例本身使用`新建这个构造函数(..)`. 

## 回顾

6介绍帮助代码组织几个新特点: 

-   迭代器提供对数据或操作的顺序访问. 它们可以被新的语言特性所消耗. `对..`和`ⅆ`. 
-   生成器是由迭代器控制的本地暂停/恢复功能. 它们可以用编程方式(通过交互方式). `产量`/`下一个(..)`消息传递)_生成_通过迭代消耗的值. 
-   模块允许实施私人封装
-   类为基于原型的编码提供了更干净的语法. 此外,`超级的`还解决了相关的参考的棘手问题`[原型]`链. 

这些新的工具应该是你的第一站,当试图通过拥抱6提高你的JS项目的建筑. 
