
# 你不知道JS: ES6与超越

# 8章: 超越ES6

在写这篇文章的时候,最终草案(ES6_ECMAScript 2015_)不久走向最终的正式投票批准由ECMA. 但即使ES6定稿,TC39委员会已经在努力工作的特点和超越ES7 / 2016. 

正如我们在第1章中所讨论的,预期js的进度将从每隔几年更新一次,到每年更新一次正式版本(因此以年为基础). 仅此一点就将彻底改变JS开发人员如何了解并跟上语言的发展. 

但更为重要的是,委员会实际上将按特征进行工作. 一旦某个特性完成了规范,并在几个浏览器中实现了它的功能,那么该特性将被认为足够稳定以便开始使用. 我们强烈鼓励他们在准备就绪后采用功能,而不是等待一些官方标准的投票. 如果你还没有了解到6,时间_过去由于_上船!

在撰写本文的时候,可以看到一份关于未来提案及其地位的清单. [http: / / GitHub. COM/TC39 / ECMA262 #目前的建议](https://github.com/tc39/ecma262#current-proposals)). 

transpilers和polyfills是我们如何将这些新功能,甚至在桥上所有的浏览器都支持了他们. Babel,名,和其他几个主要的transpilers已经为一些最有可能稳定post-es6功能支持. 

考虑到这一点,我们已经到了审视它们的时候了. 让我们跳进去!

**警告: **这些特点都在不同的发展阶段. 虽然它们很可能会降落,而且可能看起来很相似,但这一章的内容中有几粒盐. 这一章将在以后的版本中演变为这些(和其他)!特征确定. 

## `异步函数`S

在第4章的"生成器+承诺"中,我们提到有一个关于生成器模式的直接语法支持的建议. `产量`ING承诺,像一个跑步者一样,将在承诺完成后恢复工作. 让我们简要看看这个建议的特性,称为`异步函数`. 

从第4章回顾这个生成器示例: 

```js
run( function *main() {
	var ret = yield step1();

	try {
		ret = yield step2( ret );
	}
	catch (err) {
		ret = yield step2Failed( err );
	}

	ret = yield Promise.all([
		step3a( ret ),
		step3b( ret ),
		step3c( ret )
	]);

	yield step4( ret );
} )
.then(
	function fulfilled(){
		// `*main()` completed successfully
	},
	function rejected(reason){
		// Oops, something went wrong
	}
);
```

建议`异步函数`语法可以表示相同的流控制逻辑,而不需要`跑步(ⅆ)`实用程序,因为js将自动知道如何寻找等待和恢复的承诺. 考虑: 

```js
async function main() {
	var ret = await step1();

	try {
		ret = await step2( ret );
	}
	catch (err) {
		ret = await step2Failed( err );
	}

	ret = await Promise.all( [
		step3a( ret ),
		step3b( ret ),
		step3c( ret )
	] );

	await step4( ret );
}

main()
.then(
	function fulfilled(){
		// `main()` completed successfully
	},
	function rejected(reason){
		// Oops, something went wrong
	}
);
```

相反的`功能* main() { ..`声明,我们声明`异步函数main() { ..`形式. 而`产量`我们许下诺言`等待`的承诺. 运行函数的调用`main()`事实上,我们可以直接观察到一个承诺. 这相当于我们从一个`跑(主)`呼叫. 

你看到对称了吗?`异步函数`本质上是生成器+承诺+的语法糖`跑步(ⅆ)`模式;在封面下,它操作相同的!

如果你是一个C #开发商这`异步`/`等待`看起来很熟悉,那是因为这个功能是直接由C #的特征. 很高兴看到语言优先说明了收敛性!

Babel,名和其他transpilers已经有早期的支持现状`异步函数`S,这样你就可以开始使用它们了. 然而,在下一节"注意事项"中,我们会明白为什么你还不应该跳到那艘船上. 

**注: **还有一个建议`异步功能*`,这将被称为"异步发电机. "你都可以`产量`和`等待`在同一代码中,甚至将这些操作合并在同一语句中: `等待产量`. "异步发电机"的建议似乎更在变化ℴℴ即它的返回值是不完全的工作了. 有些人觉得应该是_观察_,这有点像迭代器和承诺的组合. 现在,我们将不再深入讨论这个话题,但请继续关注它的发展. 

### 注意事项

一个悬而未决的争论点`异步函数`是因为它只回一个承诺,没有办法从外面到_取消_一个`异步函数`当前运行的实例. 这可以在异步操作是资源密集型的一个问题,你需要释放的资源,只要你确定结果就不需要. 

例如:

```js
async function request(url) {
	var resp = await (
		new Promise( function(resolve,reject){
			var xhr = new XMLHttpRequest();
			xhr.open( "GET", url );
			xhr.onreadystatechange = function(){
				if (xhr.readyState == 4) {
					if (xhr.status == 200) {
						resolve( xhr );
					}
					else {
						reject( xhr.statusText );
					}
				}
			};
			xhr.send();
		} )
	);

	return resp.responseText;
}

var pr = request( "http://some.url.1" );

pr.then(
	function fulfilled(responseText){
		// ajax success
	},
	function rejected(reason){
		// Oops, something went wrong
	}
);
```

这`请求(ⅆ)`我所设想的有点像`取(..)`最近被提议纳入Web平台的实用工具. 所以担心的是,如果你想使用`公共关系`值以某种方式指示您想要取消一个长期运行的Ajax请求,例如?

承诺是不可撤销的(在写,反正时间). 在我看来,和许多其他人一样,他们永远也不应该(见_异步和性能_本系列的标题). 即使一个诺言确实有`cancel()`方法,这是否一定意味着调用`公关cancel()`其实应该宣传取消信号所有的方式回到了承诺链到`一`?

关于这场辩论的几种可能的解决办法已经浮出水面: 

-   `异步函数`在所有的不可撤销(现状)
-   "取消标记"可以通过一个异步函数在调用时
-   返回的值更改为可撤销承诺类型的增加
-   返回值更改为其他非承诺(例如,可观察的,或带有承诺和取消功能的控制令牌)

在撰写本文时,`异步函数`s返回定期的承诺,因此返回值将完全不可能改变. 但现在还不知道什么地方会着陆. 密切关注这次讨论. 

## `对象: 观察(ⅆ)`

一个前端Web开发的圣杯是数据绑定到一个数据对象ℴℴ听力和同步数据的DOM表示的更新. 大多数js框架为这些操作提供了一些机制. 

看来后6,我们会看到支持直接添加到语言,通过一个叫做实用`对象: 观察(ⅆ)`. 本质上,这个想法是,你可以设置侦听器来观察对象的变化,并在发生变化时调用回调函数. 然后,您可以相应地更新DOM,例如. 

你可以观察到六种类型的变化: 

-   添加
-   更新
-   删除
-   重新配置
-   setprototype
-   preventextensions

默认情况下,您将收到所有这些更改类型的通知,但您可以过滤到您关心的那些类型. 

考虑: 

```js
var obj = { a: 1, b: 2 };

Object.observe(
	obj,
	function(changes){
		for (var change of changes) {
			console.log( change );
		}
	},
	[ "add", "update", "delete" ]
);

obj.c = 3;
// { name: "c", object: obj, type: "add" }

obj.a = 42;
// { name: "a", object: obj, type: "update", oldValue: 1 }

delete obj.b;
// { name: "b", object: obj, type: "delete", oldValue: 2 }
```

除主`"添加"`,`"更新"`,和`"删除"`变化类型: 

-   这个`"配置"`如果某个对象的属性被重新配置,将触发更改事件. `对象. defineproperty(..)`如改变其`可写`属性. 看到_对象原型_此系列的标题以获取更多信息. 
-   这个`"preventextensions"`如果对象是不可扩展的,则更改事件将被触发. `对象. preventextensions(..)`. 

    因为`对象: 密封(ⅆ)`和`对象: 冻结(ⅆ)`也意味着`对象. preventextensions(..)`它们也会触发相应的更改事件. 此外,`"配置"`还将为对象上的每个属性触发更改事件. 

-   这个`"setprototype"`如果更改,则触发事件. `[原型]`对象的更改,或者通过设置`__proto__`二传手,或使用`对象. setprototypeof(..)`. 

注意,这些更改事件在更改后立即通知. 不要把这个与代理混淆(参见第7章),在那里您可以在操作发生之前拦截它们. 对象观察让您在更改(或一组更改)发生后作出响应. 

### 习惯的改变事件

除了六个内置的更改事件类型之外,还可以侦听和触发自定义更改事件. 

考虑: 

```js
function observer(changes){
	for (var change of changes) {
		if (change.type == "recalc") {
			change.object.c =
				change.object.oldValue +
				change.object.a +
				change.object.b;
		}
	}
}

function changeObj(a,b) {
	var notifier = Object.getNotifier( obj );

	obj.a = a * 2;
	obj.b = b * 3;

	// queue up change events into a set
	notifier.notify( {
		type: "recalc",
		name: "c",
		oldValue: obj.c
	} );
}

var obj = { a: 1, b: 2, c: 3 };

Object.observe(
	obj,
	observer,
	["recalc"]
);

changeObj( 3, 11 );

obj.a;			// 12
obj.b;			// 30
obj.c;			// 3
```

变更集(`"重新计算"`定制事件已排队等待交付给观察者,但尚未交付,这就是为什么`C对象. `仍然是`三`. 

默认情况下,这些更改是在当前事件循环的结尾处传递的(参见_异步和性能_本系列的标题). 如果您想立即交付它们,请使用`deliverchangerecords(观察者)的对象. `. 一旦交付了更改事件,您就可以观察到`C对象. `更新如预期: 

```js
obj.c;			// 42
```

在前一个示例中,我们调用`通知. 通知(..)`使用完全更改事件记录. 排队更改记录的另一种形式是使用`performchange(..)`,它将事件的类型与事件记录的其他属性(通过函数回调)分开. 考虑: 

```js
notifier.performChange( "recalc", function(){
	return {
		name: "c",
		// `this` is the object under observation
		oldValue: this.c
	};
} );
```

在某些情况下,这种关注点的分离可以更清晰地映射到您的使用模式. 

### 结局的观察

与正常事件侦听器一样,您可能希望停止观察对象的更改事件. 为此,您使用`对象. unobserve(..)`. 

例如:

```js
var obj = { a: 1, b: 2 };

Object.observe( obj, function observer(changes) {
	for (var change of changes) {
		if (change.type == "setPrototype") {
			Object.unobserve(
				change.object, observer
			);
			break;
		}
	}
} );
```

在这个小示例中,我们侦听更改事件,直到看到`"setprototype"`事件发生了,我们不再观察任何变化事件. 

## 幂运算符

运营商已经提出了JavaScript以同样的方式,执行指数`数学,战俘(ⅆ)`做.考虑: 

```js
var a = 2;

a ** 4;			// Math.pow( a, 4 ) == 16

a **= 3;		// a = Math.pow( a, 3 )
a;				// 8
```

**注: ** `* *`基本上与PythonㄡRubyㄡPerl以及其他类似的内容相同. 

## 对象的属性和`ⅆ`

正如我们在第2章"太多,太少,足够"的章节中所看到的,`ⅆ`运算符在如何扩展或收集数组方面非常明显. 但是对象呢?

这样的一个特征是6,但推迟了要考虑后6(又名"7"或"es2016"或ⅆ). 这里是它如何工作,"超越时间6": 

```js
var o1 = { a: 1, b: 2 },
	o2 = { c: 3 },
	o3 = { ...o1, ...o2, d: 4 };

console.log( o3.a, o3.b, o3.c, o3.d );
// 1 2 3 4
```

这个`ⅆ`运营商也可能被用来收集对象的结构特性为对象: 

```js
var o1 = { b: 2, c: 3, d: 4 };
var { b, ...o2 } = o1;

console.log( b, o2.c, o2.d );		// 2 3 4
```

这里的`ⅆO2`重新聚集结构`C`和`D`属性返回到`O2`对象(`O2`没有`B`属性`O1`不). 

再次,这些只是建议考虑下超过6. 但是如果他们登陆的话会很酷. 

## `阵列#包括(. )`

js开发人员需要执行的一个非常常见的任务是在一个值数组中搜索一个值. 这种做法一直是这样做的: 

```js
var vals = [ "foo", "bar", 42, "baz" ];

if (vals.indexOf( 42 ) >= 0) {
	// found it!
}
```

原因`> = 0`CHEC`IndexOf(..)`返回一个数字值`零`或更大,如果发现,或`- 1`如果没有找到. 换句话说,我们在布尔上下文中使用一个索引返回函数. 但由于`- 1`是不是falsy真相,我们必须与我们的检查更多的手册. 

在_类型与语法_这个系列的标题,我探索了另一个我稍微喜欢的模式: 

```js
var vals = [ "foo", "bar", 42, "baz" ];

if (~vals.indexOf( 42 )) {
	// found it!
}
```

这个`~`这里的运算符符合返回值. `IndexOf(..)`一个值的范围,适当的布尔威压. 这是,`- 1`生产`零`(falsy),和其他任何一个非零的(真实性)产生价值,这是我们决定如果我们发现价值或不. 

我认为这是一个进步,其他人则强烈反对. 然而,没有人可以争辩说`IndexOf(..)`搜索逻辑是完美的. 它找不到`南`数组中的值,例如. 

因此,一个建议浮出水面,并获得了许多支持,添加了一个真正的布尔返回数组搜索方法,称为`包括(ⅆ)`: 

```js
var vals = [ "foo", "bar", 42, "baz" ];

if (vals.includes( 42 )) {
	// found it!
}
```

**注: ** `阵列#包括(. )`使用将找到的匹配逻辑. `南`值,但不会区分`- 0`和`零`(见_类型与语法_本系列的标题). 如果你不在乎`- 0`程序中的值,这很可能正是您所希望的. 如果你_做_关心`- 0`您需要做自己的搜索逻辑,可能使用`对象是(ⅆ)`实用程序(见第6章). 

## SIMD

我们更详细地介绍了单指令ㄡ多数据(SIMD). _异步和性能_这个系列的标题,但是这里有一个简短的介绍,因为它是未来JS中的下一个可能的特性之一. 

SIMD API公开了各种低级(CPU)指令,这些指令可以一次操作多个数字值. 例如,您可以指定两个_向量_4个或8个数字,同时相乘各个元素(数据并行!). 

考虑: 

```js
var v1 = SIMD.float32x4( 3.14159, 21.0, 32.3, 55.55 );
var v2 = SIMD.float32x4( 2.1, 3.2, 4.3, 5.4 );

SIMD.float32x4.mul( v1, v2 );
// [ 6.597339, 67.2, 138.89, 299.97 ]
```

SIMD还包括几个其他操作`多(..)`(乘法),例如`sub()`,`div()`,`abs()`,`neg()`,`sqrt()`还有更多. 

并行数学操作对于下一代高性能js应用程序至关重要. 

## WebAssembly(WASM)

布兰登·艾奇做了一个最新公告附近的这个标题有显着影响的未来潜在的JavaScript第一版完成: WebAssembly(WASM). 我们将不能够覆盖甚至详细的在这里,因为它是在写这篇文章的时间非常早. 但这个标题不完整,至少没有提到它. 

一个对近期最强的压力(和将来)的JS语言设计的变化一直的愿望,它成为一个更合适的目标transpilation /交叉其他汇编语言(如C / C++,ClojureScript,等). 显然,作为JavaScript运行的代码的性能一直是首要关注的问题. 

如在_异步和性能_这一系列的标题,几年前,一批开发商Mozilla推出了一个主意asm.js JavaScript. asm.js是有效的JS,最明显的限制某些行动,使代码难以JS引擎优化子集. 结果是,asm.js兼容的代码在ASM知道发动机的运行可以运行非常快,几乎等同于本地优化C当量. 很多人认为ASM.js是最有可能的支柱上的应用会骑在JavaScript性能饿. 

换句话说,浏览器中运行代码的所有途径_铅通过JavaScript_. 

那就是,直到WASM公告. 甚至其他语言的目标浏览器的运行环境,而不必首先通过JavaScript提供备用路径. 基本上,如果是经营起飞,JS引擎会额外的能力来执行二进制格式的代码,可以被视为类似于一个字节码(如运行在JVM). 

甚至提出了一种高度压缩的二进制表示形式(AST语法树)的代码,然后可以直接给JS引擎及其基础的指令,而不必解析JS,甚至表现的JS的规则. 语言如C或C++编译可直接代替asm.js的WASM格式,并跳过JS解析获得额外的速度优势. 

对于WASM近期有奇偶校验asm.js确实JS. 但最终,它的预期,甚至会增加新的功能,超越任何JS能做. 例如,压力为JS发展基特征像线程--改变,当然通过JS生态系统发送重大的冲击波,作为未来甚至延伸一个更有希望的未来,缓解压力改变JS. 

事实上,这个新的路标为许多语言开辟了许多新的道路,以达到Web运行时的目标. 对于Web平台来说,这是一条令人兴奋的新的未来之路!

这对JS来说意味着什么?JS会变得无关紧要或者"死亡"吗?绝对不. asm.js可能不会看到太多的未来的几年里,但大多数是JS

支持者甚至建议它的成功将意味着JS的设计将受到压力,最终会把它超越假设的合理性突破点. 据预测,甚至将成为应用的高性能部件的首选目标,作为撰写的各种不同的语言. 

有趣的是,JavaScript是将来甚至可能目标较小的语言之一. 未来可能会出现一些针对这种目标的JS子集,但在优先级列表中,这个路径似乎并不高. 

而JS很可能不会太多甚至漏斗,js代码,甚至代码能够在最有意义的方式进行互操作,正像电流模块的相互作用. 可以想象调用JS函数`foo()`在实际调用这个名字是经营功能与权力运行在你的JS其余约束. 

目前用js编写的东西可能会一直用js编写,至少在可预见的将来是这样. 事情是transpiled JS最后可能会至少考虑针对甚至相反. 在对抽象层最小容错性能需要最大的事情,可能会选择找一个合适的非JS语言的作者,然后是经营. 

很有可能这种转变将是缓慢的,将是数年的时间. 在所有主要的浏览器登陆平台甚至可能是几年最好的. 同时,这是经营项目([https://github.com/webassembly](https://github.com/WebAssembly))已证明的概念,它的基本原理早polyfill. 

但随着时间的推移,和甚至学习新的非JS伎俩,看到一些目前JS的东西被重构为一个是经营定位的语言不是太多的想象. 例如,框架ㄡ游戏引擎和其他大量使用的工具的性能敏感部分可能会从这种转变中受益匪浅. 在Web应用程序中使用这些工具的开发人员可能不会注意到使用或集成的差异,但只会自动利用性能和功能. 

可以肯定的是,甚至随着时间的推移变得更真实,更意味着轨迹设计的JavaScript. 这也许是一个最重要的"超越6"主题开发者应该注意. 

## 回顾

如果在这个系列的其他书基本上都提出了挑战,"你(可能)不知道JS(如你想象的那么多),"这本书有相反的建议,"你不知道JS了. "本书涵盖了很多新的东西添加到ES6语言. 这是一个令人兴奋的新语言特性和范例的集合,将永远改进我们的js程序. 

但JS是没有完成6!甚至不关闭. 已经有相当多的特点,在不同的发展阶段为"超越时间6". 在本章中,我们简要地浏览了一些最有可能在JS中登陆的候选者. 

`异步函数`s是强大的语法糖在生成器+允诺模式之上(参见第4章). `对象: 观察(ⅆ)`为观察对象更改事件添加直接的原生支持,这对于实现数据绑定至关重要. 这个`* *`幂运算符,`ⅆ`用于对象属性,以及`阵列#包括(. )`都是对现有机制的简单但有益的改进. 最后,在SIMD引进高性能JS演变的新时代. 

é听起来陈词滥调,JS的未来是很光明的!这一系列的挑战,的确是这本书,现在对每一位读者都是义不容辞的. 你还在等什么?是学习和探索的时候了!
