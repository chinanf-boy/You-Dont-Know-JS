
# 你不知道JS: ES6与超越

# 第2章: 句法

如果你一直在写JS,很可能你的语法很熟悉. 当然有很多怪癖,但总的来说,它是一种相当合理和简单的语法,与其他语言有许多相似之处. 

然而,6增添了不少新的语法形式,采取一些习惯. 在这一章中,我们将参观他们,看看商店里有什么. 

**提示: **在撰写本文的时候,本书中讨论的一些特性已经在各种浏览器(FirefoxㄡChrome等)中实现,但有些功能只是部分实现了,还有许多其他功能尚未实现. 你的经验可能是混合的直接尝试这些例子. 如果是这样的话,他们尝试用transpilers,大多数这些功能都被那些工具. es6fiddle(<http://www.es6fiddle.net/>)是一个伟大的ㄡ易于使用的操场试行6,是Babel transpiler在线回答(<http://babeljs.io/repl/>). 

## 块作用域声明

你可能知道变量作用域在JavaScript的基本单位一直`功能`. 如果你需要创建一个块的范围内,最普遍的方式,这样做比其他普通函数声明是立即调用函数表达式(生活). 例如:

```js
var a = 2;

(function IIFE(){
	var a = 3;
	console.log( a );	// 3
})();

console.log( a );		// 2
```

### `让`声明

但是,我们现在可以创建绑定到任何块的声明(调用). _块作用域_. 这意味着我们所需要的只是一对`{ ..}`创建范围. 而不是使用`VaR`,它总是声明附加到封闭函数(或全局,如果是顶层)范围的变量,使用`让`: 

```js
var a = 2;

{
	let a = 3;
	console.log( a );	// 3
}

console.log( a );		// 2
```

在JS中使用独立的语言并不是很普遍或习惯. `{ ..}`块,但它总是有效的. 还有来自其他语言的开发人员_块作用域_将很容易地认识到这种模式. 

我相信这是创建块作用域的变量的最佳方式,用一个专门的`{ ..}`块. 此外,你应该总是把`让`在那块最上面的声明. 如果你有不止一个要申报,我建议只用一个. `让`. 

在风格上,我更喜欢把`让`和开场一样`{`为了更清楚地说明此块仅用于声明变量的作用域. 

```js
{	let a = 2, b, c;
	// ..
}
```

现在,这会看起来很奇怪,它不太可能去匹配其他6文献给出的建议. 但我有理由疯狂. 

还有另一种实验(非标准化)的形式`让`声明称`让`-块,看起来像: 

```js
let (a = 2, b, c) {
	// ..
}
```

这种形式就是我所说的. _明确的_块作用域,而`让..`镜子的申报表`VaR`更多的是_隐性的_这类劫持什么的,`{ ..}`发现它的配对. 一般开发商找到_明确的_机制比_隐性的_机制,我认为这是其中之一. 

如果你比较前两段的形式,他们是非常相似的,在我看来都是符合文体_明确的_块作用域. 不幸的是,这`让(..){}`形式,最多_明确的_的选择,不采用6. 这可能是重新post-es6,但现在前者的选择是我们最好的选择,我想. 

加强_隐性的_性质`让..`声明,考虑这些用法: 

```js
let a = 2;

if (a > 1) {
	let b = a * 3;
	console.log( b );		// 6

	for (let i = a; i <= b; i++) {
		let j = i + 10;
		console.log( j );
	}
	// 12 13 14 15 16

	let c = a + b;
	console.log( c );		// 8
}
```

快速回顾,不用回顾那个片段: 只有在里面的变量才存在`如果`语句,并且变量只存在于`对于`环?

答案是: `如果`声明包含`B`和`C`块作用域的变量,和`对于`回路包含`我`和`J`块作用域的变量. 

你想了一会儿吗?你感到惊讶吗?`我`不添加到包围中`如果`声明的范围?这种精神上的停顿和质疑ℴℴ我称之为"精神税"ℴℴ来自于这一事实. `让`机制不仅对我们来说是新的,而且对我们也是_隐性的_. 

也有危险`让ⅆ`出现在范围内的声明. 不同于传统的`VaR`-声明变量,它们依附于整个封闭函数范围,不管它们出现在哪里,`让`声明附加到块作用域,但直到它们出现在块中时才初始化. 

访问`让`-声明变量比`让..`声明/初始化会导致错误,而`VaR`声明的顺序没有关系(除了风格). 

考虑: 

```js
{
	console.log( a );	// undefined
	console.log( b );	// ReferenceError!

	var a;
	let b;
}
```

**警告: **这`引用错误`过早访问`让`-声明引用在技术上称为_时间死区(TDZ)_错误ℴℴ您访问的是已声明但尚未初始化的变量. 这不会是我们唯一一次看到TDZ错误--他们出现在几个地方在6. 另外,请注意,"初始化"不需要在代码中显式地赋值,如`让B;`是完全有效的. 假定在声明时间未赋值的变量被赋值为`未定义`VA`让B;`是一样的`让b =未定义;`. 显式赋值与否,不能访问`B`直到`让B`语句运行. 

最后一个问题: `类型`表现出有TDZ变量而不是申报(或宣布!)变量.例如:

```js
{
	// `a` is not declared
	if (typeof a === "undefined") {
		console.log( "cool" );
	}

	// `b` is declared, but in its TDZ
	if (typeof b === "undefined") {		// ReferenceError!
		// ..
	}

	// ..

	let b;
}
```

这个`一`没有声明,所以`类型`唯一的安全方法是检查它是否存在. 但`类型B`抛出的错误因为更远的TDZ在代码中碰巧有一个`让B`宣言.哎呀.

现在应该更清楚我为什么坚持`让`所有声明都应该放在他们的范围之内. 这完全避免了过早访问的偶然错误. 它也使它更多. _明确的_当您查看一个块的开始时,任何块,它包含哪些变量. 

你的块(`如果`声明,`虽然`循环等)不必搜索行为分享他们的原始行为. 

这显化在你的部分,这是由你来维持纪律,能节省你的头痛和footguns重构线下. 

**注: **有关更多信息`让`和块范围,详见3章_范围和关闭_本系列的标题. 

#### `让`+`对于`

唯一的例外,我会作出的偏好_明确的_形式`让`声明阻塞是`让`出现在A的标题中`对于`环. 原因可能是微妙的,但我相信这是一个更重要的ES6功能. 

考虑: 

```js
var funcs = [];

for (let i = 0; i < 5; i++) {
	funcs.push( function(){
		console.log( i );
	} );
}

funcs[3]();		// 3
```

这个`让我`在`对于`标题声明`我`不只是为了`对于`环本身,但它重新声明一个新的`我`循环的每一次迭代. 这意味着在循环迭代中创建的闭包以您期望的方式接近于每个迭代变量. 

如果您尝试相同的代码片段,但`var i`在`对于`循环头,你会得到`五`而不是`三`因为只有一个`我`在封闭的外部范围内,而不是一个新的`我`对于每个迭代函数关闭. 

你也可以完成同样的事情稍微冗长: 

```js
var funcs = [];

for (var i = 0; i < 5; i++) {
	let j = i;
	funcs.push( function(){
		console.log( j );
	} );
}

funcs[3]();		// 3
```

在这里,我们强迫创建一个新的`J`对于每个迭代,然后闭包都以相同的方式工作. 我更喜欢前一种方法,那就是我特别赞同的能力. `为了(让ⅆ)..`形式. 可以说它有点多. _隐性的_但它是_明确的_够了,够实用了,适合我的口味. 

`让`也用同样的方式工作`对..`和`对..`循环(参见)`对..`循环". 

### `const`声明

有一块其他形式范围考虑的声明: `const`,造成_常数_. 

什么是常量?它是在初始值设置后只读的变量. 考虑: 

```js
{
	const a = 2;
	console.log( a );	// 2

	a = 3;				// TypeError!
}
```

在声明时间内,您不允许更改变量所设置的值. 一`const`声明必须有明确的初始化. 如果你想要一个_常数_与`未定义`值,你必须声明`常量=未定义的`得到它. 

常量不是对值本身的限制,而是关于变量赋值的值. 换言之,该值不是冻结的或不可变的,因为`const`只是任务的分配. 如果该值是复杂的,如对象或数组,则该值的内容仍然可以修改: 

```js
{
	const a = [1,2,3];
	a.push( 4 );
	console.log( a );		// [1,2,3,4]

	a = 42;					// TypeError!
}
```

这个`一`变量实际上不包含一个常量数组;相反,它对数组保留一个常量引用. 数组本身是可变的. 

**警告: **分配的对象或数组作为一个常数意味着价值将无法在恒定的词法范围去收集垃圾,作为价值的参考不可撤消. 这可能是可取的,但要小心,如果不是你的意图!

基本上,`const`声明说,加强我们与我们的代码来表示,我们宣布所有大写字母的变量名,给它一些文字值,我们照顾从未改变. 没有强制执行`VaR`赋值,但现在有了`const`赋值,它可以帮助你捕捉意外的变化. 

`const` _可以_与变量声明一起使用`对于`,`对..`,和`对..`循环(参见)`对..`循环". 然而,一个错误会如果有任何企图重新抛出,典型的如`我+ +`条款一`对于`环. 

#### `const`或不

有传言称`const`可以更优化的JS引擎在某些情况下比`让`或`VaR`将. 从理论上讲,引擎更容易知道变量的值/类型永远不会改变,因此它可以消除一些可能的跟踪. 

是否`const`在这里真的有帮助,或者这仅仅是我们自己的幻想和直觉,更重要的决定是,如果你打算持续的行为或不. 记住: 源代码最重要的角色之一是清楚地沟通,不仅是对你,而且是你未来的自我和其他代码合作者,你的意图是什么?. 

一些开发人员喜欢将每个变量声明作为一个`const`然后放松一个声明返回到`让`如果它的价值是必要的

这不是真的_保护_正如许多人所相信的那样,因为任何后来想要改变某个值的开发人员`const`只能一味的改变`const`到`让`关于宣言. 充其量,它能保护意外的变化. 但是,除了我们的直觉和敏感性之外,似乎还没有对什么构成"事故"或预防措施作出客观和明确的衡量. 类似的心态存在类型强制. 

我的建议: 避免潜在混乱的代码,只使用`const`对于您有意且明显的变量,信令不会改变. 换句话说,不要_依靠_ `const`对于代码行为,而是使用它作为信令意图的工具,当意图可以清楚地发出信号时. 

### 块作用域的功能

从6,函数的声明出现在块现在规定范围的那块. 前6,规范没有要求,但还是做了很多的实现. 所以现在规范符合现实. 

考虑: 

```js
{
	foo();					// works!

	function foo() {
		// ..
	}
}

foo();						// ReferenceError
```

这个`foo()`函数在内部声明`{ ..}`块,并作为ES6块范围有. 所以它不在那个街区之外. 但也要注意,它是在街区内"悬挂"的,而不是`让`声明,这受到前面提到的TDZ错误陷阱. 

块作用域函数声明可以如果你曾经写过这样的代码之前,是一个问题,依靠传统的非块范围内的行为: 

```js
if (something) {
	function foo() {
		console.log( "1" );
	}
}
else {
	function foo() {
		console.log( "2" );
	}
}

foo();		// ??
```

在pre-es6环境,`foo()`将打印`"2"`不计价值`某物`因为两个函数声明都从块中取出,而第二个函数总是获胜. 

在最后一行6,抛出一个`引用错误`. 

## 传播/休息

介绍了一种新型的ES6`ⅆ`运算符,通常称为_传播_或_休息_运算符,取决于它在哪里使用. 让我们看一看: 

```js
function foo(x,y,z) {
	console.log( x, y, z );
}

foo( ...[1,2,3] );				// 1 2 3
```

什么时候`ⅆ`在数组的前面使用(实际上,任何_可迭代的_我们在第3章谈到),它的作用是"传播"到它的个体价值中去. 

当将数组作为函数调用的一组参数展开时,您通常会看到前面的代码片段所示的用法. 在这种用法中,`ⅆ`为我们提供一个更简单的语法替换. `应用(ⅆ)`方法,我们通常会用pre-es6作为: 

```js
foo.apply( null, [1,2,3] );		// 1 2 3
```

但`ⅆ`也可以用于在其他上下文中展开/展开一个值,例如在另一个数组声明中: 

```js
var a = [2,3,4];
var b = [ 1, ...a, 5 ];

console.log( b );					// [1,2,3,4,5]
```

在这种用法中,`ⅆ`基本上是更换`concat(..)`,就像它的行为一样`[ 1 ]. concat(A,[ 5 ])`在这里.

其他常用用法`ⅆ`本质上是相反的,而不是把价值传播出去. `ⅆ` _集_数组中的一组值. 考虑: 

```js
function foo(x, y, ...z) {
	console.log( x, y, z );
}

foo( 1, 2, 3, 4, 5 );			// 1 2 [3,4,5]
```

这个`ⅆZ`在这个片段中,基本上是这样说的: "收集_休息_将参数(如果有的话)转换为数组`Z`因为. "`X`被分配`一`,和`Y`被分配`二`其余的论点`三`,`四`,和`五`聚成`Z`. 

当然,如果没有任何命名参数,则`ⅆ`收集所有参数: 

```js
function foo(...args) {
	console.log( args );
}

foo( 1, 2, 3, 4, 5);			// [1,2,3,4,5]
```

**注: **这个`ⅆargs`在`富(ⅆ)`函数声明通常称为"休息参数",因为您正在收集其余参数. 我更喜欢"收集",因为它更能描述它所做的,而不是它包含的内容. 

关于这种用法最好的部分是,它使用早已过时的提供了一个非常坚实的替代`争论`数组ℴℴ实际上,它不是一个数组,而是一个数组一样的对象. 因为`args`(或者你管它叫什么)很多人都喜欢. `R`或`休息`)是一个真正的数组,我们可以摆脱无聊的pre-es6把戏我们跳到让很多`争论`我们可以当作数组对待. 

考虑: 

```js
// doing things the new ES6 way
function foo(...args) {
	// `args` is already a real array

	// discard first element in `args`
	args.shift();

	// pass along all of `args` as arguments
	// to `console.log(..)`
	console.log( ...args );
}

// doing things the old-school pre-ES6 way
function bar() {
	// turn `arguments` into a real array
	var args = Array.prototype.slice.call( arguments );

	// add some elements on the end
	args.push( 4, 5 );

	// filter out odd numbers
	args = args.filter( function(v){
		return v % 2 == 0;
	} );

	// pass along all of `args` as arguments
	// to `foo(..)`
	foo.apply( null, args );
}

bar( 0, 1, 2, 3 );					// 2 4
```

这个`ⅆargs`在`富(ⅆ)`函数声明收集参数,以及`ⅆargs`在`控制台(ⅆ)`呼叫分散他们. 这很好地说明了对称而相反的用法. `ⅆ`算子. 

除了`ⅆ`函数声明中的用法,还有另一种情况`ⅆ`用于收集值,我们将在本章后面的"过多ㄡ过少ㄡ足够"部分查看它. 

## 默认参数值

JavaScript中最常见的习惯用法之一可能是为函数参数设置默认值. 我们这样做了多年,看起来应该很熟悉: 

```js
function foo(x,y) {
	x = x ƜƜ 11;
	y = y ƜƜ 31;

	console.log( x + y );
}

foo();				// 42
foo( 5, 6 );		// 11
foo( 5 );			// 36
foo( null, 6 );		// 17
```

当然,如果你已经在使用这种模式,你知道它是有益的,有点危险,例如如果你需要能够在原本被视为一个参数的值传递falsy. 考虑: 

```js
foo( 0, 42 );		// 53 <-- Oops, not 42
```

为什么?因为`零`是falsy,所以`X Ɯ Ɯ 11`结果`十一`而不是直接通过`零`. 

要解决这个问题,有些人会写这样的检查更详细: 

```js
function foo(x,y) {
	x = (x !== undefined) ? x : 11;
	y = (y !== undefined) ? y : 31;

	console.log( x + y );
}

foo( 0, 42 );			// 42
foo( undefined, 6 );	// 17
```

当然,这意味着除了`未定义`可以直接传入. 然而,`未定义`将被假定为信号,"我没有通过这个",这是伟大的工作,除非你真的需要能够通过`未定义`在. 

在这种情况下,你可以`争论`数组,也许像这样: 

```js
function foo(x,y) {
	x = (0 in arguments) ? x : 11;
	y = (1 in arguments) ? y : 31;

	console.log( x + y );
}

foo( 5 );				// 36
foo( 5, undefined );	// NaN
```

但你怎么能省略第一个呢?`X`没有能力传递任何价值的争论(甚至不是)`未定义`"我漏掉了这个论点"?

`美孚(5)`是诱人的,但它是无效的语法. `应用(NULL,[,5 ])`似乎应该这样做,但是`应用(ⅆ)`这里的怪癖意味着这些论点被视为`[未定义,5 ]`这当然不会遗漏. 

如果你进一步研究,你会发现你只能省略参数对端(即右边)通过简单的传递参数比预期的少,但你不能省略的参数在中间或在参数列表的开始. 这是不可能的. 

这里有一个应用于JavaScript设计的原则,这一点很重要: `未定义`方法_丢失的_. 也就是说,两者之间没有区别. `未定义`和_丢失的_至少函数的参数是. 

**注: **还有,令人困惑的是,在这个特定的JS设计原则并不适用于其他地方,如空槽阵列. 看到_类型与语法_此系列的标题以获取更多信息. 

考虑到这一切,我们现在可以检查一个好有用的语法增加为6精简作业缺少参数默认值: 

```js
function foo(x = 11, y = 31) {
	console.log( x + y );
}

foo();					// 42
foo( 5, 6 );			// 11
foo( 0, 42 );			// 42

foo( 5 );				// 36
foo( 5, undefined );	// 36 <-- `undefined` is missing
foo( 5, null );			// 5  <-- null coerces to `0`

foo( undefined, 6 );	// 17 <-- `undefined` is missing
foo( null, 6 );			// 6  <-- null coerces to `0`
```

请注意结果,以及它们如何暗示早期方法的细微差别和相似之处. 

`x = 11`在函数声明中更像`X!=未定义的?X: 11`而不是更常见的习语`X Ɯ Ɯ 11`,所以你需要把你的pre-es6代码这6缺省参数值的语法要小心. 

**注: **REST /收集参数(参见"扩展/ REST")不能具有默认值. 所以,当`函数foo(ⅆ瓦尔斯= [1,2,3]){`可能是一个有趣的功能,它不是有效的语法. 如果需要,您还需要继续手动应用这种逻辑. 

### 默认值表达式

函数默认值不仅仅是简单的值,比如`三十一`它们可以是任何有效表达式,甚至是函数调用: 

```js
function bar(val) {
	console.log( "bar called!" );
	return y + val;
}

function foo(x = y + 3, z = bar( x )) {
	console.log( x, z );
}

var y = 5;
foo();								// "bar called"
									// 8 13
foo( 10 );							// "bar called"
									// 10 15
y = 6;
foo( undefined, 10 );				// 9 10
```

正如您所看到的,默认值表达式是经过求值的,这意味着它们只在需要时和需要时运行,也就是说,当参数参数被省略或是`未定义`. 

这是一个微妙的细节,但是函数声明中的形参是在自己的范围内(把它看作是一个范围的泡泡,只包装在`(..)`函数声明的范围内,而不是在函数主体的作用域中. 这意味着在查找外部范围之前,默认值表达式中的标识符的引用首先匹配形参的作用域. 看到_范围和关闭_此系列的标题以获取更多信息. 

考虑: 

```js
var w = 1, z = 2;

function foo( x = w + 1, y = x + 1, z = z + 1 ) {
	console.log( x, y, z );
}

foo();					// ReferenceError
```

这个`W`在`W + 1`默认值表达式查找`W`在形式参数的范围内,但没有找到它,所以外部范围的`W`使用. 下一步,该`X`在`x + 1`默认值表达式查找`X`在正式参数范围内,幸运的是`X`已经初始化,所以赋值给`Y`做工精细. 

然而,这`Z`在里面`Z + 1`发现`Z`作为一个尚未初始化的时刻,参数变量,所以它从不试图找到`Z`从外部范围. 

正如我们在"`让`声明本章前面的"部分ES6有TDZ,防止一个变量被访问的初始化状态. 因此,`Z + 1`默认值表达式抛出TDZ`引用错误`误差. 

尽管它不一定是一个好主意,代码清晰,默认值表达式可以内联函数表达的电话--通常被称为一个立即调用函数表达式(生活): 

```js
function foo( x =
	(function(v){ return v + 11; })( 31 )
) {
	console.log( x );
}

foo();			// 42
```

也很少有任何情况下,生活(或任何其他执行内联函数表达式)将适当的默认值表达式. 如果你发现自己想这样做,那么退一步重新评估一下!

**警告: **如果生活曾试图访问`X`标识符,并没有声明自己`X`,这也将是一个错误只是讨论之前发生. 

在前一段的默认值表达的是一个生活在某种意义上它是一个函数的执行权通过内联,`(31)`. 如果我们放弃了该部分,默认值分配给`X`将只是一个函数引用本身,可能像一个默认回调函数. 可能会出现这种模式非常有用的情况,例如: 

```js
function ajax(url, cb = function(){}) {
	// ..
}

ajax( "http://some.url.1" );
```

在这种情况下,我们本质上希望默认`CB`如果没有其他指定,则为空函数调用. 函数表达式只是函数引用,而不是函数调用本身(没有调用). `()`在结束时,它实现了那个目标. 

从JS的早期起,我们就有了一个鲜为人知却有用的怪癖: `function.prototype`本身是空的非运算功能. 所以,宣言可能是`CB = function.prototype`并保存内联函数表达式创建. 

## 解构

介绍了一种新的句法特征称为6_解构_如果你相反,这可能会稍微不那么混乱. _结构分配_. 要理解这个意义,请考虑: 

```js
function foo() {
	return [1,2,3];
}

var tmp = foo(),
	a = tmp[0], b = tmp[1], c = tmp[2];

console.log( a, b, c );				// 1 2 3
```

如您所见,我们创建了数组中值的手动赋值`foo()`返回单个变量`一`,`B`,和`C`为了做到这一点,我们(不幸地)需要`TMP`变量. 

类似地,我们可以用对象来完成以下操作: 

```js
function bar() {
	return {
		x: 4,
		y: 5,
		z: 6
	};
}

var tmp = bar(),
	x = tmp.x, y = tmp.y, z = tmp.z;

console.log( x, y, z );				// 4 5 6
```

这个`TMP X. `属性值被分配给`X`变量,同样适用于`TMP. Y`到`Y`和`TMP. Z`到`Z`. 

可以从一个对象手动地从数组或属性中分配索引值. _结构分配_. 6添加专用的语法_解构_,具体_阵列的解构_和_对象解构_. 此语法消除了`TMP`在前一段中变量,使它们更干净. 考虑: 

```js
var [ a, b, c ] = foo();
var { x: x, y: y, z: z } = bar();

console.log( a, b, c );				// 1 2 3
console.log( x, y, z );				// 4 5 6
```

您可能更习惯于看到语法`[ a,b,c ]`在一个右边`=`赋值,作为赋值的值. 

解构对称翻转模式,使`[a,b,c]`在左边`=`分配被视为一种"分解右边数组的值为独立变量的赋值模式". 

同样,`{: x,y,y,z,z`指定从对象中分解对象值的"模式". `bar()`分成单独的变量赋值. 

### 对象属性分配模式

让我们深入探究`x,x,ⅆ}`从上一段代码中提取的语法. 如果匹配的属性名称与您要声明的变量相同,则可以实际缩短语法: 

```js
var { x, y, z } = bar();

console.log( x, y, z );				// 4 5 6
```

很酷,对吧?

但`{,ⅆ}`离开了`X: `部分或离开`: x`的一部分吗?实际上我们要离开`X: `当我们使用较短的语法时. 这似乎不是一个重要的细节,但是你会在一瞬间理解它的重要性. 

如果你能写出较短的表格,你为什么要写出较长的表格?因为这种较长的表单实际上允许您将属性分配给不同的变量名,这有时是非常有用的: 

```js
var { x: bam, y: baz, z: bap } = bar();

console.log( bam, baz, bap );		// 4 5 6
console.log( x, y, z );				// ReferenceError
```

有一个微妙但超级重要的怪癖,了解这种变化的对象解构形式. 为了说明为什么它可以是一个问题你要小心,我们把"模式"如何正常指定对象的文字: 

```js
var X = 10, Y = 20;

var o = { a: X, b: Y };

console.log( o.a, o.b );			// 10 20
```

在`{: x,b: y }`我们知道`一`是对象属性,以及`X`是分配给它的源值. 换句话说,句法模式是`目标: 源`或者更明显,`属性别名: 值`. 我们直觉地理解这一点,因为它是一样的. `=`赋值,模式在哪里`目标=源`. 

然而,当你使用对象解构任务--就是把`{ ..}`对象文字从语法上的左边`=`操作员-您反转那个`目标: 源`模式. 

回忆: 

```js
var { x: bam, y: baz, z: bap } = bar();
```

这里的语法模式是`来源: 目标`(或`值: 变量别名`). `X: BAM`意味着`X`属性是源值和`BAM`要分配的目标变量. 换句话说,对象文本是`目标<来源`,和对象解构作业`源>目标`. 看看那是怎么翻的?

还有另一种方法来思考这个语法,这可能有助于缓解混乱. 考虑: 

```js
var aa = 10, bb = 20;

var o = { x: aa, y: bb };
var     { x: AA, y: BB } = o;

console.log( AA, BB );				// 10 20
```

在`x: AA,y: BB }`线的`X`和`Y`表示对象属性. 在`x: AA,y: BB }`线的`X`和`Y` _也_表示对象属性. 

回想一下我早些时候说过的话`{,ⅆ}`离开了`X: `的一部分吗?在这两行中,如果擦除`X: `和`Y: `片段中的部分,只剩下`AAㄡBB`和`AAㄡBB`实际上,这只是概念上的,而不是实际的. `AA`到`AA`从`BB`到`BB`. 

所以,对称性可能有助于解释为什么句法模式是故意把这6特征. 

**注: **我宁愿使用语法. `{`对于解构的任务,那会更熟悉保持一致性`目标: 源`两种用法的模式. 唉,我不得不训练我的大脑去反演,因为一些读者可能也必须这样做. 

### 不只是声明

到目前为止,我们已经使用解构分配`VaR`声明(当然,也可以使用)`让`和`const`),但将是一个通用的赋值操作,而不只是一个宣言. 

考虑: 

```js
var a, b, c, x, y, z;

[a,b,c] = foo();
( { x, y, z } = bar() );

console.log( a, b, c );				// 1 2 3
console.log( x, y, z );				// 4 5 6
```

变量已经可以宣告,然后将只做作业,正如我们已经看到的. 

**注: **对象的解构形式特别,离开的时候了`VaR`/`让`/`const`声明,我们不得不环绕整个赋值表达式中`()`因为不然`{ ..}`左边是语句中的第一个元素是一个语句块而不是一个对象. 

事实上,赋值表达式(`一`,`Y`实际上不需要只是变量标识符. 任何一个有效赋值表达式都是允许的. 例如:

```js
var o = {};

[o.a, o.b, o.c] = foo();
( { x: o.x, y: o.y, z: o.z } = bar() );

console.log( o.a, o.b, o.c );		// 1 2 3
console.log( o.x, o.y, o.z );		// 4 5 6
```

你甚至可以在解构中使用计算属性表达式. 考虑: 

```js
var which = "x",
	o = {};

( { [which]: o[which] } = bar() );

console.log( o.x );					// 4
```

这个`[这`部分是计算属性,这将导致`X`ℴℴ财产解构从问题中的对象作为赋值的来源. 这个`O [哪个]`部分只是一个普通的对象键引用,这相当于`OX`作为分配的目标. 

您可以使用一般赋值来创建对象映射/转换,例如: 

```js
var o1 = { a: 1, b: 2, c: 3 },
	o2 = {};

( { a: o2.x, b: o2.y, c: o2.z } = o1 );

console.log( o2.x, o2.y, o2.z );	// 1 2 3
```

或者您可以将对象映射到数组,例如: 

```js
var o1 = { a: 1, b: 2, c: 3 },
	a2 = [];

( { a: a2[0], b: a2[1], c: a2[2] } = o1 );

console.log( a2 );					// [1,2,3]
```

或者反过来: 

```js
var a1 = [ 1, 2, 3 ],
	o2 = {};

[ o2.a, o2.b, o2.c ] = a1;

console.log( o2.a, o2.b, o2.c );	// 1 2 3
```

或者可以重新排列一个数组到另一个数组: 

```js
var a1 = [ 1, 2, 3 ],
	a2 = [];

[ a2[2], a2[0], a2[1] ] = a1;

console.log( a2 );					// [2,3,1]
```

你甚至可以在没有临时变量的情况下解决传统的"交换两个变量"任务: 

```js
var x = 10, y = 20;

[ y, x ] = [ x, y ];

console.log( x, y );				// 20 10
```

**警告: **注意: 除非将所有的赋值表达式都包含进来,否则不应将声明与赋值混合在一起. _也_被视为宣言. 否则,您将得到语法错误. 这就是为什么在前面的例子中我必须这么做. `[ⅆ]`分别从`[ A2 [ 0 ],ⅆ] = ..`解构的任务. 尝试一下是没有意义的. `var [ A2 ] [ 0 ],ⅆ] = ..`,因为`A2 [ 0 ]`不是有效的声明标识符;它显然也不能隐式地创建一个`[ⅆ]`使用声明. 

### 重复作业

对象解构形式允许源物业(持有任何值类型)被多次列出. 例如:

```js
var { a: X, a: Y } = { a: 1 };

X;	// 1
Y;	// 1
```

这也意味着你可以解构子对象/阵列性能和捕获的子对象数组的值本身. 考虑: 

```js
var { a: { x: X, x: Y }, a } = { a: { x: 1 } };

X;	// 1
Y;	// 1
a;	// { x: 1 }

( { a: X, a: Y, a: [ Z ] } = { a: [ 1 ] } );

X.push( 2 );
Y[0] = 10;

X;	// [10,2]
Y;	// [10,2]
Z;	// 1
```

提醒一句关于解构: 它可能是诱人的解构的任务列表都在一个单一的线已在我们迄今所做的探讨. 然而,传播解构分配模式多行的这是一个更好的主意,使用适当的压痕,就像你会在JSON或文字对象的价值ℴℴ可读性的缘故. 

```js
// harder to read:
var { a: { b: [ c, d ], e: { f } }, g } = obj;

// better:
var {
	a: {
		b: [ c, d ],
		e: { f }
	},
	g
} = obj;
```

记得:**解构的目的不仅仅是少打字,但陈述的可读性. **

#### 解构赋值表达式

与解构的对象或数组赋值表达式作为其完成价值的充分右手对象数组的值. 考虑: 

```js
var o = { a:1, b:2, c:3 },
	a, b, c, p;

p = { a, b, c } = o;

console.log( a, b, c );			// 1 2 3
p === o;						// true
```

在前一段代码中,`P`被分配的`o`对象引用,而不是`一`,`B`,或`C`价值观. 同样是解构真实阵列: 

```js
var o = [1,2,3],
	a, b, c, p;

p = [ a, b, c ] = o;

console.log( a, b, c );			// 1 2 3
p === o;						// true
```

通过对象数组的值通过完成,你可以链解构赋值表达式一起: 

```js
var o = { a:1, b:2, c:3 },
	p = [4,5,6],
	a, b, c, x, y, z;

( {a} = {b,c} = o );
[x,y] = [z] = p;

console.log( a, b, c );			// 1 2 3
console.log( x, y, z );			// 4 5 4
```

### 太多,太少,够了

与数组分配对象解构解构的任务,你不需要将所有的价值是. 例如:

```js
var [,b] = foo();
var { x, z } = bar();

console.log( b, x, z );				// 2 4 6
```

这个`一`和`三`从中返回的值`foo()`被丢弃,如`五`价值`bar()`. 

同样,如果你试图把更多的价值比现在的价值你解构/分解,你优雅的后备`未定义`正如你所预料的: 

```js
var [,,c,d] = foo();
var { w, z } = bar();

console.log( c, z );				// 3 6
console.log( d, w );				// undefined undefined
```

这种行为与前面所说的对称. `未定义`"失踪"原则. 

我们检查了`ⅆ`操作符在本章的前面,看到它有时可以用来将数组值传播到它的独立值中,有时它可以用来做相反的事情: 将一组值集合在一起组成一个数组. 

除了函数声明中的集合/ REST用法之外,`ⅆ`在解构的任务执行相同的行为. 为了举例说明,让我们回忆一下本章前面的一段代码: 

```js
var a = [2,3,4];
var b = [ 1, ...a, 5 ];

console.log( b );					// [1,2,3,4,5]
```

在这里我们看到`ⅆ一`传播`一`出来,因为它出现在数组中`㄰..]`价值定位. 如果`ⅆ一`出现在数组解构的位置,它执行的聚集行为: 

```js
var a = [2,3,4];
var [ b, ...c ] = a;

console.log( b, c );				// 2 [3,4]
```

这个`VAR [ ..] =一`解构分配差`一`分配给内部描述的模式`㄰..]`. 第一部分名称`B`对于第一个值`一`(`二`). 但随后`Cⅆ`收集其余的值(`三`和`四`进入数组并调用它`C`. 

**注: **我们已经看到了`ⅆ`与数组一起工作,但是使用对象呢?这不是一个6特征,但见8章的一个可能的"讨论超出6"的特征`ⅆ`用于传播或收集对象. 

### 默认值分配

解构形式可以提供一个分配一个默认值的选项,使用`=`与前面讨论的默认函数参数值类似的语法. 

考虑: 

```js
var [ a = 3, b = 6, c = 9, d = 12 ] = foo();
var { x = 5, y = 10, z = 15, w = 20 } = bar();

console.log( a, b, c, d );			// 1 2 3 12
console.log( x, y, z, w );			// 4 5 6 20
```

可以将默认值赋值与前面所述的替代赋值表达式语法相结合. 例如:

```js
var { x, y, z, w: WW = 20 } = bar();

console.log( x, y, z, WW );			// 4 5 6 20
```

小心混淆自己(或其他开发人员阅读你的代码)如果你使用一个对象或数组作为一个解构的默认值. 你可以创建一些很难理解的代码: 

```js
var x = 200, y = 300, z = 100;
var o1 = { x: { y: 42 }, z: { y: z } };

( { y: x = { y: y } } = o1 );
( { z: y = { y: z } } = o1 );
( { x: z = { y: x } } = o1 );
```

你能从那个片段中看出什么值吗?`X`,`Y`,和`Z`到底有没有?需要一段时间的沉思,我可以想象. 我将结束悬念: 

```js
console.log( x.y, y.y, z.y );		// 300 100 42
```

这里的外卖: 解构是伟大的,可以是非常有用的,但它也是一把锋利的剑,能造成伤害(人的大脑)如果使用不当. 

### 嵌套的解构

如果你将价值观具有嵌套的对象或数组,你可以解构这些嵌套的值以及: 

```js
var a1 = [ 1, [2, 3, 4], 5 ];
var o1 = { x: { y: { z: 6 } } };

var [ a, [ b, c, d ], e ] = a1;
var { x: { y: { z: w } } } = o1;

console.log( a, b, c, d, e );		// 1 2 3 4 5
console.log( w );					// 6
```

嵌套的解构可以是一个简单的方法,把对象的命名空间. 例如:

```js
var App = {
	model: {
		User: function(){ .. }
	}
};

// instead of:
// var User = App.model.User;

var { model: { User } } = App;
```

### 破坏

在下面的片段中,你能发现作业吗?

```js
function foo(x) {
	console.log( x );
}

foo( 42 );
```

这个任务有点隐藏: `四十二`(参数)分配给`X`(参数)何时`美孚(42)`执行. 如果参数/参数配对是一个赋值,则它是一个任务可以分解,对吗?当然!

考虑的参数数组的解构: 

```js
function foo( [ x, y ] ) {
	console.log( x, y );
}

foo( [ 1, 2 ] );					// 1 2
foo( [ 1 ] );						// 1 undefined
foo( [] );							// undefined undefined
```

对象解构为参数的作品,太: 

```js
function foo( { x, y } ) {
	console.log( x, y );
}

foo( { y: 1, x: 2 } );				// 2 1
foo( { y: 42 } );					// undefined 42
foo( {} );							// undefined undefined
```

这种技术是命名参数的近似(js的一个长期请求的特性!),在对象上的属性映射到结构参数相同的名字. 这也意味着,我们可以得到任意参数(在任何位置)都是免费的,正如你可以看到的. `X`"参数"按我们期望的方式工作. 

当然,所有前面讨论的变化我们可以解构参数包括嵌套解构,解构,默认值,和更多. 将混合好也与其他6函数参数的能力,如默认参数值和休息/收集参数. 

考虑这些快速的插图(当然不是详尽的可能的变化): 

```js
function f1([ x=2, y=3, z ]) { .. }
function f2([ x, y, ...z], w) { .. }
function f3([ x, y, ...z], ...w) { .. }

function f4({ x: X, y }) { .. }
function f5({ x: X = 10, y = 20 }) { .. }
function f6({ x = 10 } = {}, { y } = { y: 10 }) { .. }
```

让我们从这个片段中获取一个示例,并对其进行检查,以供说明之用: 

```js
function f3([ x, y, ...z], ...w) {
	console.log( x, y, z, w );
}

f3( [] );							// undefined undefined [] []
f3( [1,2,3,4], 5, 6 );				// 1 2 [3,4] [5,6]
```

有两`ⅆ`这里使用的操作符,它们都在数组中收集值(`Z`和`W`),虽然`ⅆZ`从第一个数组参数剩下的值中收集,同时`ⅆW`从第一部分剩下的主要论点中收集起来. 

#### 解构违约+参数默认值

有一个微妙的一点你应该特别小心,注意--解构的默认值和函数参数的默认值之间的行为差异. 例如:

```js
function f6({ x = 10 } = {}, { y } = { y: 10 }) {
	console.log( x, y );
}

f6();								// 10 10
```

首先,我们似乎声明了一个默认值`十`两`X`和`Y`参数,但以两种不同的方式. 然而,这两种不同的方法在某些情况下的表现会有所不同,差别是非常微妙的. 

考虑: 

```js
f6( {}, {} );						// 10 undefined
```

等等,为什么会这样?很明显,命名参数`X`默认为`十`如果不作为第一个参数对象中相同名称的属性传递. 

但怎么样`Y`存在`未定义`?这个`{ 10 }`价值是一个对象作为函数参数的默认值,而不是将默认值. 因此,只有当第二个参数未被传递,或者作为`未定义`. 

在前一段代码中,我们_是_传递第二个参数(`{ }`)所以默认值`{ 10 }`不使用值,以及`{是}`发生在通过解构`{ }`空对象值. 

现在,比较`{ y=y: 10 }`到`{ = 10 } } { }`. 

对于`X`如果省略第一个函数参数,则使用表单的`未定义`,的`{ }`默认应用空对象. 然后,无论第一个参数位置中的值是多少,都是默认值. `{ }`不管你是通过在结构与`{ = 10 }`,它检查是否`X`属性被找到,如果没有找到(或`未定义`),这`十`默认值应用于`X`命名参数. 

深呼吸. 读几段最后几段. 让我们通过代码复习: 

```js
function f6({ x = 10 } = {}, { y } = { y: 10 }) {
	console.log( x, y );
}

f6();								// 10 10
f6( undefined, undefined );			// 10 10
f6( {}, undefined );				// 10 10

f6( {}, {} );						// 10 undefined
f6( undefined, {} );				// 10 undefined

f6( { x: 2 }, { y: 3 } );			// 2 3
```

一般看来,违约行为的`X`参数可能是比较理想和明智的情况. `Y`. 因此,重要的是了解为什么和如何`{ = 10 } } { }`形式不同于`{ y=y: 10 }`形式. 

如果仍然有点模糊,回去读一遍,然后自己玩这个. 未来的你会感谢你抽出时间来把这个非常微妙的细节,直了. 

#### 嵌套的默认值: 解构和重组

虽然起初可能很难把握,一个有趣的习语出现设置默认为一个嵌套的对象的属性: 使用对象将随着我所说的_重组_. 

考虑嵌套对象结构中的一组默认值,如下所示: 

```js
// taken from: http://es-discourse.com/t/partial-default-arguments/120/7

var defaults = {
	options: {
		remove: true,
		enable: false,
		instance: {}
	},
	log: {
		warn: true,
		error: true
	}
};
```

现在,让我们假设您有一个对象`配置`其中一些应用程序,但可能不是全部,您希望在丢失的点中设置所有默认值,但不能覆盖已经存在的特定设置: 

```js
var config = {
	options: {
		remove: false,
		instance: null
	}
};
```

当然,你可以手动完成,就像你过去做过的那样: 

```js
config.options = config.options ƜƜ {};
config.options.remove = (config.options.remove !== undefined) ?
	config.options.remove : defaults.options.remove;
config.options.enable = (config.options.enable !== undefined) ?
	config.options.enable : defaults.options.enable;
...
```

讨厌.

其他人可能更喜欢这个任务的分配重写方法. 你可能会被诱惑的ES6`对象(ⅆ)`实用程序(参见第6章)首先克隆属性`默认值`然后用克隆的属性覆盖`配置`就这样: 

```js
config = Object.assign( {}, defaults, config );
```

看起来更漂亮,是吗?但是有一个大问题!`对象(ⅆ)`是浅的,也就是说它拷贝的时候. `defaults.options`它只是复制对象引用,而不是将对象的属性克隆到一个`config.options`对象. `对象(ⅆ)`需要在对象树的所有级别上应用(排序)递归,以获得预期的深层克隆. 

**注: **很多JS工具库/框架提供深CLO自己的选择

让我们看看ES6对象解构与默认值可以帮助所有: 

```js
config.options = config.options ƜƜ {};
config.log = config.log ƜƜ {};
({
	options: {
		remove: config.options.remove = defaults.options.remove,
		enable: config.options.enable = defaults.options.enable,
		instance: config.options.instance = defaults.options.instance
	} = {},
	log: {
		warn: config.log.warn = defaults.log.warn,
		error: config.log.error = defaults.log.error
	} = {}
} = config);
```

不如虚伪的诺言好`对象(ⅆ)`(只是它很浅),但我认为它比手动方法更好. 尽管如此,它仍然是冗长而重复的. 

前一段的方法因为我是黑客的解构和违约机制做财产`=未定义的`我的检查和分配决定. 这是一个诡计,我解构`配置`(见`=配置`在代码段结束),但我将所有的破坏值回`配置`,与`config.options.enable`分配参考. 

不过还是太多了. 看看我们能不能做得更好. 

如果你知道所有的各种性能,你将是唯一的命名以下技巧最好的作品. 你仍然可以即使不是这样做的,但它不是好的,你要做的解构阶段,或创造独特的局部变量作为临时的别名. 

如果我们全面解构的所有特性在高层次的变量,我们可以立即改组重建原来的嵌套的对象结构. 

但是所有这些临时变量都会污染范围. 所以,让我们用块作用域(见"块作用域声明"在本章的前面)与一般`{ }`围挡: 

```js
// merge `defaults` into `config`
{
	// destructure (with default value assignments)
	let {
		options: {
			remove = defaults.options.remove,
			enable = defaults.options.enable,
			instance = defaults.options.instance
		} = {},
		log: {
			warn = defaults.log.warn,
			error = defaults.log.error
		} = {}
	} = config;

	// restructure
	config = {
		options: { remove, enable, instance },
		log: { warn, error }
	};
}
```

这似乎更好些,对吧?

**注: **你还可以用一个箭头,而不是一般的实现范围外壳`{ }`块和`让`声明. 你的解构任务/默认会在参数列表和你的重组将是`返回`函数体中的语句. 

这个`{警告,错误}`重构部分中的语法看起来很新,这就是所谓的"简明属性",我们将在下一节介绍它!

## 文字对象的扩展

6增添了许多以谦逊的重要方便扩展`{ ..}`对象字面量. 

### 简洁的特性

您当然熟悉在这个表单中声明对象文本: 

```js
var x = 2, y = 3,
	o = {
		x: x,
		y: y
	};
```

如果总是觉得多余的话`X: X`到处都是好消息. 如果需要定义与词汇标识符相同的属性,则可以将其从`X: X`到`X`. 考虑: 

```js
var x = 2, y = 3,
	o = {
		x,
		y
	};
```

### 简洁的方法

以类似的精神,我们刚才检查的简明属性,附加在对象文字中的属性的函数也有一个简洁的形式,以方便. 

旧方法: 

```js
var o = {
	x: function(){
		// ..
	},
	y: function(){
		// ..
	}
}
```

而作为ES6: 

```js
var o = {
	x() {
		// ..
	},
	y() {
		// ..
	}
}
```

**警告: **而`x() { ..}`似乎只是速记`X: function() { ..}`简明的方法有特殊的行为,而年长的则没有. `超级的`(参见"对象"`超级的`"本章后面). 

发电机(见第4章)也有简明的方法形式: 

```js
var o = {
	*foo() { .. }
};
```

#### 简洁的命名

而方便的速记是相当有吸引力的,有需要注意的一个微妙的问题. 例如,让我们检查pre-es6像下面这样的代码,你可能会试图重构使用简洁的方法: 

```js
function runSomething(o) {
	var x = Math.random(),
		y = Math.random();

	return o.something( x, y );
}

runSomething( {
	something: function something(x,y) {
		if (x > y) {
			// recursively call with `x`
			// and `y` swapped
			return something( y, x );
		}

		return y - x;
	}
} );
```

这显然是愚蠢的代码只产生两个随机数减去较小较大. 但这里重要的不是它做什么,而是它是如何定义的. 让我们把重点放在对象文字和函数定义上,正如我们在这里看到的: 

```js
runSomething( {
	something: function something(x,y) {
		// ..
	}
} );
```

为什么我们都说`什么东西: `和`功能点`?这不是多余的吗?事实上,不,两者都需要不同的目的. 物业`某物`我们可以打电话`o.something(..)`有点像它的公共名称. 但第二`某物`是一个用于从内部引用函数的词汇名称,用于递归目的. 

你能看出为什么吗?`返回某物(y,x)`需求名称`某物`参考函数?这个对象没有词汇名称,所以它可以说`返回o.something(Y,X)`or something of that sort.

当对象文本确实有一个识别名时,这实际上是一种非常常见的做法,例如: 

```js
var controller = {
	makeRequest: function(..){
		// ..
		controller.makeRequest(..);
	}
};
```

这是个好主意吗?也许,也许不是. 你在假定这个名字`控制器`总是指向所讨论的对象. 但很可能不是ℴℴ`makerequest(..)`函数不能控制外部代码,所以不能强迫情况如此. 这可能会回来咬你. 

其他人更喜欢使用`这`定义这样的东西: 

```js
var controller = {
	makeRequest: function(..){
		// ..
		this.makeRequest(..);
	}
};
```

这看起来不错,如果您总是调用方法作为`控制器. makerequest(..)`. 但是你现在有`这`结合了如果你做这样的事: 

```js
btn.addEventListener( "click", controller.makeRequest, false );
```

当然,你可以通过传球来解决这个问题. `控制器. makerequest绑定(控制器). `作为处理程序引用以将事件绑定到. 但讨厌的-它不是很吸引人. 

或者如果你的内心`这makerequest(..). `调用需要从嵌套函数中获得吗?你会有另一个`这`结合风险,人们往往会与容易的解决`var =`,例如: 

```js
var controller = {
	makeRequest: function(..){
		var self = this;

		btn.addEventListener( "click", function(){
			// ..
			self.makeRequest(..);
		}, false );
	}
};
```

更讨厌. 

**注: **有关更多信息`这`有约束力的规则和陷阱,看1-2章_对象原型_本系列的标题. 

好的,这和C有什么关系?`某事(ⅆ)`方法定义: 

```js
runSomething( {
	something: function something(x,y) {
		// ..
	}
} );
```

第二`某物`这里提供了一个超级方便的词汇识别,将始终指向函数本身,给我们递推的完善提供参考,事件的结合/解离,等等--不乱搞`这`或试图使用一个不可信任的对象引用. 

伟大的!

所以,现在我们试图重构函数参考这6简洁方法: 

```js
runSomething( {
	something(x,y) {
		if (x > y) {
			return something( y, x );
		}

		return y - x;
	}
} );
```

乍一看很好,但这段代码会中断. 这个`归还某物(ⅆ)`打电话找不到`某物`标识符,这样你就可以得到一个`引用错误`. 哎呀.但是为什么呢?

上述6段的含义: 

```js
runSomething( {
	something: function(x,y){
		if (x > y) {
			return something( y, x );
		}

		return y - x;
	}
} );
```

仔细看. 你查到了问题吗?简明的方法定义意味着`函数: (x,y)`. 看看第二个`某物`我们依赖的被省略了吗?换句话说,简洁的方法意味着匿名函数表达式. 

是啊,真恶心. 

**注: **你可能会想`= >`箭头函数在这里是一个很好的解决方案,但它们也同样不足,因为它们也是匿名函数表达式. 我们将在本章后面的"箭头函数"中介绍它们. 

部分可取的消息是我们的`某物(x,y)`简洁的方法不会完全匿名. 看到"函数名"7章约6函数名推理规则信息. 这对我们的递归没有帮助,但至少有助于调试. 

那么我们剩下的关于简洁方法的结论是什么呢?它们又短又甜,而且很方便. 但你应该只使用他们,如果你不需要他们做递归或事件的结合/解离. 否则,坚持你的旧学校. `某物: 起作用(ⅆ)`方法定义. 

你的很多方法可能会受益于简明的方法定义,所以这是个好消息!小心那些没有命名危险的地方. 

#### ES5的getter和setter

从技术上讲,ES5定义getter和setter的文字形式,但他们似乎并没有得到多大用,主要是由于缺乏对transpilers处理新的语法(唯一的主要新语法添加ES5,真的). 所以,这不是一个新的ES6特性,我们将简要的刷新,形式,它可能会在6前进更有用. 

考虑: 

```js
var o = {
	__id: 10,
	get id() { return this.__id++; },
	set id(v) { this.__id = v; }
}

o.id;			// 10
o.id;			// 11
o.id = 20;
o.id;			// 20

// and:
o.__id;			// 21
o.__id;			// 21 -- still!
```

在类中也有这些消气剂和定标文字形式;参见第3章. 

**警告: **这可能并不明显,但设置文字必须有一个声明的参数;省略或列出其他参数是非法的语法. 单一所需参数_可以_用解构和默认值(例如,`设置ID({ = v = 0 }){}`)但收集/休息`ⅆ`是不允许的. `设置id(ⅆv){ⅆ}`). 

### 计算属性名称

您可能处于如下代码片段中,其中有一个或多个属性名称来自某种表达式,因此不能将其放入对象文本中: 

```js
var prefix = "user_";

var o = {
	baz: function(..){ .. }
};

o[ prefix + "foo" ] = function(..){ .. };
o[ prefix + "bar" ] = function(..){ .. };
..
```

6添加语法对象文字定义允许您指定一个表达式,应计算,其结果是指定属性名称. 考虑: 

```js
var prefix = "user_";

var o = {
	baz: function(..){ .. },
	[ prefix + "foo" ]: function(..){ .. },
	[ prefix + "bar" ]: function(..){ .. }
	..
};
```

任何有效表达式都可以出现在`㄰..]`位于对象文字定义的属性名称位置. 

计算属性名最常见的用法可能是`符号`s(我们在本章后面的"符号")中包含,例如: 

```js
var o = {
	[Symbol.toStringTag]: "really cool thing",
	..
};
```

`symbol.tostringtag`是一个特殊的内置值,我们用`㄰..]`语法,所以我们可以分配`"真是酷的东西"`值为特殊属性名. 

计算属性名也可以作为简明方法的名称或简洁的生成器出现: 

```js
var o = {
	["f" + "oo"]() { .. }	// computed concise method
	*["b" + "ar"]() { .. }	// computed concise generator
};
```

### 设置`[原型]`

我们不会在这里详细介绍原型,所以要了解更多信息,请参见_对象原型_本系列的标题. 

有时候,分配`[原型]`同时声明对象的文字. 以下是一个在许多JS引擎标准扩展,但规范为ES6: 

```js
var o1 = {
	// ..
};

var o2 = {
	__proto__: o1,
	// ..
};
```

`O2`用正常的对象文字声明,但也是`[原型]`-链接`O1`. 这个`__proto__`此处的属性名称也可以是字符串. `"__proto__"`但请注意_不能_是计算属性名的结果(见上一节). 

`__proto__`至少可以说是有争议的. 这是一个几十年的老的专有扩展到JS,最终规范,有些不情愿地似乎在6. 许多开发人员认为它不应该被使用. 事实上,这是在"附录B"6,这是部分列出的东西JS认为有规范兼容的原因只有. 

**警告: **虽然我勉强赞同`__proto__`作为对象定义中的一个键,我绝对不赞成在对象属性窗体中使用它,比如`o.__proto__`. 这种形式既是一个消气剂和二传手(又出于兼容性原因),但肯定有更好的选择. 看到_对象原型_此系列的标题以获取更多信息. 

对于设置`[原型]`对于现有对象,您可以使用`对象. setprototypeof(..)`. 考虑: 

```js
var o1 = {
	// ..
};

var o2 = {
	// ..
};

Object.setPrototypeOf( o2, o1 );
```

**注: **我们将讨论`对象`再次在第6章. "`对象. setprototypeof(..)`静态函数"提供额外的细节`对象. setprototypeof(..)`. 也看到了"`对象(ⅆ)`"静态函数"的另一种形式涉及`O2`典型的以`O1`. 

### 对象`超级的`

`超级的`通常被认为只与类相关. 然而,由于JS的无阶级的对象与原型性质,`超级的`同样有效,几乎相同的行为,与平原对象的简明方法. 

考虑: 

```js
var o1 = {
	foo() {
		console.log( "o1:foo" );
	}
};

var o2 = {
	foo() {
		super.foo();
		console.log( "o2:foo" );
	}
};

Object.setPrototypeOf( o2, o1 );

o2.foo();		// o1:foo
				// o2:foo
```

**警告: ** `超级的`只允许用简洁的方法,而不是正则函数表达式属性. 它也只允许在`super.xxx`表单(用于属性/方法访问),不在`super()`形式. 

这个`超级的`在借鉴`foo() O2. `方法是静态锁定的. `O2`,特别是`[原型]`属于`O2`. `超级的`这里基本上是`getprototypeof(O2)的对象. `ℴℴ解决`O1`当然ℴℴ这是它如何找到和调用的. `foo() O1. `. 

详情请看`超级的`参见第3章中的"类". 

## 模板文字

在本章一开始,我就要叫这名字真6特征ⅆ误导,取决于你的经验与这个词_模板_意味着. 

许多开发商认为模板作为可重复使用的渲染块的文本,如大多数模板引擎提供的能力(胡子,把手,等). 6的措辞_模板_将意味着类似的东西,比如声明可重新呈现的内联模板文字的方法. 然而,这并不是思考这个特性的正确方法. 

所以,在我们继续之前,我重命名为它应该被称为: _插入字符串_(或_interpoliterals_简称). 

您已经很清楚地声明了字符串文本`"`或`'`分隔符,你也知道,这些都不是_聪明的字符串_(如某些语言),其中的内容将被解析为插值表达式. 

然而,6介绍了一种新的字符串类型,使用`` ` ``那些作为分隔符. 这些字符串文字允许嵌入基本的字符串插值表达式,然后自动进行分析和评估. 

这里的老pre-es6方式: 

```js
var name = "Kyle";

var greeting = "Hello " + name + "!";

console.log( greeting );			// "Hello Kyle!"
console.log( typeof greeting );		// "string"
```

现在,考虑新的6路: 

```js
var name = "Kyle";

var greeting = `Hello ${name}!`;

console.log( greeting );			// "Hello Kyle!"
console.log( typeof greeting );		// "string"
```

正如你所看到的,我们使用了`` ` ` ..``在一系列字符周围,这些字符被解释为字符串文字,但是任何形式的表达式. `$ { }`立即解析和评价内联. 这种解析和评估的术语是_插值_(比模板更精确). 

插值字符串文字表达式的结果是一个普通的常规字符串,分配给`招呼`变量. 

**警告: ** `类型= ="字符串"的问候`说明了为什么不把这些实体的特殊模板值很重要,因为你不能分配到一些文字的巨大的形式和再利用. 这个`` ` ` ..``字符串字面值,更像是一个生活在某种意义上说,它的自动评估内联. 结果`` ` ` ..``字符串文字是简单的字符串. 

插入字符串文字的一个非常好的好处是允许它们跨多个行进行拆分: 

```js
var text =
`Now is the time for all good men
to come to the aid of their
country!`;

console.log( text );
// Now is the time for all good men
// to come to the aid of their
// country!
```

的换行符(换行符)中插入的字符串被保存在字符串值. 

除非在字面值中显示为转义转义序列,否则`\r`回车字符(代码点)`U +000D`)或值`n`回车符+换行符序列(代码点)`U +000D`和`u + 000a`)都正常化为`\n`换行字符(代码点)`u + 000a`). 不过不要担心,这种正常化是罕见的,只有在复制粘贴文本到js文件时才可能发生. 

### 插值公式

任何有效表达式都允许出现在`$ { }`在插值字符串文字中,包括函数调用ㄡ内联函数表达式调用,甚至其他插入字符串的文字!

考虑: 

```js
function upper(s) {
	return s.toUpperCase();
}

var who = "reader";

var text =
`A very ${upper( "warm" )} welcome
to all of you ${upper( `${who}s` )}!`;

console.log( text );
// A very WARM welcome
// to all of you READERS!
```

这里,内心`"{谁}"`当合并字符串时,插入字符串文字对我们来说有点方便. `谁`可变的`"S"`字符串,而不是`谁+"S"`. 有些情况下,嵌套插入字符串的文字是有帮助的,但如果你发现自己经常做这种事情,或者发现自己嵌套了好几个层次,就要小心. 

如果是这样的话,你的字符串值生产可以从一些抽象中获益. 

**警告: **作为一个注意事项,要非常小心您的代码的可读性与这种新发现的权力. 就像默认值表达式和赋值表达式的解构,只是因为你_可以_做某事并不意味着你_应该_做它. 不那么极端的新技巧,你的代码变得比6你或你的团队成员更聪明. 

#### 表达范围

关于表达式中变量的作用域的一个快速注释. 我前面提到过,插入字符串文字是一种

考虑: 

```js
function foo(str) {
	var name = "foo";
	console.log( str );
}

function bar() {
	var name = "bar";
	foo( `Hello from ${name}!` );
}

var name = "global";

bar();					// "Hello from bar!"
```

此刻`` ` ` ..``字符串文字表示,在`bar()`函数,可找到的范围`bar()`的`名称`变量的值`"酒吧"`. 无论是全球`名称`也没有`富(ⅆ)`的`名称`物质. 换句话说,一个内插的字符串是词法作用域,它的出现,不以任何方式的动态范围. 

### 标签模板文字

再次,为理智起见重命名功能: _标记字符串_. 

老实说,这是一个凉爽的把戏,6提供. 这似乎有点奇怪,也许不是所有的普遍实用的第一次. 但一旦您花了一些时间,标记的字符串可能会让您感到惊讶. 

例如:

```js
function foo(strings, ...values) {
	console.log( strings );
	console.log( values );
}

var desc = "awesome";

foo`Everything is ${desc}!`;
// [ "Everything is ", "!"]
// [ "awesome" ]
```

让我们花一点时间来考虑前一段代码中正在发生的事情. 首先,跳出的最不和谐的东西是`'一切ℹ;`. 那不像我们以前见过的. 这是怎么一回事?

它本质上是一种特殊的函数调用,不需要`(..)`. 这个_标签_ℴℴ`Foo`之前的部分`` ` ` ..``字符串文字--是一个应该被调用的函数值. 实际上,它可以是任何函数的表达式,甚至是返回另一个函数的函数调用,比如: 

```js
function bar() {
	return function foo(strings, ...values) {
		console.log( strings );
		console.log( values );
	}
}

var desc = "awesome";

bar()`Everything is ${desc}!`;
// [ "Everything is ", "!"]
// [ "awesome" ]
```

但是什么传递到`富(ⅆ)`函数作为字符串文字的标记调用?

第一个论点ℴℴ我们称之为`串`ℴℴ是所有普通字符串的数组(在任何插值表达式之间的内容). 我们得到两个值`串`阵列: `"一切都是"`和`"啊!"`. 

为了方便起见,在我们的示例中,我们随后将所有后续参数收集到一个数组中. `价值观`使用`ⅆ`"收集/休息"操作符(参见本章前面的"扩展/ REST"部分),当然您可以将它们作为单独的命名参数保留在`串`参数.

我们的论点集中在一起. `价值观`数组是在字符串文字中已经找到的插值表达式的结果. 显然是唯一的元素`价值观`在我们的例子中`"棒极了"`. 

您可以将这两个数组看作: `价值观`如果要将它们拼接在值之间,是分隔符吗?`串`然后,如果您将所有内容连接在一起,就会得到完整的插入字符串值. 

一个带标记的字符串文字就像在对插值表达式进行评估之后,但在编译最终字符串值之前的处理步骤,允许您从字面上生成字符串的更多控制. 

通常,字符串文字标记函数(`富(ⅆ)`在前一段)要计算一个适当的字符串值并返回它,这样你就可以使用标签的字符串作为一种价值就像未标记的字符串: 

```js
function tag(strings, ...values) {
	return strings.reduce( function(s,v,idx){
		return s + (idx > 0 ? values[idx-1] : "") + v;
	}, "" );
}

var desc = "awesome";

var text = tag`Everything is ${desc}!`;

console.log( text );			// Everything is awesome!
```

在这个片段中,`标签(ⅆ)`是一个通过操作,因为它不执行任何特殊的修改,只是使用. `减少(ⅆ)`循环和拼接/交织`串`和`价值观`在一起一样会做一个非标记字符串. 

那么有什么实际用途呢?有许多先进的产品超出了我们的讨论范围. 但这里有一个简单的想法,把数字格式化为美元(类似于基本本地化): 

```js
function dollabillsyall(strings, ...values) {
	return strings.reduce( function(s,v,idx){
		if (idx > 0) {
			if (typeof values[idx-1] == "number") {
				// look, also using interpolated
				// string literals!
				s += `$${values[idx-1].toFixed( 2 )}`;
			}
			else {
				s += values[idx-1];
			}
		}

		return s + v;
	}, "" );
}

var amt1 = 11.99,
	amt2 = amt1 * 1.08,
	name = "Kyle";

var text = dollabillsyall
`Thanks for your purchase, ${name}! Your
product cost was ${amt1}, which with tax
comes out to ${amt2}.`

console.log( text );
// Thanks for your purchase, Kyle! Your
// product cost was $11.99, which with tax
// comes out to $12.95.
```

如果一个`数`值在`价值观`数组,我们放`"$"`在它前面,把它格式化为小数点后两位数. `(2)固定`. 否则,我们的价值就不会受到影响. 

#### 原始字串

在前面的代码段中,我们的标记函数接收我们调用的第一个参数. `串`,这是一个数组. 但是还有一个额外的数据: 所有字符串的原始未处理版本. 可以使用这些字符串访问这些原始字符串值. `. 原`属性,像这样: 

```js
function showraw(strings, ...values) {
	console.log( strings );
	console.log( strings.raw );
}

showraw`Hello\nWorld`;
// [ "Hello
// World" ]
// [ "Hello\nWorld" ]
```

值的原始版本保留原始的逃脱. `\n`序列(的`\`和`n`是单独的字符),而处理过的版本认为一个换行符. 但是,前面提到的行结束标准化应用于这两个值. 

6带有一个内置的功能,可以作为一个字符串标签: `字符串(ⅆ)`. 它只是通过原始版本的`串`价值观: 

```js
console.log( `Hello\nWorld` );
// Hello
// World

console.log( String.raw`Hello\nWorld` );
// Hello\nWorld

String.raw`Hello\nWorld`.length;
// 12
```

字符串文字标记的其他用途包括国际化ㄡ本地化和更多的特殊处理!

## 箭头功能

我们碰上了`这`与本章前面的函数绑定的并发症,它们在_对象原型_本系列的标题. 理解挫折是很重要的. `这`与正常功能的基础编程带来的,因为这是新的6的主要动机`= >`箭头功能特征. 

让我们首先说明箭头函数的样子,与普通函数比较: 

```js
function foo(x,y) {
	return x + y;
}

// versus

var foo = (x,y) => x + y;
```

箭头函数定义由一个参数列表(零个或多个参数)及其周围组成. `(..)`如果没有一个参数),后面是`= >`标记,后跟一个函数体. 

因此,在前一段代码中,箭头函数只是`(x,y)= y + y`部分,函数引用恰好分配给变量. `Foo`. 

身体只需要被`{ ..}`如果有多个表达式,或者该体由非表达式语句组成. 如果只有一个表达式,则忽略了周围`{ ..}`有一个隐含的`返回`在前面的表达式中,如前一段代码所示. 

这里还有一些其他的箭头函数需要考虑: 

```js
var f1 = () => 12;
var f2 = x => x * 2;
var f3 = (x,y) => {
	var z = x * 2 + y;
	y++;
	x *= 3;
	return (x + y + z) / 2;
};
```

箭头功能_总是_函数表达式;没有箭头函数声明. 它也应该清楚他们是匿名函数表达式--他们没有指定参考用于递归或事件的结合/解离-虽然"函数名"7章将描述用于调试目的ES6的函数名推理规则. 

**注: **正常功能参数的所有功能都可用箭头功能,包括默认值,解构,其余参数,等等. 

箭头的功能有一个很好的ㄡ短的语法,这使得他们表面上写简洁的代码很有吸引力. 事实上,几乎所有的文献6(除了在这一系列的标题)似乎立即和完全采用箭头功能"的新功能. "

它告诉我们,在几乎所有的例子都是箭头功能探讨短单表的公用事业,如那些为各种公用事业通过回调. 例如:

```js
var a = [1,2,3,4,5];

a = a.map( v => v * 2 );

console.log( a );				// [2,4,6,8,10]
```

在这些情况下,如果您有这样的内联函数表达式,并且它们适合于在一个语句中计算快速计算并返回结果的模式,箭头函数看起来更像是一个有吸引力的轻量级替代方案. `功能`关键字和语法. 

大多数人倾向于_惊讶_在像这样的简洁的例子中,正如我想象的那样,你刚刚做到了!

但是,我要提醒你,在我看来有点滥用此功能使用箭头功能语法与其他正常的ㄡ多语句的功能,特别是那些否则会自然地表示为函数声明. 

回忆`dollabillsyall(..)`本章前面的字符串文字标记函数ℴℴ让我们将其更改为使用`= >`语法: 

```js
var dollabillsyall = (strings, ...values) =>
	strings.reduce( (s,v,idx) => {
		if (idx > 0) {
			if (typeof values[idx-1] == "number") {
				// look, also using interpolated
				// string literals!
				s += `$${values[idx-1].toFixed( 2 )}`;
			}
			else {
				s += values[idx-1];
			}
		}

		return s + v;
	}, "" );
```

在这个例子中,我做的唯一修改是删除`功能`,`返回`,和一些`{ ..}`然后插入`= >`和一个`VaR`. 这是对代码可读性的显著改进吗?无聊的.

我真的认为缺乏`返回`和外`{ ..}`部分掩盖了这样一个事实: `减少(ⅆ)`调用是唯一的语句`dollabillsyall(..)`函数,其结果是调用的预期结果. 此外,训练有素的眼睛是如此习惯于寻找单词. `功能`在寻找范围界限的代码中,现在需要查找`= >`标记,这在代码中很难找到. 

虽然不是一个严格和快速的规则,我要说的可读性获得`= >`箭头函数转换与被转换函数的长度成反比. 函数越长,越少. `= >`帮助;功能越短,越多. `= >`可以照. 

我认为采取这种做法可能更明智合理. `= >`对于代码中的位置,您需要简短的内联函数表达式,但将正常长度的主要函数保留为. 

### 不仅语法较短,而且`这`

大部分的注意力集中在`= >`一直在保存这些珍贵的键盘下降`功能`,`返回`,和`{ ..}`从你的代码. 

但是到目前为止我们已经跳过了一个大的细节. 我在那节的开头说`= >`函数与`这`结合行为. 事实上,`= >`箭头功能_主要设计_改变`这`以特定的方式处理特定的和常见的疼痛点`这`感知编码. 

按键的储蓄是一个红色的鲱鱼,充其量误导杂耍. 

让我们再看一下本章前面的另一个例子: 

```js
var controller = {
	makeRequest: function(..){
		var self = this;

		btn.addEventListener( "click", function(){
			// ..
			self.makeRequest(..);
		}, false );
	}
};
```

我们使用`var =`黑客,然后引用`自我. makerequest(..)`因为在回调函数中,我们传递给`addEventListener(..)`,的`这`绑定将与它中的不一样. `makerequest(..)`本身. 换句话说,因为`这`绑定是动态的,我们通过词汇表返回词汇范围的可预测性. `自己`变量. 

在这里,我们终于可以看到的主要设计特点`= >`箭头功能. 内部箭头函数`这`绑定不是动态的,而是词汇化的. 在前一段代码中,如果我们为回调使用了一个箭头函数,`这`可以预见,我们希望它是. 

考虑: 

```js
var controller = {
	makeRequest: function(..){
		btn.addEventListener( "click", () => {
			// ..
			this.makeRequest(..);
		}, false );
	}
};
```

词汇`这`在前一段代码中的箭头函数回调中,现在指向与在包围中相同的值. `makerequest(..)`功能. 换言之,`= >`是句法表达式吗?`var =`. 

在案件`var =`(或者,另一个函数)`绑定(这个)`打电话通常会有帮助,`= >`箭头功能

不那么简单. 

如果`= >`取代`var =`或`绑定(这个)`它有帮助,如果你使用它会发生什么`= >`用一个`这`感知功能_不_需要`var =`工作?你也许能猜出它会把事情搞得一团糟. 是啊.

考虑: 

```js
var controller = {
	makeRequest: (..) => {
		// ..
		this.helper(..);
	},
	helper: (..) => {
		// ..
	}
};

controller.makeRequest(..);
```

虽然我们援引`控制器. makerequest(..)`,的`this.helper`引用失败,因为`这`这里没有指向`控制器`正常情况下. 它指向哪里?它由继承`这`从周围的范围. 在前面的代码片段中,这是全局范围,其中`这`指向全局对象. 啊. 

除了词法`这`箭头函数也有词法. `争论`-他们没有自己的`争论`而是从其父继承,而不是从词法上继承. `超级的`和`new.target`(见第3章中的"类"). 

所以现在我们可以总结出一套更微妙的规则. `= >`是适当的而不是: 

-   如果有一个简短的单语句内联函数表达式,其中惟一的语句是`返回`某个计算值,_和_这个函数还不能构成一个`这`内部参考,_和_没有自我参考(递归,事件的结合/解离),_和_你不合理的期望函数那样的方式,你可以将它作为一个`= >`箭头功能. 
-   如果你有一个依赖于`var =`黑客或`绑定(这个)`在封闭函数中调用它以确保正确`这`绑定,该内部函数表达式可能安全地成为`= >`箭头功能. 
-   如果你有一个依赖于类似事物的内部函数表达式`var args =阵列. 原型. 片叫(参数). `在封闭函数中进行词法复制. `争论`这个内部函数表达式可能会安全地成为`= >`箭头功能. 
-   一切正常的函数声明,再多语句的函数表达式,需要词汇名称自参考函数(递归,等等),以及任何其他的功能不符合以往的特点--你应该避免`= >`功能语法. 

底线: `= >`是关于词汇绑定的`这`,`争论`,和`超级的`. 这是故意的设计解决一些常见的问题,不是错误,怪癖,或错误的ES6. 

不要相信任何炒作`= >`主要是,甚至主要是关于更少的击键. 无论是保存击键还是浪费按键,您都应该清楚地知道每一个字符键入的内容. 

**提示: **如果你有一个函数,对于任何这些明确的原因都不是很好的匹配. `= >`箭头函数,但它被声明为对象文本的一部分,从本章前面的"简明方法"中回忆起,还有一个更短的函数语法选项. 

如果您喜欢一个可视化的决策图,如何/为什么要选择箭头函数: 

<img src="fig1.png">

## `对..`环

加入`对于`和`对..`从我们都熟悉JavaScript循环ㄡES6添加`对..`循环,循环在由a生成的值组上. _迭代器_. 

循环的值`对..`必须是一个_可迭代的_它必须是一个值,它可以被强制/装箱到一个对象中(参见_类型与语法_这一系列的标题),是一个. 一个简单的物体,能够产生一个迭代器,其中循环再利用. 

让我们来比较一下`对..`到`对..`说明差异: 

```js
var a = ["a","b","c","d","e"];

for (var idx in a) {
	console.log( idx );
}
// 0 1 2 3 4

for (var val of a) {
	console.log( val );
}
// "a" "b" "c" "d" "e"
```

正如你所看到的,`对..`在键/索引中循环`一`阵列,而`对..`在值中循环`一`. 

这里的pre-es6版`对..`从前面的代码段: 

```js
var a = ["a","b","c","d","e"],
	k = Object.keys( a );

for (var val, i = 0; i < k.length; i++) {
	val = a[ k[i] ];
	console.log( val );
}
// "a" "b" "c" "d" "e"
```

这里的6但非ℴ`对..`等价的,它还提供了在第3章中手动迭代迭代器(参见"迭代器")的一瞥: 

```js
var a = ["a","b","c","d","e"];

for (var val, ret, it = a[Symbol.iterator]();
	(ret = it.next()) && !ret.done;
) {
	val = ret.value;
	console.log( val );
}
// "a" "b" "c" "d" "e"
```

封面下面`对..`回路要求迭代器迭代器(使用内置的`symbol.iterator`参见第7章中的"众所周知的符号",然后重复调用迭代器并将其生成的值赋给循环迭代变量. 

在JavaScript中,默认情况下可迭代对象标准内置值(或提供): 

-   阵列
-   串
-   发电机(见第3章)
-   收藏/ typedarrays(见5章)

**警告: **默认情况下,普通对象不适合`对..`循环. 这是因为它们没有默认迭代器,这是有意的,而不是错误的. 然而,我们不会再为那些微妙的推理在这里. 在第3章的"迭代器"中,我们将看到如何为我们自己的对象定义迭代器,这让我们可以`对..`在任何对象上循环以获得一组我们定义的值. 

下面是如何在原始字符串中循环字符: 

```js
for (var c of "hello") {
	console.log( c );
}
// "h" "e" "l" "l" "o"
```

这个`"你好"`原始字符串值被强制/装箱到`字符串`包装对象的等效,这是默认的一个. 

在`对于(ABC的XYZ)ⅆ`,的`XYZ`子句既可以是赋值表达式,也可以是与同一子句相同的声明. `对于`和`对..`环. 所以你可以做一些事情

```js
var o = {};

for (o.a of [1,2,3]) {
	console.log( o.a );
}
// 1 2 3

for ({x: o.a} of [ {x: 1}, {x: 2}, {x: 3} ]) {
  console.log( o.a );
}
// 1 2 3
```

`对..`循环可以过早地停止,就像其他循环一样. `打破`,`持续`,`返回`(如果在函数中),抛出异常. 在任何这些情况下,迭代器的`返回(..)`如果需要,函数将自动调用(如果存在),让迭代器执行清理任务. 

**注: **看到"在可迭代对象和迭代器更完整的覆盖在3章迭代器". 

## 正则表达式

让我们面对现实: js的正则表达式在很长一段时间里变化不大. 因此,他们终于学会了一些在6新花样的一件大事. 我们将在这里简单地介绍附加内容,但是正则表达式的整个主题非常密集,您需要转向专门讨论它的章节(其中有很多)!如果你需要复习一下. 

### Unicode的旗帜

我们将在本章后面的"Unicode"中更详细地介绍Unicode的主题. 在这里,我们将简单地看看新的`u`6 +正则表达式为标志,即Unicode,表达式匹配. 

JavaScript字符串通常被解释为16位字符的序列,这些字符对应于_基本多语言平面(BMP)_([HTTP: / /恩. 维基百科. org /维基/ plane\_ % 28unicode % 29](http://en.wikipedia.org/wiki/Plane_%28Unicode%29)). 但有许多UTF-16字符,不属于这个范围,所以字符串可能在他们这些多字节字符. 

前6,正则表达式只匹配基于BMP字符,这意味着扩展字符被视为两个独立的字符匹配的目的. 这往往不是理想的. 

所以,作为6,的`u`标志告诉正则表达式处理Unicode字符串的解释(UTF-16)字符,这样扩展字符会匹配一个单一的实体. 

**警告: **尽管这个名字的含义,"UTF-16"并不严格的意思是16位. 现代Unicode使用21比特,如UTF-8和UTF-16标准参考大致有多少位用于字符表示. 

例(直接从6规范): (音乐符号G-clef)是Unicode点u + 1d11e(0x1d11e). 

如果这个字符出现在正则表达式模式中(比如`/ /`),标准的BMP的解读是,这是两个不同的字符(0xd834和0xdd1e)匹配. 但新的ES6 Unicode模式意味着`/ / U`(或转义的Unicode形式)`/ \ U { 1d11e } / U`)将匹配`""`在字符串中作为单个匹配字符. 

你可能想知道为什么这很重要?在非Unicode BMP模式中,模式被视为两个独立的字符,但仍然会在字符串中找到与`""`如果你尝试,你可以看到它里面的字符: 

```js
/𝄞/.test( "𝄞-clef" );			// true
```

比赛的长度是最重要的. 例如:

```js
/^.-clef/ .test( "𝄞-clef" );		// false
/^.-clef/u.test( "𝄞-clef" );		// true
```

这个`^ -谱号. `在模式中说只匹配一个字符在开始之前正常. `"谱号"`文本. 在标准BMP模式下,匹配失败(两个字符),但`u`Unicode模式标记,匹配成功(一个字符). 

同样重要的是要注意`u`使量词一样`+`和`*`将整个Unicode代码点应用为单个字符,而不仅仅是_较低的替代_(又名右一半的符号)的字符. 字符类中出现的Unicode字符也是如此,比如`[和]`. 

**注: **还有更多的细节关于`u`在正则表达式中的行为,Mathias Bynens(<https://twitter.com/mathias>)广泛地写了关于(<https://mathiasbynens.be/notes/es6-unicode-regex>). 

### 粘贴标志

另一个抢旗模式添加到正则表达式是6`Y`这通常被称为"粘性模式". _粘粘的_从本质上说,正则表达式在其开头有一个虚拟锚,它使其根在仅由正则表达式的位置所匹配的位置上匹配. `lastIndex`财产. 

为了举例说明,让我们考虑两个正则表达式,第一个表达式没有粘滞模式,第二个表达式包含: 

```js
var re1 = /foo/,
	str = "++foo++";

re1.lastIndex;			// 0
re1.test( str );		// true
re1.lastIndex;			// 0 -- not updated

re1.lastIndex = 4;
re1.test( str );		// true -- ignored `lastIndex`
re1.lastIndex;			// 4 -- not updated
```

关于这个片段要观察的三件事: 

-   `测试(ⅆ)`不注意`lastIndex`的值,并且总是从输入字符串的开始执行匹配. 
-   因为我们的模式没有`^`输入锚的开始,搜索`"foo"`可以自由前进通过整个字符串寻找一个匹配. 
-   `lastIndex`不更新`测试(ⅆ)`. 

现在,让我们尝试一个粘滞模式正则表达式: 

```js
var re2 = /foo/y,		// <-- notice the `y` sticky flag
	str = "++foo++";

re2.lastIndex;			// 0
re2.test( str );		// false -- "foo" not found at `0`
re2.lastIndex;			// 0

re2.lastIndex = 2;
re2.test( str );		// true
re2.lastIndex;			// 5 -- updated to after previous match

re2.test( str );		// false
re2.lastIndex;			// 0 -- reset after previous match failure
```

所以我们对粘滞模式的新观察: 

-   `测试(ⅆ)`使用`lastIndex`作为准确和唯一的位置`STR`找火柴. 前面没有人在找比赛,要么就在那儿. `lastIndex`地位与否. 
-   如果比赛成功,`测试(ⅆ)`更新`lastIndex`在比赛后立即指出角色. 如果比赛失败,`测试(ⅆ)`重置`lastIndex`回到`零`. 

正常的非粘性模式,否则`^`-根到输入的开始是自由前进在输入字符串寻找一个匹配. 但是粘滞模式限制了模式匹配的位置. `lastIndex`. 

当我`Y`在模式的开始部分是一个虚拟锚点,它是相对的(也就是说限制了比赛的开始). `lastIndex`位置. 

**警告: **在以前的关于这个主题的文献中,有人断言这种行为是相似的. `Y`这意味着一个`^`(输入开始)模式中的锚点. 这是不准确的. 稍后我们将在"锚粘"中进一步解释. 

#### 粘粘的定位

似乎很奇怪地限制了它的使用. `Y`对于重复的匹配,您必须手动确保`lastIndex`处于正确的位置,因为它没有提前匹配的能力. 

这里有一个可能的场景: 如果你知道你关心的比赛总是在一个数字的倍数处,`零`,`十`,`二十`您可以只构建一个匹配您关心的有限模式,然后手动设置. `lastIndex`每次比赛前,这些固定位置. 

考虑: 

```js
var re = /f../y,
	str = "foo       far       fad";

str.match( re );		// ["foo"]

re.lastIndex = 10;
str.match( re );		// ["far"]

re.lastIndex = 20;
str.match( re );		// ["fad"]
```

但是,如果您正在解析一个字符串,而不是在固定位置那样格式化,那么找出要设置的位置. `lastIndex`在每场比赛之前都可能是站不住脚的. 

这里有一个节省的细微差别需要考虑. `Y`要求`lastIndex`处于比赛的准确位置. 但这并不是严格要求的. _你_手动设置`lastIndex`. 

相反,你可以用这样一种方式来构建你的表达方式,在每一个主要的匹配之前,在你关心的事情之前和之后,在你关心的下一件事情之前,把它们捕获. 

因为`lastIndex`在匹配结束后,如果匹配了所有的字符,将设置为下一个字符,`lastIndex`将始终处于正确的位置`Y`从下一次开始的模式. 

**警告: **如果不能以这样一种充分模式化的方式来预测输入字符串的结构,这种技术可能并不合适,您可能无法使用. `Y`. 

结构化字符串输入可能是最实际的场景. `Y`将能够在字符串中执行重复匹配. 考虑: 

```js
var re = /\d+\.\s(.*?)(?:\sƜ$)/y
	str = "1. foo 2. bar 3. baz";

str.match( re );		// [ "1. foo ", "foo" ]

re.lastIndex;			// 7 -- correct position!
str.match( re );		// [ "2. bar ", "bar" ]

re.lastIndex;			// 14 -- correct position!
str.match( re );		// ["3. baz", "baz"]
```

之所以如此,是因为我提前知道了输入字符串的结构: 总是有一个数字前缀. `"1. "`在想要的比赛之前(`"foo"`,或者后面的空格,或者字符串的结尾(`美元`锚). 因此,我构建的正则表达式在每个主匹配中捕获所有这些,然后使用匹配组. `()`为了方便起见,我真正关心的东西被分开了. 

第一场比赛之后(`"1. Foo"`),这`lastIndex`是`七`,这已经是开始下一场比赛所需要的位置了. `"2. 酒吧"`等等. 

如果你打算使用`Y`重复比赛的粘性模式,你可能会想寻找机会. `lastIndex`自动定位,正如我们刚才演示. 

#### 粘性与全球

有些读者可能意识到你可以效仿这样的东西. `lastIndex`-相对匹配`G`全局匹配标志和`行政长官(ⅆ)`方法,因此: 

```js
var re = /o+./g,		// <-- look, `g`!
	str = "foot book more";

re.exec( str );			// ["oot"]
re.lastIndex;			// 4

re.exec( str );			// ["ook"]
re.lastIndex;			// 9

re.exec( str );			// ["or"]
re.lastIndex;			// 13

re.exec( str );			// null -- no more matches!
re.lastIndex;			// 0 -- starts over now!
```

虽然那是真的`G`模式匹配`行政长官(ⅆ)`开始匹配`lastIndex`的当前值,并更新`lastIndex`每一场比赛(或失败)之后,这不是同一回事. `Y`行为. 

注意在前一段代码中`"书"`位于位置`六`被匹配和发现的第二个`行政长官(ⅆ)`即使当时打电话,`lastIndex`是`四`(上一场比赛结束时). 为什么?因为正如我们前面所说的,非粘性匹配可以在匹配中向前移动. 一个粘滞模式表达式在这里会失败,因为它不允许向前移动. 

除了在匹配行为方面不受欢迎之外,另一个缺点就是使用. `G`而不是`Y`是的,`G`更改某些匹配方法的行为,例如`str.match(RE)`. 

考虑: 

```js
var re = /o+./g,		// <-- look, `g`!
	str = "foot book more";

str.match( re );		// ["oot","ook","or"]
```

看一次所有的比赛是怎么回来的?有时候没关系,但有时候这不是你想要的. 

这个`Y`粘贴标志会给你时间与事业一样进行匹配`测试(ⅆ)`和`比赛(ⅆ)`. 只要确定`lastIndex`每场比赛总是处于正确的位置!

#### 锚粘

正如我们早些时候警告过的那样,认为粘滞模式意味着一个模式开始时是不准确的. `^`. 这个`^`锚在正则表达式中有明确的含义,它是_没有改变_粘性模式. `^`是一个锚_总是_指输入的开始,以及_是不是_以任何方式相对于`lastIndex`. 

除了可怜的/不准确的关于这一主题的文档,混乱是进一步加强由于旧pre-es6实验与Firefox的粘滞模式_做_制作`^`相对于`lastIndex`所以这种行为已经存在多年了. 

6选择不这样做. `^`在模式中意味着绝对和唯一的输入开始. 

因此,像这样的模式`和`将永远只找到一个`"foo"`字符串开头的匹配,_如果允许在那里匹配_. 如果`lastIndex`是`零`比赛将失败. 考虑: 

```js
var re = /^foo/y,
	str = "foo";

re.test( str );			// true
re.test( str );			// false
re.lastIndex;			// 0 -- reset after failure

re.lastIndex = 1;
re.test( str );			// false -- failed for positioning
re.lastIndex;			// 0 -- reset after failure
```

底线: `Y`加`^`加`lastIndex > 0`是一个不兼容的组合,总是会导致一个失败的匹配. 

**注: **而`Y`不改变意思`^`无论如何,`M`多行模式_做_,这样`^`表示输入开始_或_正文开始后换行. 所以,如果你结合`Y`和`M`旗帜一起为一个模式,你可以找到多个`^`根字符串中的根匹配. 但是请记住: 因为它是`Y`粘糊糊的,你得弄清楚`lastIndex`每一个后续时间都指向正确的新行位置(可能是匹配到行的结尾),否则将不会进行后续匹配. 

### 正则表达式`旗帜`

6之前,如果你想检查一个正则表达式对象看到它应用了什么旗帜--讽刺的是你需要解析出来,可能与另一个正则表达式的内容ℴℴ`来源`属性,例如: 

```js
var re = /foo/ig;

re.toString();			// "/foo/ig"

var flags = re.toString().match( /\/([gim]*)$/ )[1];

flags;					// "ig"
```

截至6,你现在可以直接得到这些值,随着新的`旗帜`财产: 

```js
var re = /foo/ig;

re.flags;				// "gi"
```

这是一个小的差别,但6规范要求表达的标志是这个顺序列出: `"gimuy"`不管原始模式是用什么顺序指定的. 这就是两者之间差异的原因. `/搞笑`和`"GI"`. 

不,指定或列出的标志顺序无关紧要. 

另一个办法是,从6`正则表达式(..)`构造函数是现在`旗帜`-如果您传递它一个已有的正则表达式: 

```js
var re1 = /foo*/y;
re1.source;							// "foo*"
re1.flags;							// "y"

var re2 = new RegExp( re1 );
re2.source;							// "foo*"
re2.flags;							// "y"

var re3 = new RegExp( re1, "ig" );
re3.source;							// "foo*"
re3.flags;							// "gi"
```

此前的6,`3`建设将抛出一个错误,但作为6可以覆盖国旗在复制. 

## 数字扩展

之前ES5,数文字看起来像下面的八进制形式没有正式规定,只允许作为一个扩展,浏览器已经事实上的协议: 

```js
var dec = 42,
	oct = 052,
	hex = 0x2a;
```

**注: **虽然你是指定在不同基地的数量,数量的数学值被存储,并默认输出解释永远是10. 前一段代码中的三个变量都有`四十二`存储在它们中的值. 

进一步说明`052`是一个非标准的表单扩展,请考虑: 

```js
Number( "42" );				// 42
Number( "052" );			// 52
Number( "0x2a" );			// 42
```

ES5继续允许浏览器扩展的八进制形式(包括这种不一致),但在严格的模式ㄡ八进制字面(`052`)的形式是不允许的. 这限制了主要是因为很多开发商已经习惯(从其他语言)看似无害化前缀另有10号`零`用于代码对齐的目的,然后遇到一个意外的事实,即他们完全改变了数值!

6继续变化/变化如何数文字以外的普通数字可以表示的遗产. 现在有正式八进制格式ㄡ经过修改的十六进制形式和全新的二进制形式. 出于Web兼容性的原因,旧八进制`052`在非严格模式下,表单仍将是合法的(尽管未指明),但真的不应该再使用了. 

这是新的文学形式6号: 

```js
var dec = 42,
	oct = 0o52,			// or `0O52` :(
	hex = 0x2a,			// or `0X2a` :/
	bin = 0b101010;		// or `0B101010` :/
```

只有小数形式可以是10. 八进制ㄡ十六进制和二进制都是整数形式. 

这些表单的字符串表示都可以被强制转换为它们的数字等价: 

```js
Number( "42" );			// 42
Number( "0o52" );		// 42
Number( "0x2a" );		// 42
Number( "0b101010" );	// 42
```

虽然不到6严格新,鲜为人知的事实是你可以去的相反方向转化(嗯,差不多): 

```js
var a = 42;

a.toString();			// "42" -- also `a.toString( 10 )`
a.toString( 8 );		// "52"
a.toString( 16 );		// "2a"
a.toString( 2 );		// "101010"
```

事实上,您可以在任何基础上以这样的方式表示一个数字. `二`到`三十六`尽管你很少去标准基地: 2, 8, 10和16. 

## Unicode

我想说的是,这一部分并不是你想知道的关于Unicode资源的全部内容. 我想介绍一下你需要知道的东西. _改变_Unicode在6,但我们不会做得比这更深. Mathias Bynens(<http://twitter.com/mathias>)关于JS和Unicode的广泛和精辟的书面和口头发言(参见<https://mathiasbynens.be/notes/javascript-unicode>和<http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode>). 

Unicode字符,范围从`0x0000`到`0xffff`包含你可能见过或与之交互的所有标准印刷字符(用各种语言). 这组字符被称为_基本多语言平面(BMP)_. BMP甚至包含有趣的符号,这样酷的雪人: ☃(U + 2603). 

除了BMP集之外,还有许多其他扩展Unicode字符,它的范围包括`0x10ffff`. 这些符号常被称为_星光_符号,这是给16的集合的名称. _飞机_BMP以外的字符(例如层/分组). 星符号的例子包括(U + 1d11e)和(U + 1f4a9). 

前6,JavaScript字符串,可以使用Unicode转义指定Unicode字符,如: 

```js
var snowman = "\u2603";
console.log( snowman );			// "☃"
```

然而,这`\uxxxx`Unicode转义仅支持四个十六进制字符,因此只能用这种方式表示BMP字符集. 代表使用Unicode逃跑之前6星体而言,你需要使用一个_代理对_基本上是两个规格

```js
var gclef = "\uD834\uDD1E";
console.log( gclef );			// "𝄞"
```

截至6,我们现在有一种新的形式(在Unicode转义字符串和正则表达式),称为Unicode_代码点逃逸_: 

```js
var gclef = "\u{1D11E}";
console.log( gclef );			// "𝄞"
```

正如你所看到的,不同之处在于`{ }`在转义序列中,该序列允许包含任意数量的十六进制字符. 因为你只需要六在Unicode代表最高可能的代码点的值(即,0x10ffff),这是足够的. 

### Unicode感知字符串操作

默认情况下,JavaScript字符串操作和方法对字符串值中的星形符号不敏感. 因此,他们分别对待每一个BMP字符,甚至是构成另一个星体角色的两个代理半角色. 考虑: 

```js
var snowman = "☃";
snowman.length;					// 1

var gclef = "𝄞";
gclef.length;					// 2
```

那么,我们如何精确计算这样一个字符串的长度呢?在这种情况下,下面的技巧会起作用: 

```js
var gclef = "𝄞";

[...gclef].length;				// 1
Array.from( gclef ).length;		// 1
```

回忆起"`对..`环"部分在本章前面,6字符串有内置的迭代器. 这个迭代器恰好是Unicode感知的,这意味着它将自动输出一个星体符号作为一个值. 我们利用了`ⅆ`在数组文字中展开运算符,它创建字符串符号的数组. 然后我们只检查这个结果数组的长度. 6的`数组(ⅆ)`基本上是一样的事情`[ⅆⅆXYZ ]`但我们将在第6章中详细介绍该实用程序. 

**警告: **应该注意的是,构建和耗尽一个迭代器以获得字符串的长度在性能上是相当昂贵的,相对而言,与理论上优化的本地实用程序/属性所做的工作相比. 

不幸的是,完整的答案并不是那么简单明了. 除了代理对(字符串迭代器所关心的)之外,还有一些特殊的Unicode代码点,它们以其他特殊的方式运行,这很难解释. 例如,有一组代码点修改前一个相邻字符,称为_组合用附加符号_. 

考虑这两个字符串输出: 

```js
console.log( s1 );				// "é"
console.log( s2 );				// "é"
```

它们看起来一样,但它们不是!以下是我们如何创建`S1`和`S2`: 

```js
var s1 = "\xE9",
	s2 = "e\u0301";
```

正如你可能猜到的,我们以前的`长度`把戏不起作用`S2`: 

```js
[...s1].length;					// 1
[...s2].length;					// 2
```

那么我们能做什么呢?在这种情况下,我们可以执行_万国码规范化_在值之前询问其长度,使用6`字符串#规范(..)`实用程序(我们将在第6章中详细介绍): 

```js
var s1 = "\xE9",
	s2 = "e\u0301";

s1.normalize().length;			// 1
s2.normalize().length;			// 1

s1 === s2;						// false
s1 === s2.normalize();			// true
```

基本上,`规范化(ⅆ)`像一个序列`E u0301"`和规范它`"\xE9"`. 如果结合了合适的Unicode字符,标准化甚至可以合并多个相邻的组合标记: 

```js
var s1 = "o\u0302\u0300",
	s2 = s1.normalize(),
	s3 = "ồ";

s1.length;						// 3
s2.length;						// 1
s3.length;						// 1

s2 === s3;						// true
```

不幸的是,这里的标准化并不完全完美. 如果有多个组合标记修改单个字符,则可能无法得到预期的长度计数,因为可能没有一个定义的标准化字符表示所有标记的组合. 例如:

```js
var s1 = "e\u0301\u0330";

console.log( s1 );				// "ḛ́"

s1.normalize().length;			// 2
```

你沿着这个兔子洞走得越远,你就越意识到很难得到一个"长度"的精确定义. _石墨烯_ℴℴ并不总是严格地与程序处理意义上的单个"字符"相关. 

**提示: **如果你想看到的是如何深入这个兔子洞,检查"字形簇边界"算法([HTTP: / / www.unicode. org /报告/ tr29 / # grapheme_cluster_boundaries](http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)). 

### 角色定位

类似长度并发症,它实际上意味着问,"什么是字符在位置2?"天真的pre-es6回答来自`charAt(..)`,不尊重一个星体性质的原子性,也考虑到结合标志. 

考虑: 

```js
var s1 = "abc\u0301d",
	s2 = "ab\u0107d",
	s3 = "ab\u{1d49e}d";

console.log( s1 );				// "abćd"
console.log( s2 );				// "abćd"
console.log( s3 );				// "ab𝒞d"

s1.charAt( 2 );					// "c"
s2.charAt( 2 );					// "ć"
s3.charAt( 2 );					// "" <-- unprintable surrogate
s3.charAt( 3 );					// "" <-- unprintable surrogate
```

所以,是6给我们一个Unicode版本`charAt(..)`?不幸的是,我写这篇文章的时候,有这样一个工具,是考虑post-es6在提案. 

但是我们在前一节中所探索的(当然还有它所指出的局限性)!,我们可以回答一个6: 

```js
var s1 = "abc\u0301d",
	s2 = "ab\u0107d",
	s3 = "ab\u{1d49e}d";

[...s1.normalize()][2];			// "ć"
[...s2.normalize()][2];			// "ć"
[...s3.normalize()][2];			// "𝒞"
```

**警告: **提醒前面的警告: 每当您想获得单个字符时,构造和耗尽迭代器是ⅆ不是很理想,性能聪明. 让我们希望我们有一个内置的优化工具很快,post-es6. 

那么Unicode感知版本的`charcodeat(..)`效用?6给我们`codepointat(..)`: 

```js
var s1 = "abc\u0301d",
	s2 = "ab\u0107d",
	s3 = "ab\u{1d49e}d";

s1.normalize().codePointAt( 2 ).toString( 16 );
// "107"

s2.normalize().codePointAt( 2 ).toString( 16 );
// "107"

s3.normalize().codePointAt( 2 ).toString( 16 );
// "1d49e"
```

另一个方向呢?Unicode感知版本`字符串. fromcharcode(..)`是6的`字符串. fromcodepoint(..)`: 

```js
String.fromCodePoint( 0x107 );		// "ć"

String.fromCodePoint( 0x1d49e );	// "𝒞"
```

等等,我们可以合并吗?`字符串. fromcodepoint(..)`和`codepointat(..)`获得一个更好的Unicode感知版本`charAt(..)`从早期的?是的!

```js
var s1 = "abc\u0301d",
	s2 = "ab\u0107d",
	s3 = "ab\u{1d49e}d";

String.fromCodePoint( s1.normalize().codePointAt( 2 ) );
// "ć"

String.fromCodePoint( s2.normalize().codePointAt( 2 ) );
// "ć"

String.fromCodePoint( s3.normalize().codePointAt( 2 ) );
// "𝒞"
```

还有很多其他的字符串方法我们没有在这里讨论,包括`touppercase()`,`tolowercase()`,`子串(..)`,`IndexOf(..)`,`切片(..)`还有十几个. 所有这些都没有更改或增强为完整的Unicode意识,所以您应该非常小心-可能只是避免它们!ℴℴ当使用包含星体符号的字符串时. 

还有几个字符串方法`替换(ⅆ)`和`比赛(ⅆ)`. 值得庆幸的是,6带来Unicode意识的正则表达式,得到"UNICODE"在本章的前面. 

好的,我们有!JavaScript的Unicode字符串的支持明显优于pre-es6(尽管还不完善)与各种添加我们刚刚覆盖. 

### Unicode标识符名称

Unicode也可以用于标识符名称(变量ㄡ属性等). 6之前,你可以做的与Unicode转义,如: 

```js
var \u03A9 = 42;

// same as: var Ω = 42;
```

截至6,你也可以使用之前的代码点转义语法解释: 

```js
var \u{2B400} = 42;

// same as: var 𫐀 = 42;
```

有一套复杂的规则围绕着哪些Unicode字符被允许. 此外,只有当它们不是标识符名称的第一个字符时才允许. 

**注: **Mathias Bynens有一个伟大的职位(<https://mathiasbynens.be/notes/javascript-identifiers-es6>)所有的细节. 

在标识符名称中使用这种不寻常字符的原因是相当罕见的和学术性的. 通过编写依赖于这些深奥功能的代码,您通常不会得到最好的服务. 

## 符号

与6,在相当长的一段时间是第一次,一个新的原始类型已被添加到JavaScript的`符号`. 然而,与其他原始类型不同的是,符号没有文字形式. 

下面是如何创建符号的方法: 

```js
var sym = Symbol( "some optional description" );

typeof sym;		// "symbol"
```

值得注意的事情: 

-   你不能也不应该使用`新的`具有`符号(..)`. 它不是构造函数,也不是生成对象. 
-   传递给`符号(..)`是可选的. 如果传递的话,它应该是一个字符串,可以对符号的用途进行友好的描述. 
-   这个`类型`输出是一个新值(`"符号"`这是识别符号的主要方法. 

的描述,如果提供,仅用于表示符号的字符串化所带来的: 

```js
sym.toString();		// "Symbol(some optional description)"
```

类似于原始字符串值不是实例的`字符串`符号也不是`符号`. 如果出于某种原因,您想要构造一个符号值的包装器对象形式,您可以执行以下操作: 

```js
sym instanceof Symbol;		// false

var symObj = Object( sym );
symObj instanceof Symbol;	// true

symObj.valueOf() === sym;	// true
```

**注: ** `symobj`在这个片段中可以互换`对称`任何一种形式都可以在所有地方使用符号. 没有太多的理由使用盒装包装器对象表单(`symobj`而不是原始形式. `对称`). 保持对其他原语的类似建议,最好还是选择`对称`结束`symobj`. 

符号本身的内部值,称为符号值. `名称`ℴℴ隐藏在代码中,无法获得. 可以将这个符号值视为自动生成的ㄡ唯一的(在应用程序中)字符串值. 

但是,如果值是隐藏的,无法获得,在所有具有象征的意义是什么?

符号的要点是创建一个字符串值,它不能与任何其他值冲突. 因此,例如,考虑使用符号作为表示事件名称的常量: 

```js
const EVT_LOGIN = Symbol( "event.login" );
```

然后你会使用`evt_login`代替一般字符串文字`"事件"登录`: 

```js
evthub.listen( EVT_LOGIN, function(data){
	// ..
} );
```

这里的好处是`evt_login`保存一个不能被任何其他值复制(意外或其他)的值,因此不可能有任何混乱的事件被分派或处理. 

**注: **封面下面`evthub`在前一段代码中假定的实用程序几乎可以肯定地使用`evt_login`直接作为跟踪事件处理程序的内部对象(hash)中的属性/键的参数. 如果`evthub`相反,需要将符号值用作真正的字符串,它需要显式强制使用`字符串(..)`或`tostring()`因为不允许符号的隐式字符串强制. 

您可以在对象中直接使用一个符号作为属性名/键,例如您希望处理为隐藏或使用中的特殊属性. 重要的是要知道,虽然你打算这样对待它,但它不是. _事实上_隐蔽的或不可触及的财产. 

考虑这个实现了_独生子女_模式行为ℴℴ也就是说,它只允许自己创建一次: 

```js
const INSTANCE = Symbol( "instance" );

function HappyFace() {
	if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];

	function smile() { .. }

	return HappyFace[INSTANCE] = {
		smile: smile
	};
}

var me = HappyFace(),
	you = HappyFace();

me === you;			// true
```

这个`实例`这里的符号值是一个特殊的ㄡ几乎是隐藏的ㄡ类似于元的属性,静态地存储在`happyface()`函数对象. 

它也可以是一个普通的老财产. `__instance`而且行为会是一样的. 一个符号的使用只是提高了元编程风格,保持这`实例`与其他正常属性分开的属性. 

### 符号注册表

在最后几个例子中使用符号的一个轻微的缺点是`evt_login`和`实例`变量必须存储在外部范围(甚至是全局范围),或者以某种方式存储在公开可用的位置,以便需要使用符号的所有代码部分都可以访问它们. 

为了帮助组织代码以访问这些符号,您可以使用_全局符号注册表_. 例如:

```js
const EVT_LOGIN = Symbol.for( "event.login" );

console.log( EVT_LOGIN );		// Symbol(event.login)
```

和: 

```js
function HappyFace() {
	const INSTANCE = Symbol.for( "instance" );

	if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];

	// ..

	return HappyFace[INSTANCE] = { .. };
}
```

`符号(ⅆ)`在全局符号注册表中查看是否已将符号存储在所提供的描述文本中,如果返回,则返回符号. 如果没有,它创造

但这也意味着应用程序的任何部分都可以从注册表中检索符号. `符号(ⅆ)`只要使用匹配描述名即可. 

讽刺的是,符号基本上是用来取代_魔力字符串_(在应用程序中给定特殊含义的任意字符串值). 但你准确地使用_魔术_描述字符串值以在全局符号注册表中唯一地标识/定位它们!

为了避免意外碰撞,您可能希望使您的符号描述非常独特. 这样做的一个简单的方法是在其中包括前缀/背景/命名空间信息. 

例如,考虑一个实用工具,如以下: 

```js
function extractValues(str) {
	var key = Symbol.for( "extractValues.parse" ),
		re = extractValues[key] ƜƜ
			/[^=&]+?=([^&]+?)(?=&Ɯ$)/g,
		values = [], match;

	while (match = re.exec( str )) {
		values.push( match[1] );
	}

	return values;
}
```

我们使用魔法字符串值. `"extractvalues. 解析"`因为注册表中的任何其他符号都不可能与该描述相冲突. 

如果此实用程序的用户希望重写解析正则表达式,则它们也可以使用符号注册表: 

```js
extractValues[Symbol.for( "extractValues.parse" )] =
	/..some pattern../g;

extractValues( "..some string.." );
```

除了符号注册表提供的帮助,全局存储这些值,我们在这里看到的一切都可以通过实际使用魔术字符串来完成. `"extractvalues. 解析"`作为关键,而不是符号. 改进存在的元编程水平超过功能水平. 

您可能有机会使用存储在注册表中的符号值来查找存储在其下面的描述文本(key). 例如,您可能需要向应用程序的另一个部分发出信号,如何在注册表中定位符号,因为无法传递符号值本身. 

您可以使用一个已注册符号的描述文本(key)检索`的象征. 关键(..)`: 

```js
var s = Symbol.for( "something cool" );

var desc = Symbol.keyFor( s );
console.log( desc );			// "something cool"

// get the symbol from the registry again
var s2 = Symbol.for( desc );

s2 === s;						// true
```

### 符号作为对象属性

如果一个符号被用作对象的属性/键,它将以特殊的方式存储,这样属性就不会出现在对象属性的正常枚举中: 

```js
var o = {
	foo: 42,
	[ Symbol( "bar" ) ]: "hello world",
	baz: true
};

Object.getOwnPropertyNames( o );	// [ "foo","baz" ]
```

检索对象的符号属性: 

```js
Object.getOwnPropertySymbols( o );	// [ Symbol(bar) ]
```

这清楚地表明属性符号实际上并不是隐藏的或不可访问的,因为您可以在`对象. getownpropertysymbols(..)`列表. 

#### 内置的符号

6有许多预定义的内置符号,揭露各种元行为对JavaScript对象的值. 然而,这些符号是_不_注册在全局符号注册表中,正如人们所期望的那样. 

相反,它们作为属性存储在`符号`函数对象. 例如,在"`对..`在本章的前面部分,我们介绍了`symbol.iterator`价值: 

```js
var a = [1,2,3];

a[Symbol.iterator];			// native function
```

规范使用`@ @`前缀符号是指内置符号,最常见的符号是: `@ @迭代器`,`@ @ tostringtag`,`@ @ toprimitive`. 还有好几种定义,尽管它们可能不会经常使用. 

**注: **请参见第7章中的"众所周知的符号",以获得关于这些内置符号如何用于元编程目的的详细信息. 

## 回顾

6加一堆新的语法形式的JavaScript,所以有很多学习!

其中大部分旨在减轻常见编程习惯用法的疼痛点,例如将默认值设置为函数参数,并将参数的"REST"收集到数组中. 解构是简洁地表达值的数组分配一个强大的工具和嵌套的对象. 

而特征`= >`箭头函数看起来也都是短而漂亮的语法,它们实际上有非常特殊的行为,只有在适当的情况下才应该故意使用. 

扩展Unicode支持,正则表达式的新技巧,甚至一个新的原语`符号`型圆了6句法演变. 
