
# 你不知道JS：范围和闭包

# 第1章：什么是范围？

几乎所有编程语言最基本的范式之一是在变量中存储值，然后检索或修改这些值的能力。事实上，存储变量的值和值的能力就是给出程序的能力。_状态_。

如果没有这样的概念，程序可以执行一些任务，但它们将是非常有限的，并不是非常有趣。

但变量到我们的程序纳入生最有趣的问题，我们现在在做的那些变量的地址：_居住_？换句话说，它们存储在哪里？最重要的是，我们的程序是如何在需要的时候找到它们的呢？

这些问题说明需要一组定义良好的规则来存储某些位置的变量，以及在稍后时间找到这些变量。我们称之为规则：_范围_。

但是，在哪里，如何做这些_范围_规则集？

## 编译原理

这可能是不言而喻的，也可能是令人惊讶的，这取决于您与各种语言的交互程度，但尽管JavaScript属于“动态”或“解释”语言的一般类别，实际上它是一种编译语言。它是_不_像许多传统编译语言一样预先编译好，在各种分布式系统中编译的结果也不可移植。

但是，不管怎样，JavaScript引擎执行许多相同的步骤，尽管比我们通常知道的更复杂的方法，任何传统的语言编译器。

在传统的编译语言过程中，一段源代码，你的程序，通常会经历三个步骤。_之前_它被执行，大致称为“编译”：

1.  **标记/ Lexing：**把一串字符分成有意义的（语言）块，称为记号。例如，考虑程序：`var a＝2；`。这个程序很可能被分解成下列令牌：`VaR`，`一`，`=`，`二`，和`；`。空格可能会或可能不会坚持为表征，取决于它是否是有意义的或不。

    **注：**分词和词法分析的区别是微妙的，学术的，但它的中心是否在这些标记鉴定_无国籍_或_状态_的方式。简而言之，如果tokenizer来调用状态解析规则判断`一`应该被视为一个独特的令牌或只是另一个令牌的一部分，_那个_将**词法分析**。

2.  **解析：**获取一个流（数组）令牌并将其转换成嵌套元素的树，它们共同表示程序的语法结构。这种树叫做“AST”。<b>一</b>摘要<b>S</b>yntax<b>T</b>稀土元素）。

    树上`var a＝2；`可以从一个顶级节点开始`变量说明`，调用子节点`标识符`（其值是`一`）还有另一个孩子叫`assignmentexpression`它本身有一个孩子叫`numericliteral`（其值是`二`）。

3.  **代码生成：**接受AST并将其转换为可执行代码的过程。这部分根据语言、目标平台等不同而有很大差异。

    因此，而不是陷入细节，我们就HandWave说有办法把我们的上述AST`var a＝2；`然后把它变成一组机器指令。_创造_一个变量称为`一`（包括保留内存等），然后将值存储到`一`。

    **注：**引擎如何管理系统资源的细节比我们要深入的要多，因此我们理所当然地认为引擎能够根据需要创建和存储变量。

JavaScript引擎要复杂得多。_只是_这三个步骤，和大多数其他语言编译器一样。例如，在解析和代码生成的过程中，当然有优化执行性能的步骤，包括分解冗余元素等。

所以，我只画宽笔画在这里。但我想你很快就会明白为什么_这些_细节我们_做_即使是高水平的封面也是相关的。

一方面，JavaScript引擎没有像其他语言编译器那样有足够的时间来优化，因为JavaScript编译不像其他语言那样在构建阶段提前发生。

对于JavaScript，发生的编译在很多情况下仅仅微秒（或更少）！在执行代码之前。保证最快的性能，JS引擎使用各种技巧（如JIT编译，这懒惰甚至热重新编译，等），远远超出了“范围”，在这里我们讨论的。

让我们说，为了简单起见，JavaScript的任何代码片段都必须在以前编译（通常_正确的_前！）它被处决了。因此，js编译器将接收程序。`var a＝2；`与编译_第一_然后马上准备执行它，通常马上。

## 理解范围

我们将学习范围的方法是从对话的角度来思考这个过程。但，_谁_具有收敛

### 铸造

让我们来看看处理程序交互的字符的转换。`var a＝2；`因此，我们理解他们的谈话，我们将在不久内收听：

1.  _发动机_负责我们JavaScript程序的开始编译和执行。

2.  _编译器_：一个_发动机_的朋友；处理解析和代码生成的所有脏工作（见上一节）。

3.  _范围_另一个朋友_发动机_收集并维护所有声明的标识符（变量）的查找列表，并强制执行一组严格的规则，说明这些代码是如何被当前执行的代码访问的。

为你_充分理解_JavaScript是如何工作的，你需要开始_认为_喜欢_发动机_（和朋友）思考，问他们提出的问题，并回答同样的问题。

### 来来回回

当你看到程序时`var a＝2；`你很可能认为这是一种说法。但我们的新朋友却不是这样。_发动机_看到它。事实上，_发动机_看到两个不同的语句，其中一个_编译器_将在编译期间处理，其中一个_发动机_执行期间将处理。

所以，让我们分解_发动机_和朋友们将接近程序`var a＝2；`。

的第一件事_编译器_会与此程序进行词法分析将其分解成记号，它将解析成一棵树。但当_编译器_到代码生成时，它将比假设的有所不同。

合理的假设是_编译器_将生成可以由这个伪代码总结的代码：“为一个变量分配内存，并标记它`一`, then stick the value`二`进入那个变量。“不幸的是，这不太准确。”。

_编译器_将继续进行：

1.  遇到`VaR`，_编译器_问_范围_查看变量是否`一`已经存在该特定范围集合。如果是这样的话，_编译器_忽略此声明并继续前进。否则，_编译器_问_范围_声明一个新变量`一`对于该范围集合。

2.  _编译器_然后生成代码_发动机_稍后执行，处理`= 2`分配。代码_发动机_运行将首先要求_范围_如果有一个变量被调用`一`在当前范围集合中可访问。如果是这样的话，_发动机_使用该变量。如果不是，_发动机_看_在别处_（请参阅嵌套_范围_（下节）。

如果_发动机_最终找到一个变量，它赋值。`二`它。如果不是，_发动机_会举起手喊出一个错误！

总结：对于变量赋值，有两种不同的操作：第一，_编译器_声明一个变量（如果以前没有在当前范围声明），第二个执行时，_发动机_查找变量_范围_并分配给它，如果发现。

### 编译器说

我们需要更多的编译器术语来进一步理解。

什么时候_发动机_执行代码_编译器_为步骤（2）生成的，它必须查找变量。`一`看看是否已经声明了，这个查找是咨询的。_范围_。但是查找的类型_发动机_执行会影响查找结果。

在我们的例子中，有人说_发动机_将执行“左”的变量查找`一`。查找其他类型叫做“方管”。

我打赌你能猜出“l”和“r”是什么意思。这些术语代表“左手边”和“右手边”。

侧…什么？**赋值操作的。**

换句话说，一个LHS查是当一个变量出现在赋值操作的左侧，和RHS查是当一个变量出现在右边的赋值操作侧。

事实上，让我们更精确一点。RHS查是没有区别的，对于我们而言，从简单的查找一些变量的值，而该查找到可变容器本身，所以它可以分配。这样，该不_真正地_意思是“赋值的右边”，更确切地说，意思是“不是左手边”。

稍微圆滑的那一刻，你也可以认为“右”而不是“他/她是检索源（值）”，这意味着该手段”去获得价值…”。

让我们深入探究。

当我说：

```js
console.log( a );
```

参考`一`是一个RHS的参考，因为没有被分配到`一`在这里.相反，我们正在寻找检索值。`一`以便将值传递给`控制台（…）`。

通过对比：

```js
a = 2;
```

参考`一`这里是一个LHS的参考，因为我们真的不在乎现在的价值是什么，我们只是想找到变为目标`= 2`赋值操作。

**注：**左边和右边的意思“左/右边赋值”不是字面上的意思就是“左/右侧`=`赋值运算符。也有一些其他的方法，作业发生，所以最好是在概念上认为它是：“谁是这个任务的目标（LHS）”和“谁是这个任务的来源（RHS）”。

考虑这个方案，既有左边和右边的参考：

```js
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

调用的最后一行`富（…）`一`Foo`，意思是“去查一下`Foo`然后把它给我，`（..）`意味着`Foo`应该被执行，所以最好是一个函数！

这里有一个微妙但重要的任务。**你发现了吗？**

你可能错过了暗示。`= 2`在这个代码片段中。当价值发生时`二`作为参数传递给`富（…）`函数，在这种情况下`二`值**分配**对参数`一`。（隐式）赋值给参数`一`，执行该查询。

还有一个RHS的参考价值`一`并将结果值传递给`控制台（…）`。`控制台（…）`需要一个引用来执行。这是一个右查`慰问`对象，然后发生一个属性解析，看看它是否有一个方法被调用。`日志`。

最后，我们也可以想象，有一个左/右通过价值交换`二`（通过变量的方式）`一`查到的RHS）`记录（…）`。本机内部实现`记录（…）`我们可以假设它有参数，第一个参数（也许是调用）`arg1`）有一个LHS参考查找，然后分配`二`它。

**注：**您可能会试图对函数声明进行概念化。`function foo(a) {...`作为一个普通变量声明和赋值，例如`变量Foo`和`函数（a）{…`。这样做，你可能会认为这个函数声明为涉及该查。

然而，微妙但重要的区别是_编译器_在代码生成期间处理声明和值定义，例如_发动机_执行代码时，不需要将函数值赋值给`Foo`。因此，它真的不适合把函数声明为LHS查找分配的方式我们在这里讨论这些。

### 引擎/范围会话

```js
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

让我们把上面的交换（处理这个代码片段）想象成一个会话。谈话会有点像这样：

> **_发动机_**：嘿_范围_我有一个参考，RHS`Foo`。听说过吗？
>
> **_范围_**为什么，是的，我有。_编译器_刚刚宣布。他是一个函数。干得好.
>
> **_发动机_**太好了，谢谢！好的，我正在执行`Foo`。
>
> **_发动机_**：嘿，_范围_我有一个，LHS参考`一`听说过吗？
>
> **_范围_**为什么，是的，我有。_编译器_将它声明为一个正式参数`Foo`只是最近。干得好.
>
> **_发动机_**一如既往的有用，_范围_。再次感谢。现在，分配的时间`二`到`一`。
>
> **_发动机_**：嘿，_范围_很抱歉再次打扰你。我需要一个RHS查`慰问`。听说过吗？
>
> **_范围_**没问题，_发动机_这就是我一整天都在做的。是的，我有。`慰问`。他是内置的。你走吧。
>
> **_发动机_**：完美。抬头`记录（…）`。好的，这是个函数。
>
> **_发动机_**：Yo，_范围_。你能帮我解决一个RHS参考`一`。我想我想起来了，只是想再检查一下。
>
> **_范围_**你说得对，_发动机_。同一个人，没变。你走吧。
>
> **_发动机_**：酷。传递价值`一`，这是`二`，成`记录（…）`。
>
> …

### 测验

到目前为止，请检查您的理解。一定要发挥作用_发动机_和“对话”_范围_：

```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1.  确定所有的LHS查找（有3！）。

2.  确定所有的RHS查找（有4！）。

**注：**查看问答题的章节复习！

## 嵌套作用域

我们说，_范围_是一组用标识符名称查找变量的规则。通常不止一个。_范围_然而，要考虑。

正如块或函数嵌套在另一个块或函数中一样，作用域嵌套在其他范围内。因此，如果在当前范围内找不到变量，_发动机_咨询下一个外部包含范围，直到找到或一直到最外层（又名，全局）范围为止。

考虑：

```js
function foo(a) {
	console.log( a + b );
}

var b = 2;

foo( 2 ); // 4
```

右边的参考`B`函数内不能解析`Foo`但它可以在_范围_围绕它（在这种情况下，全局）。

所以，重温一下_发动机_和_范围_，我们会听到：

> **_发动机_**“嘿，_范围_属于`Foo`听说过吗？`B`？有一个RHS参考吧。”
>
> **_范围_**：“不，从来没有听说过它。去钓鱼。”
>
> **_发动机_**“嘿，_范围_外`Foo`哦，你是全球的_范围_好酷。听说过`B`？有一个RHS参考吧。”
>
> **_范围_**“是的，当然有。给你。

遍历嵌套的简单规则_范围_：_发动机_从当前执行开始_范围_，查找变量，然后如果找不到，继续上升一级，等等。如果到达最外层的全局范围，搜索停止，不管它是否找到变量。

### 建筑隐喻

可视化嵌套的过程_范围_决心，我想让你想想这座高楼。

<img src="fig1.png" width="250">

该结构表示我们程序的嵌套。_范围_规则集。建筑物的第一层代表您当前正在执行的工作。_范围_无论你在哪里。这个建筑的顶层是全球的。_范围_。

你解决的左边和右边的引用看你目前的地板，如果你找不到它，以高度_范围_你要么找到你要找的东西，要么找不到，但不管怎样你都得停下来。

## 错误

为什么无论我们称之为左或右的事吗？

因为这两种类型的查找行为在变量尚未声明的情况下行为不同（在任何咨询中都没有发现）_范围_）。

考虑：

```js
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

当RHS查找发生`B`第一次，它将不会被发现。这是一个“未声明的”变量，因为它在范围内找不到。

如果一个节点查找未能找到任何变量，在嵌套的地方_范围_s，这导致`引用错误`被投掷_发动机_。需要注意的是，错误是该类型的。`引用错误`。

相比之下，如果_发动机_执行该查询到达顶层（全球_范围_）如果没有找到它，如果程序没有运行在“严格模式”中[^注strictmode-]然后是全球_范围_将创建该名称的新变量**在全球范围内**然后把它交给_发动机_。

_“不，以前没有，但我很有帮助，为你创造了一个。”_

“严格模式”[^注strictmode-]，这增加了ES5，有一些不同的行为从正常/轻松/懒人模式。这样的行为是不允许自动/隐式全局变量的创建。那样的话，就没有全球性的了。_范围_想变交还从LHS的查找，并_发动机_会扔`引用错误`同样的RHS情况。

现在，如果一个变量被发现对RHS查，但你要与它的价值是不可能做的事情，比如试图功能非功能价值执行，或参考上的属性`无效的`或`未定义`值，然后_发动机_抛出一种不同类型的错误，称为`TypeError`。

`引用错误`是_范围_分辨率失败有关，而`TypeError`意味着_范围_决议是成功的，但有一个非法的/不可能的行动企图反对结果。

## 回顾（TL；DR）

范围是确定查找变量（标识符）的位置和方式的规则集。这个查找可能为分配给该变量的用途，这是一个左（左边）的参考资料，也可用于检索其值的目的，这是一个右（右手边）参考。

该结果从引用赋值操作。_范围_相关的作业也可以与`=`运算符或通过传递参数（分配给）函数参数。

JavaScript_发动机_首先在执行前编译代码，这样做时，它将像语句一样拆分语句。`var a＝2；`分成两个步骤：

1.  第一,`VaR`在那声明它_范围_。这是在代码执行之前的开始执行的。

2.  后来，`= 2`查找变量（LHS参考）分配给它如果发现。

两者的左边和右边的参考查找从当前执行的_范围_如果需要的话（也就是说，他们找不到他们要找的东西），他们就在嵌套的地方工作。_范围_，一次一个范围（地板），寻找标识符，直到他们到达全局（顶层）并停止，要么找到它，要么不要。

未了的RHS参考结果`引用错误`被投掷。未了的LHS引用导致自动隐式创建的全球名称（如果不是在“严格模式”[^注strictmode-]）或`引用错误`（如果处于“严格模式”）[^注strictmode-]）。

### 测验的答案

```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1.  确定所有的LHS查找（有3！）。

    **`C = ..`，`= 2`（隐式参数赋值）和`B = ..`**

2.  确定所有的RHS查找（有4！）。

    **`美孚（2…`，`=一个；`，`+ ..`和`..+ B`**

[^注strictmode-]：MDN：[严格模式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode)
