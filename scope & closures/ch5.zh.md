
# 你不知道JS: 范围和闭包

# 第5章: 范围关闭

我们到了这里,希望能很好地了解范围的工作原理. 

我们把注意力转移到一个极其重要但却始终难以捉摸的问题上,_几乎神话_,语言的一部分: **关闭**. 如果你跟随我们的词汇范围迄今为止的讨论,这样的封闭会,很大程度上,虎头蛇尾,几乎显而易见. _巫师的帘子后面有一个人,我们就要去见他了. _. 不,他不叫Crockford!

但是,如果你对词汇范围有一些恼人的问题,那么现在是回去复习第2章之前的好时机. 

## 启示

对于那些有点JavaScript经验的人来说,他们可能从来没有完全掌握闭包的概念,_理解闭包_似乎是一个特殊的涅磐,一个必须奋斗和牺牲,以达到. 

我回忆起几年前我对JavaScript的牢牢掌握,但不知道闭包是什么. 暗示有_这另一边_的语言,一个承诺比我已经拥有更多的能力,嘲笑和奚落我. 我记得通过阅读早期框架的源代码,试图理解它实际上是如何工作的. 我记得第一次"模块模式"开始浮现在我的脑海中. 我记得_啊哈!_瞬间生动. 

那时我不知道的是,我花了多少年才明白,我希望现在能告诉你的是这个秘密: **在JavaScript中,闭包就在你周围,你必须承认并接受它. **闭包不是一种特殊的选择工具,您必须学习新的语法和模式. 不,闭包并不是一种武器,你必须学会掌握和掌握卢克在原力中的训练. 

闭包是由于编写依赖词法范围的代码而产生的. 他们只是发生. 您甚至不必特意创建闭包来利用它们. 闭包是为代码中的所有代码创建和使用的. 你是什么_丢失的_正确的心理环境是为了你自己的意愿去认识ㄡ拥抱和利用闭包吗?. 

启蒙的时刻应该是: **哦,闭包已经在我的代码中出现了,我终于可以了. _看见_他们现在. **理解闭包就像尼奥第一次看到矩阵一样. 

## 事实真相

好,夸张和无耻的电影参考. 

这是一个down-n-dirty定义你所需要知道的理解和认识闭包: 

> 闭包是当一个函数能够记住并访问它的词法范围时,即使该函数在词法范围之外执行. 

让我们跳一些代码来说明这个定义. 

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a ); // 2
	}

	bar();
}

foo();
```

我们对嵌套范围的讨论应该熟悉这段代码. 功能`bar()`有_接近_给变量`一`在外封闭范围由于词法范围查找规则(在这种情况下,它是一个RHS参考查). 

这是"封闭"吗?

嗯,技术上ⅆ_也许_. 但是我们需要知道上面的定义ⅆ_不完全_. 我想最准确的解释方法`bar()`引用`一`是通过词法范围查找规则,而这些规则是_只有_(重要的!)**部分**什么是闭包. 

从纯学术的角度来看,上面提到的代码片段是函数`bar()`有一个_关闭_超过范围`foo()`(事实上,甚至在它所访问的其他范围内,如本例中的全局范围). 说得稍有不同,据说`bar()`关闭范围`foo()`. 为什么?因为`bar()`似乎嵌套在`foo()`. 质朴. 

但是,以这种方式定义的闭包不是直接的. _观察_我们也看不到闭包_锻炼_在那个片段里. 我们清楚地看到词法范围,但是闭包仍然是代码后面一个神秘的变化的影子. 

让我们来考虑将闭包引入全光的代码: 

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a );
	}

	return bar;
}

var baz = foo();

baz(); // 2 -- Whoa, closure was just observed, man.
```

功能`bar()`词法范围访问的内部范围`foo()`. 但是,我们采取`bar()`函数本身,并通过它_作为_一个值. 在这种情况下,我们`返回`函数对象本身`酒吧`引用. 

在我们执行`foo()`我们分配它返回的值(我们的内部)`bar()`函数)调用一个变量`巴兹`然后我们实际调用`baz()`这当然是在召唤我们的内在功能. `bar()`,只是通过不同的标识符引用. 

`bar()`确实执行. 但在这种情况下,它被执行_外部_其声明的词法范围. 

后`foo()`执行,通常我们期望整个内部范围`foo()`会离去,因为我们知道_发动机_采用_垃圾收集器_当它不再使用时,它会释放内存. 因为它的内容似乎是`foo()`不再使用了,看起来应该考虑它们是很自然的. _跑了_. 

但闭包的"魔力"并没有让这种情况发生. 内在范围实际上是_仍然_"在使用中",因此不会消失. 是谁**功能`bar()`它本身**. 

凭借它被宣布的位置,`bar()`在该内部范围内有词法范围闭包. `foo()`,使该范围保持活力`bar()`以后参考. 

**`bar()`仍然有一个对该范围的引用,该引用称为闭包. **

因此,在几微秒之后,当变量`巴兹`调用(调用我们最初标记的内部函数)`酒吧`,它适时地_接近_编写时间词法范围,因此它可以访问变量. `一`正如我们所预料的. 

该函数在其作者时间词法范围之外被很好地调用. **关闭**让函数继续访问它在作者时间中定义的词法范围. 

当然,函数的任何一种方法都可以_通过周围_作为值,实际上在其他位置调用,都是观察/执行闭包的例子. 

```js
function foo() {
	var a = 2;

	function baz() {
		console.log( a ); // 2
	}

	bar( baz );
}

function bar(fn) {
	fn(); // look ma, I saw closure!
}
```

我们传递内在的功能. `巴兹`过去`酒吧`并调用内部函数(标记)`FN`现在,当我们这样做时,它在内部范围内关闭了. `foo()`通过访问观察`一`. 

这些功能可以通过在间接,太. 

```js
var fn;

function foo() {
	var a = 2;

	function baz() {
		console.log( a );
	}

	fn = baz; // assign `baz` to global variable
}

function bar() {
	fn(); // look ma, I saw closure!
}

foo();

bar(); // 2
```

无论我们使用什么设施_运输_在词法范围之外的内部函数,它将保持一个范围引用到它最初声明的位置,并且无论我们在哪里执行它,都将执行该闭包. 

## 现在我能看见了

前面的代码片段有点学术性和人工构造来说明. _使用闭包_. 但我答应给你的不仅仅是一件很酷的新玩具. 我保证闭包是你现有代码中的一部分. 现在让我们_看见_真理. 

```js
function wait(message) {

	setTimeout( function timer(){
		console.log( message );
	}, 1000 );

}

wait( "Hello, closure!" );
```

我们接受一个内部函数(命名`定时器`并把它传递给`setTimeout(..)`. 但`定时器`在范围上有一个范围闭包`等待(ⅆ)`事实上,保持和使用对变量的引用`消息`. 

一千毫秒后,我们执行`等待(ⅆ)`它的内在范围应该早已消失,内在的功能. `定时器`仍然在这个范围内关闭. 

在内心深处_发动机_内置的实用程序`setTimeout(..)`引用一些参数,可能是调用`FN`或`功能`或者类似的东西. _发动机_调用该函数,该函数调用我们的内部. `定时器`函数,词法范围引用仍然是完整的. 

**关闭.**

或者,如果您是jQuery的说服者(或者任何js框架): 

```js
function setupBot(name,selector) {
	$( selector ).click( function activator(){
		console.log( "Activating: " + name );
	} );
}

setupBot( "Closure Bot 1", "#bot_1" );
setupBot( "Closure Bot 2", "#bot_2" );
```

我不知道你写的是哪种代码,但我经常写代码,负责控制一个封闭机器人的整个全球无人飞行器,所以这是完全现实的!

(有些)开玩笑,本质上_无论何时_和_无论什么地方_对待函数(将各自的词法范围访问)作为一级值并传递它们,您很可能会看到这些函数执行闭包. 是计时器ㄡ事件处理程序ㄡAjax请求ㄡ交叉窗口消息传递ㄡWeb工作者或其他异步(或同步)!任务,当你通过A_回调函数_准备好关闭一些闭包!

**注: **3章介绍了生活模式. 虽然人们常说生活(单独)是观察关闭的一个例子,我有点不同意,在我们上面的定义. 

```js
var a = 2;

(function IIFE(){
	console.log( a );
})();
```

这段代码"有效",但这并不是严格的闭包. 为什么?因为函数(我们称之为"生活"在这里)不执行其词法范围之外. 它仍然在与声明的相同范围内调用(封闭/全局作用域). `一`). `一`通过正常的词法范围查找找到,而不是通过闭包. 

虽然技术上的关闭可能在声明时间发生,但它是_不_严格观察,因此,正如他们所说,_那棵树倒在森林里,周围没有人听见. _

虽然生活是不_它本身_闭包的一个例子,它绝对创建范围,它是我们用来创建可以关闭的范围的最常用的工具之一. 所以iifes确实是封闭的关系,即使不封闭自己. 

亲爱的读者,现在就把这本书放下. 我有一个任务给你. 打开一些最近的JavaScript代码. 寻找您的函数作为值,并确定您已经使用闭包的地方,也许以前甚至不知道它. 

我会等的. 

现在...你看!

## 循环+封闭

用来说明闭包的最常见的典型例子是for循环. 

```js
for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

**注: **棉短绒经常抱怨当你把函数内部循环,因为不了解关闭的错误**在开发人员中如此常见**. 我们在这里解释如何正确地利用闭包的全部能力. 但微妙的是往往失去了对棉短绒和他们会抱怨不管,假设你不_事实上_知道你在做什么. 

这个代码段的精神是我们通常_期待_对于行为是数字"1","2",ⅆ5"打印出来,一次一个,每秒一个. 

事实上,如果你运行这个代码,你会在一秒钟内打印出"6"5次. 

**嗯?**

首先,让我们解释一下`六`来自. 循环的终止条件是`我`是_不_ `< = 5`. 第一次是这样的. `我`6. 因此,输出反映的是`我`循环结束后. 

这在第二眼看来似乎很明显. 超时函数回调函数都运行良好的循环完成后. 事实上,就像计时器一样,即使它是`setTimeout(: 0)`在每次迭代中,所有这些函数回调仍将严格执行后循环的完成,从而打印`六`每一次. 

但这里还有一个更深层次的问题要解决. 什么_丢失的_从我们的代码,实际上有它的行为,我们的语义暗示?

缺少的是我们正在努力_意味着_循环的每一次迭代都"捕获"了它自己的副本`我`,在迭代时. 但是,作用域的工作方式,所有这5个函数,尽管它们分别在每个循环迭代中定义,所有**在相同的共享全局范围内关闭. **事实上,只有一个`我`在这. 

那样做,_当然_所有函数都共享同一个引用. `我`. 关于循环结构的一些东西会让我们迷惑,认为还有其他更复杂的东西在工作. 没有. 如果5个超时回调只是一个接一个宣称没有差别,没有在所有的环. 

好了,回到我们的问题. 什么不见了?我们需要更多的~~牛铃~~封闭范围. 具体来说,我们需要一个新的封闭循环的每个迭代的范围. 

我们学习了3章,生活创造范围,声明一个函数并立即执行. 

让我们试试: 

```js
for (var i=1; i<=5; i++) {
	(function(){
		setTimeout( function timer(){
			console.log( i );
		}, i*1000 );
	})();
}
```

这样行吗?试试. 再一次,我会等待. 

我为你结束悬念. **不.**但是为什么呢?我们现在显然有了更多的词法范围. 每一个超时函数回调确实是关闭在自己的每个生活每迭代范围分别创建. 

仅仅有一个范围关闭是不够的. **如果该范围是空的**. 仔细看. 我们的生活只是一个空无的范围. 它需要_某物_它对我们有用. 

它需要自己的变量,并有一个副本`我`每次迭代的值. 

```js
for (var i=1; i<=5; i++) {
	(function(){
		var j = i;
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})();
}
```

**尤里卡!它的工作原理!**

稍有变化,有些人更喜欢: 

```js
for (var i=1; i<=5; i++) {
	(function(j){
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})( i );
}
```

当然,由于这些iifes只是功能,我们可以通过在`我`我们可以称之为`J`如果我们愿意,我们甚至可以称之为`我`再一次.无论哪种方式,代码现在工作. 

在每一次迭代的生命的使用造成了每次迭代的一个新的范围,这给我们的超时函数回调机会近在每个迭代的一个新的范围,其中有一个变量的值在每次迭代的权利对我们的访问. 

问题解决了!

### 块范围的重新审视

仔细看一下我们对以前的解决方案的分析. 我们用一个缔造每迭代的新范围. 换句话说,我们实际上_需要_每一个迭代**块范围**. 第3章向我们展示了`让`声明,这一声明有劫持块和块中的变量对. 

**它本质上把一个块变成了一个我们可以封闭的范围. **因此,下面的代码"刚刚生效": 

```js
for (var i=1; i<=5; i++) {
	let j = i; // yay, block-scope for closure!
	setTimeout( function timer(){
		console.log( j );
	}, j*1000 );
}
```

_但是,这还不是全部!_(用我最好的Bob Barker的声音). 有一个特殊的行为被定义为`让`for循环头中使用的声明. 此行为表示该变量将不仅仅为循环声明一次,**但每次迭代**. 而且,它将被初始化,还好,在每个后续的迭代值从以前的迭代结束. 

```js
for (let i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

那有多酷?块作用域和关闭合作,解决世界上所有的问题. 我不知道你,但让我快乐的javascripter. 

## 模块

还有其他的代码模式,利用封闭的权力但不表面上看起来是关于回调. 让我们来看看最有力的: _模块_. 

```js
function foo() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}
}
```

正如这段代码现在所显示的那样,没有明显的闭包. 我们只需要一些私有数据变量. `某物`和`另一个`和几个内部功能`dosomething()`和`doanother()`,它们都有词法作用域(因此闭包)!超过内部范围`foo()`. 

但现在考虑: 

```js
function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

这就是我们称之为JavaScript的模式. _模块_. 实现模块模式最常见的方法通常称为"显示模块",这是我们在这里提供的更改. 

让我们来研究一下这个代码. 

首先,`coolmodule()`只是一个函数,但它_必须被调用_要创建一个模块实例. 没有外部函数的执行,内部范围和闭包的创建就不会发生. 

其次,该`coolmodule()`函数返回一个对象,用对象字面语法表示. `{键: 值,ⅆ}`. 我们返回的对象对我们的内在功能有参考,但是_不_对内部数据变量. 我们隐藏那些秘密的. 将这个对象返回值视为本质上是合适的. **我们模块的公共API**. 

这个对象的返回值是最终地`Foo`然后,我们可以访问API上的这些属性方法,比如`dosomething() foo. `. 

**注: **我们不需要从模块返回实际对象(文字). 我们可以直接返回内部函数. jQuery实际上就是一个很好的例子. 这个`jQuery`和`美元`标识符是jQuery"模块"的公共API,但它们本身就是一个函数(它本身可以拥有属性,因为所有函数都是对象). 

这个`dosomething()`和`doanother()`函数对模块"实例"的内部范围有关闭(通过实际调用到达)`coolmodule()`). 当我们在词法范围之外传递这些函数时,通过返回的对象的属性引用,我们现在已经建立了一个可以观察和执行闭包的条件. 

更简单地说,模块模式需要执行两个"需求": 

1.  必须有一个外部封闭函数,必须至少调用一次(每次创建一个新的模块实例). 

2.  封闭函数必须返回至少一个内部函数,以便这个内部函数在私有作用域上关闭,并且可以访问和/或修改那个私有状态. 

仅具有它的函数属性的对象不是_真正地_一个模块. 一个对象是函数返回调用它只有在它的数据的性质和功能不是没有合拢_真正地_模块,在可观察的意义上. 

上面的代码片段显示了一个独立的模块创建者`coolmodule()`可以调用任意次数,每次创建一个新模块实例. 这种模式的一个小变化是当你只关心一个实例,一个"单件"的排序: 

```js
var foo = (function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

在这里,我们把我们的模块功能为生活(见3章),我们_立即_调用它并将它的返回值直接赋给我们的模块实例标识符. `Foo`. 

模块只是函数,所以它们可以接收参数: 

```js
function CoolModule(id) {
	function identify() {
		console.log( id );
	}

	return {
		identify: identify
	};
}

var foo1 = CoolModule( "foo 1" );
var foo2 = CoolModule( "foo 2" );

foo1.identify(); // "foo 1"
foo2.identify(); // "foo 2"
```

模块模式的另一个微小但强大的变化是将您返回的对象命名为公共API: 

```js
var foo = (function CoolModule(id) {
	function change() {
		// modifying the public API
		publicAPI.identify = identify2;
	}

	function identify1() {
		console.log( id );
	}

	function identify2() {
		console.log( id.toUpperCase() );
	}

	var publicAPI = {
		change: change,
		identify: identify1
	};

	return publicAPI;
})( "foo module" );

foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```

通过在模块实例中保留对公共API对象的内部引用,您可以修改该模块实例**从里面**包括添加和移除方法ㄡ属性,_和_改变他们的价值观. 

### 现代模块

各种模块依赖加载器/管理器本质上将这种模块定义模式封装成友好的API. 与其检查任何一个特定的库,不如给出一个_很简单的_概念证明**为说明目的(仅)**: 

```js
var MyModules = (function Manager() {
	var modules = {};

	function define(name, deps, impl) {
		for (var i=0; i<deps.length; i++) {
			deps[i] = modules[deps[i]];
		}
		modules[name] = impl.apply( impl, deps );
	}

	function get(name) {
		return modules[name];
	}

	return {
		define: define,
		get: get
	};
})();
```

此代码的关键部分是`模块[姓名] =执行申请(实现,依赖). `. 这是调用一个模块的定义包装器函数(传入任何依赖项),并将返回值(模块的API)存储到按名称跟踪的模块的内部列表中. 

下面是我如何用它来定义一些模块: 

```js
MyModules.define( "bar", [], function(){
	function hello(who) {
		return "Let me introduce: " + who;
	}

	return {
		hello: hello
	};
} );

MyModules.define( "foo", ["bar"], function(bar){
	var hungry = "hippo";

	function awesome() {
		console.log( bar.hello( hungry ).toUpperCase() );
	}

	return {
		awesome: awesome
	};
} );

var bar = MyModules.get( "bar" );
var foo = MyModules.get( "foo" );

console.log(
	bar.hello( "hippo" )
); // Let me introduce: hippo

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

"富"和"bar"模块都定义了一个返回公共API的函数. "甚至"接收"bar"实例作为依赖项参数,并可以相应地使用它. 

花一些时间检查这些代码片段,以充分了解闭包用于我们自己的良好目的的能力. 关键的一点是对模块管理者来说没有什么特别的"魔力". 它们实现了上面列出的模块模式的两个特性: 调用函数定义包装器,并将其返回值作为该模块的API. 

换句话说,模块只是模块,即使在它们上面放了一个友好的包装工具. 

### 未来的模块

6添加模块的概念,一流的语法支持. 当加载的模块系统,6将文件作为一个单独的模块. 每个模块都可以导入其他模块或特定API成员,也可以导出自己的公共API成员. 

**注: **基于函数的模块不是静态识别模式(编译器知道的东西),所以在运行时不考虑它们的API语义. 也就是说,实际上可以在运行时修改模块的API(参见前面). `publicapi`讨论). 

相比之下,ES6模块API是静态的(在运行时API不改变). 因为编译器知道_那个_它可以(而且!)在(文件加载和)编译过程中检查对导入模块API的成员的引用. _真的存在_. 如果API引用不存在,编译器在编译时抛出一个"早期"错误,而不是等待传统的动态运行时解析(以及错误,如果有的话). 

ES6模块**不**有一个"内联"格式,它们必须在单独的文件中定义(每个模块一个). 浏览器/引擎有一个默认的"模块加载器"(这是可重写的,但这是远远超出了我们这里的讨论),同时加载一个模块文件时,它的进口. 

考虑: 

**bar.js**

```js
function hello(who) {
	return "Let me introduce: " + who;
}

export hello;
```

**foo.js**

```js
// import only `hello()` from the "bar" module
import hello from "bar";

var hungry = "hippo";

function awesome() {
	console.log(
		hello( hungry ).toUpperCase()
	);
}

export awesome;
```

```js
// import the entire "foo" and "bar" modules
module foo from "foo";
module bar from "bar";

console.log(
	bar.hello( "rhino" )
); // Let me introduce: rhino

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

**注: **单独的文件**"js"**和**"酒吧"**将需要创建,前面两个片段所示的内容分别为. 然后,您的程序将加载/导入. 

`进口`从模块的API导入一个或多个成员到当前范围,每个成员绑定到一个变量(`你好`在我们的情况下). `模块`将整个模块API导入绑定变量(`Foo`,`酒吧`在我们的情况下). `出口`将标识符(变量ㄡ函数)导出到当前模块的公共API中. 在必要时,这些操作符可以在模块的定义中多次使用. 

里面的内容_模块文件_被视为封闭在范围闭包中,就像前面看到的函数闭包模块一样. 

## 回顾(TL;DR)

封闭似乎是一个不受启发的世界,就像一个神秘的世界,在JavaScript里面,只有少数勇敢的灵魂能够触及. 但实际上它只是一个标准,显而易见我们如何写代码的词法范围内的环境,其中功能价值,可以通过在将. 

**闭包是指函数在其词法范围之外调用时可以记住并访问它的词法范围. **

如果我们不小心识别它们,以及它们是如何工作的,闭包可能会使我们陷入循环. 但它们也是一个非常强大的工具,可以启用如下模式_模块_以各种形式. 

模块需要两个关键特性: (1)调用外部包装函数,以创建封闭范围2)包装函数的返回值必须包括对至少一个内部函数的引用,该内部函数在包装器的私有内部范围内关闭. 

现在我们可以看到闭包在我们现有的代码周围,我们有能力识别并利用它们来实现我们自己的利益!
