
# 你不知道JS：范围和闭包

# 第4章吊装

到目前为止，您应该对范围的概念相当满意，以及如何根据不同的范围和声明如何将变量连接到不同级别的范围。函数范围和块作用域在这方面都遵循相同的规则：在范围内声明的任何变量都附加到该范围。

但是有一个微妙的细节，说明了范围作用如何与出现在范围内的不同位置的声明一起工作，这个细节是我们在这里将要检查的。

## 鸡肉还是鸡蛋？

有一种诱惑，认为在程序执行时，JavaScript程序中看到的所有代码都是逐行、自上而下地依次解释的。虽然这基本上是真的，但这种假设的一部分可能会导致对程序的不正确的考虑。

考虑这个代码：

```js
a = 2;

var a;

console.log( a );
```

你希望印刷的内容是什么？`控制台（…）`声明？

许多开发人员预计`未定义`，自`VaR`声明之后`= 2`假设变量被重新定义，从而分配默认值，这似乎很自然。`未定义`。但是，输出将是`二`。

考虑另一段代码：

```js
console.log( a );

var a = 2;
```

您可能会想假设，因为前面的代码片段显示了一些低于自顶向下的行为，可能在这个片段中，`二`也将印刷。其他人可能认为`一`变量在声明之前使用，这必须导致`引用错误`被抛。

不幸的是，两个猜测都是错误的。`未定义`是输出吗？。

**那么，这里发生了什么事？**看来我们有鸡和蛋的问题。第一个，声明（鸡蛋），还是赋值（鸡）？

## 编译器再次罢工。

要回答这个问题，我们需要参考第1章和我们对编译器的讨论。记得，_发动机_实际上，在编译JavaScript代码之前，它会编译它。编译阶段的一部分是查找并将所有声明与其适当范围关联起来。第2章告诉我们，这是词汇范围的核心。

因此，最好的方法是，在执行代码的任何部分之前，首先对所有声明（变量和函数）进行处理。

当你看到`var a＝2；`你可能认为这是一种说法。但是JavaScript实际上认为它是两个语句：`VaR；`和`a = 2；`。第一个语句，即声明，在编译阶段处理。第二个语句，赋值，是左边的。**在的地方**执行阶段。

我们的第一段代码应该被认为是这样处理的：

```js
var a;
```

```js
a = 2;

console.log( a );
```

第一部分是编译，第二部分是执行。

类似地，我们的第二个代码片段实际上被处理为：

```js
var a;
```

```js
console.log( a );

a = 2;
```

所以，一个思维方式，这种比喻，这个过程，是变量和函数的声明是“感动”，从那里出现的流代码的代码顶部。这就产生了“吊装”的名称。

换言之，**蛋（宣言）出现在鸡（分配）之前。**。

**注：**只有声明本身被挂起，而任何赋值或其他可执行逻辑都被保留。_在的地方_。如果要重新编排代码的可执行逻辑，可能会造成严重破坏。

```js
foo();

function foo() {
	console.log( a ); // undefined

	var a = 2;
}
```

功能`Foo`声明（在本例中）_包括_它作为实际函数的隐含值被提升，以便第一行上的调用能够执行。

重要的是要注意，吊装是**每个范围**。因此，我们前面的代码段简化了，因为它们只包含全局范围，所以`富（…）`我们现在审查的功能本身展示了`VaR`被吊到山顶`富（…）`（显然，不在程序的顶部）。所以这个程序也许可以更准确地解释如下：

```js
function foo() {
	var a;

	console.log( a ); // undefined

	a = 2;
}

foo();
```

函数声明被提升，正如我们刚才看到的。但是函数表达式不是。

```js
foo(); // not ReferenceError, but TypeError!

var foo = function bar() {
	// ...
};
```

变量标识符`Foo`悬挂并附于本程序的封闭范围（全球），因此`foo()`不作为一个失败`引用错误`。但`Foo`还没有值（如果它是一个真正的函数声明而不是表达式）。所以，`foo()`正在尝试调用`未定义`值，这是`TypeError`非法操作。

还记得，尽管它是一个命名函数表达式，但在封闭范围内名称标识符是不可用的：

```js
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
	// ...
};
```

这段代码更准确地解释（提升）为：

```js
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
	var bar = ...self...
	// ...
}
```

## 功能第一

函数声明和变量声明都会被挂起。而是一个微妙的细节_可以_在带有多个“重复”声明的代码中出现，首先是函数被提升，然后是变量。

考虑：

```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};
```

`一`是印刷而不是`二`！此代码段由_发动机_作为：

```js
function foo() {
	console.log( 1 );
}

foo(); // 1

foo = function() {
	console.log( 2 );
};
```

注意：`变量Foo`是重复（因此忽略）声明，即使它出现在`功能foo()…`声明，因为函数声明在正常VA之前被挂起。

多重/重复`VaR`声明实际上被忽略，随后的函数声明_做_超越以前的。

```js
foo(); // 3

function foo() {
	console.log( 1 );
}

var foo = function() {
	console.log( 2 );
};

function foo() {
	console.log( 3 );
}
```

虽然这一切听起来都像是有趣的学术琐事，但它强调了在同一范围内重复定义是一个非常糟糕的想法，并且常常导致混淆的结果。

在正常块中出现的函数声明通常提升到封闭的范围，而不是像这个代码所隐含的条件：

```js
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```

但是，重要的是要注意，这种行为是不可靠的，并且在将来的JavaScript版本中会发生变化，因此最好避免在块中声明函数。

## 回顾（TL；DR）

我们可以试探一下`var a＝2；`作为一个声明，但JavaScript_发动机_不是那样看的。它看到`VaR`和`= 2`作为两个单独的语句，第一个是编译器阶段任务，第二个是执行阶段任务。

这导致的是，在范围内的所有声明，不管它们出现在哪里，都是经过处理的。_第一_在代码本身执行之前。您可以将此声明视为声明（变量和函数）被“移动”到它们各自的作用域的顶部，我们称之为“提升”。

声明本身是被提升的，但是赋值，甚至函数表达式的赋值，都是_不_悬挂。

注意重复声明，特别是在正常var声明和函数声明之间混合——如果您这样做的话，危险就要来了！
