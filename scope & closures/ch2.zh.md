
# 你不知道JS: 范围和闭包

# 第2章: Lexical Scope

在第1章中,我们将"范围ℽ定义为一组规则,用于管理_发动机_可以通过它的标识符名称查找变量,并在当前中查找它_范围_或在任何一个_嵌套作用域_它包含在ㄢ

关于范围工作的主要模型有两种ㄢ其中第一个是目前最常用的编程语言ㄢ这就是所谓的**词法范围**我们将深入研究它ㄢ另一种模型仍然被一些语言使用(例如Perl脚本,一些模式,等等)ㄢ**动态范围**ㄢ

动态范围包含在附录A中,我在这里提到它只是为了与词法范围进行对比,这是JavaScript使用的范围模型ㄢ

## Lex的时间

正如我们在1章讨论,一个标准的语言编译器的第一个传统的阶段称为词法分析(又名,标记)ㄢ如果你还记得,在词法分析过程检查源程序的字符串字符分配语义标记由于一些状态解析ㄢ

正是这个概念为理解词汇范围和名称从何而来提供了基础ㄢ

定义有点圆,词法范围的范围,是在词法分析的时间定义ㄢ换句话说,词法范围是基于变量和块范围撰写,你在写的时候,因而是(主要)由当时的词法分析器的过程代码设置在石头上ㄢ

**注: **我们将看到一点点有作弊的词法范围的一些方法,从而修改后的lexer必须经过,但这些都是皱眉头ㄢ将词汇范围视为事实上的词汇,因而完全是作者的时间,这被认为是最佳实践ㄢ

让我们来考虑这个代码块: 

```js
function foo(a) {

	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}

	bar(b * 3);
}

foo( 2 ); // 2 4 12
```

此代码示例中包含三个嵌套范围ㄢ将这些范围看作是彼此之间的气泡可能是有帮助的ㄢ

<img src="fig2.png" width="500">

**泡1**包含全局范围,其中只有一个标识符: `Foo`ㄢ

**泡2**涵盖范围`Foo`,其中包括三个标识符: `一`,`酒吧`和`B`ㄢ

**泡3**涵盖范围`酒吧`它只包含一个标识符: `C`ㄢ

范围气泡是由范围写的块定义的,其中一个嵌套在另一个内部,在下一章中,我们将讨论不同的作用域,但是现在,我们假设每个函数都会创建一个新的范围泡沫ㄢ

泡沫`酒吧`完全包含在泡沫中`Foo`因为(而且只是因为)我们选择函数的地方`酒吧`ㄢ

注意,这些嵌套的泡是严格嵌套的ㄢ我们不是在谈论维恩图,气泡可以跨边界ㄢ换句话说,对于一些函数来说,没有气泡可以同时存在(部分地)在两个外部范围的气泡中,就像没有任何功能可以部分地位于两个父函数中的每一个ㄢ

### 查找

这些范围气泡的结构和相对位置完全解释了_发动机_所有需要查找标识符的地方ㄢ

在上面的代码段中,_发动机_执行`控制台(ⅆ)`语句并查找三个引用变量`一`,`B`,和`C`ㄢ首先从最里面的范围泡沫开始,`酒吧(ⅆ)`功能ㄢ它找不到`一`在那里,它上升到一个水平,到下一个最近的范围泡沫,范围`富(ⅆ)`ㄢ它发现`一`在那里,所以它使用`一`ㄢ同样的东西`B`ㄢ但`C`它确实在里面找到`酒吧(ⅆ)`ㄢ

曾经有过`C`无论是在`酒吧(ⅆ)`和内部`富(ⅆ)`,的`控制台(ⅆ)`语句将发现并使用`酒吧(ⅆ)`永远也进不去`富(ⅆ)`ㄢ

**查找范围一旦找到第一个匹配就停止ㄢ**ㄢ相同的标识符名称可以在嵌套范围的多个层中指定,称为"阴影ℽ(内部标识符"阴影ℽ(外部标识符))ㄢ不管阴影如何,范围查找总是在当前执行的最里面的范围内开始,并向外/向上工作直到第一个匹配,然后停止ㄢ

**注: **全局变量也是全局对象的自动属性(`窗口`在浏览器等),所以它_是_可以直接引用全局变量,而不是直接引用它的词汇名称,而是间接地作为全局对象的属性引用ㄢ

```js
window.a
```

这种技术允许访问一个全局变量,否则由于它被阴影而无法访问ㄢ但是,不能访问非全局阴影变量ㄢ

不管_哪里_函数从ㄡ甚至调用ㄢ_怎样_它被调用,它的词法范围是**只有**由函数声明的位置定义的ㄢ

词法范围查找过程_只有_应用于一流标识符,如`一`,`B`,和`C`ㄢ如果你提到`foo.bar.baz`在一段代码中,词法范围查找将应用于查找`Foo`标识符,但一旦找到该变量,对象属性访问r`酒吧`和`巴兹`属性分别ㄢ

## 作弊的词汇

如果词法范围只定义在声明函数的地方,这完全是一个作者的时间决定,那么在运行时如何可能有一种方法来"修改ℽ(又名,欺骗)词法范围呢?

JavaScript有两个这样的机制ㄢ这两个问题在广大社会中同样被视为在代码中使用的坏习惯ㄢ但反对他们的典型论点往往缺少最重要的一点: **作弊的词汇范围导致较差的性能ㄢ**

在解释性能问题之前,让我们看看这两种机制是如何工作的ㄢ

### `eval`

这个`eval(..)`JavaScript中的函数以字符串作为参数,并将字符串的内容视为程序中的实际编写的代码ㄢ换句话说,您可以以编程方式生成您编写的代码内部的代码,并运行生成的代码,就像它在编写时一样ㄢ

评价`eval(..)`(双关语意思是)在这一点上,应该清楚`eval(..)`允许您通过欺骗和假装作者时间(又名,词汇)代码一直在那里修改词法范围环境ㄢ

在后续代码行之后`eval(..)`已执行,_发动机_不会"知道ℽ或"关心ℽ,对前面的代码进行动态解释,从而修改词法范围环境ㄢ这个_发动机_只会简单地执行它的词法范围查找ㄢ

考虑下面的代码: 

```js
function foo(str, a) {
	eval( str ); // cheating!
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1 3
```

字符串`"var b=3;ℽ`被对待,在`eval(..)`调用,作为代码一直在那里ㄢ因为代码恰好声明一个新变量`B`它修改了现有的词法范围ㄢ`富(ⅆ)`ㄢ事实上,如上所述,这个代码实际上创建变量ㄢ`B`里面的`富(ⅆ)`那阴影`B`这是在外部(全局)范围内声明的ㄢ

当`控制台(ⅆ)`调用发生时,它发现两个`一`和`B`在范围内`富(ⅆ)`却永远找不到外面`B`ㄢ因此,我们打印出"1 3ℽ而不是"1 2ℽ,通常情况下是这样的ㄢ

**注: **在这个例子中,为了简单起见,我们传递的"代码ℽ字符串是一个固定的文字ㄢ但它可以很容易地通过在程序逻辑基础上添加字符来编程地创建ㄢ`eval(..)`通常用于执行动态创建的代码,动态地从字符串字面上动态地评估静态代码不会给直接编写代码带来真正的好处ㄢ

默认情况下,如果一段代码`eval(..)`执行包含一个或多个声明(变量或函数),此操作修改现有的词法范围,其中`eval(..)`驻留ㄢ技术上,`eval(..)`可以通过各种技巧"间接ℽ调用(超出我们在这里的讨论),从而导致它在全局范围的上下文中执行,从而修改它ㄢ但无论哪种情况,`eval(..)`可以在运行时修改作者时间词法范围ㄢ

**注: ** `eval(..)`在严格模式下使用时,程序在自己的词法范围内运行,这意味着在`()`不要实际修改封闭范围ㄢ

```js
function foo(str) {
   "use strict";
   eval( str );
   console.log( a ); // ReferenceError: a is not defined
}

foo( "var a = 2" );
```

JavaScript还有其他设施,其效果非常相似ㄢ`eval(..)`ㄢ`setTimeout(..)`和`setInterval(..)` _可以_为他们各自的第一个参数取一个字符串,其内容是`eval`评价作为一个动态生成的函数的代码ㄢ这是旧的,传统的行为和早已过时的ㄢ不要这样做!

这个`新功能(..)`函数构造函数类似地在其中获取一系列代码ㄢ**最后的**将参数转换为动态生成的函数(第一个参数,如果有的话,是新函数的命名参数)ㄢ这个函数构造函数语法稍微比`eval(..)`但在代码中还是应该避免的ㄢ

动态生成的代码在你的程序中使用的情况下是非常难得的,作为性能降级几乎没有价值的能力ㄢ

### `具有`

其他的皱眉头(现在不赞成!)在JavaScript,欺骗词汇范围的特征是`具有`关键词ㄢ有多种有效的方法`具有`可以解释,但我会选择从它如何影响和影响词法范围的角度来解释它ㄢ

`具有`通常被解释为用于对对象进行多个属性引用的短指针ㄢ_没有_每次重复对象引用本身ㄢ

例如:

```js
var obj = {
	a: 1,
	b: 2,
	c: 3
};

// more "tedious" to repeat "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;

// "easier" short-hand
with (obj) {
	a = 3;
	b = 4;
	c = 5;
}
```

然而,这里有更多的东西,不仅仅是一个方便的对象属性访问的短手ㄢ考虑: 

```js
function foo(obj) {
	with (obj) {
		a = 2;
	}
}

var o1 = {
	a: 3
};

var o2 = {
	b: 3
};

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2 -- Oops, leaked global!
```

在这个代码示例中,两个对象`O1`和`O2`创建ㄢ其中有一个`一`属性,而另一个不ㄢ这个`富(ⅆ)`函数获取对象引用ㄢ`obj`作为论据,并呼吁`与(obj){ ..}`关于参考ㄢ里面的`具有`块,我们使对变量看起来是正常的词汇引用ㄢ`一`事实上,在一个LHS参考(见1章),分配给它的价值`二`ㄢ

当我们通过`O1`,的`= 2`赋值查找属性`O1的ㄢ`并赋予它价值`二`,如后面所反映的`控制台日志(O1的ㄢ)`声明ㄢ然而,当我们通过`O2`因为它没有一个`一`财产,未创建此类财产,以及`一个O2ㄢ`残余`未定义`ㄢ

但是我们注意到一个特殊的副作用,即一个全局变量ㄢ`一`是由`= 2`分配ㄢ怎么会这样呢?

这个`具有`语句获取一个对象,其中一个对象具有零个或多个属性,并且**将对象视为_它_是一个完全独立的词法范围ㄢ**因此,与对象的属性被视为词汇定义的标识符在"范围ℽㄢ

**注: **即使一个`具有`块处理对象,如词法范围,普通的ㄢ`VaR`宣言里面,`具有`块不限制,`具有`块,而不是包含函数作用域ㄢ

而`eval(..)`函数可以修改现有的词法范围,如果它包含一系列具有一个或多个声明的代码,则`具有`语句实际上创建一个**全新的词法范围**从稀薄的空气中,从你传递给它的物体ㄢ

以这种方式理解,由"声明ℽ所声明的"范围ℽ`具有`我们通过时的陈述`O1`是`O1`并且"范围ℽ中有一个"标识符ℽ,它对应于`O1的ㄢ`财产ㄢ但当我们使用`O2`作为"范围ℽ,它没有这样的`一`"标识ℽ,所以该标识符查找正常的规则(见1章)发生ㄢ

无论是"范围ℽ`O2`,也没有范围`富(ⅆ)`甚至全球范围都没有`一`要找到的标识符,所以`= 2`执行时,它会自动创建全局创建(因为我们处于非严格模式)ㄢ

这是一种奇怪的想法ㄢ`具有`在运行时,将对象及其属性转换为"范围ℽ_具有_"标识符ℽㄢ但这是我能给出的最清楚的解释ㄢ

**注: **除了是一个坏主意使用,两者`eval(..)`和`具有`受严格模式影响(限制)ㄢ`具有`是完全不允许的,而各种形式的间接的或不安全的`eval(..)`不允许在保留核心功能ㄢ

### 性能

两`eval(..)`和`具有`通过在运行时修改或创建新的词法范围来欺骗其他作者定义的词法范围ㄢ

那么,有什么大不了的,你问?如果它们提供更高级的功能和编码灵活性,不是吗?_好的_特征?**不.**

JavaScript_发动机_它在编译阶段执行许多性能优化ㄢ这些归结到能够基本上是静态分析代码作为它的词汇,和预先确定的所有变量和函数的声明,因此它需要解决在执行过程中努力减少标识符ㄢ

但如果_发动机_找到一个`eval(..)`或`具有`在代码中,它本质上必须_假定_它的所有意识的标识符的位置可能无效,因为它不知道什么代码你可以进行词法分析时通过`eval(..)`要修改词法范围,或者您可以传递给对象的内容`具有`创建要查阅的新词法范围ㄢ

换言之,在悲观的意义上,大多数人都在优化它ㄢ_将_如果是毫无意义的`eval(..)`或`具有`是存在的,所以它根本不执行优化ㄢ_完全_ㄢ

你的代码几乎肯定会因为你包含一个事实而运行得很慢ㄢ`eval(..)`或`具有`代码中的任何地方ㄢ无论多么聪明_发动机_可能是试图限制这些悲观假设的副作用,**无法绕过这样一个事实: 没有优化,代码运行得越慢ㄢ**

## 回顾(TL;DR)

词法范围意味着作用域由作者声明函数的时间决定来定义ㄢ词法分析阶段的编制基本上是能够知道如何与所有标识符声明,从而预测他们将如何看在执行过程中ㄢ

JavaScript中的两种机制可以"欺骗ℽ词法范围: `eval(..)`和`具有`ㄢ前者可以通过评估一个有一个或多个声明的代码串来修改现有的词法范围(在运行时)ㄢ后者实质上是通过处理对象引用创建一个全新的词法范围(再次在运行时)ㄢ_作为_"范围ℽ,对象的属性为作用域标识符ㄢ

这些机制的缺点是它击败了_发动机_在范围查找时执行编译时优化的能力,因为_发动机_有悲观地认为,这样的优化将是无效的ㄢ代码_将_由于使用这两个特性而运行得比较慢ㄢ**不要使用它们ㄢ**
