
# 你不知道JS: 范围和闭包

# 第3章: 功能与块作用域

正如我们在第2章中所探讨的,作用域由一系列"气泡ℽ组成,每个气泡充当容器或桶,其中标识符(变量ㄡ函数)被声明ㄢ这些气泡彼此巧妙地嵌套在一起,这种嵌套是在作者时间定义的ㄢ

但是到底是什么造成了新的泡沫呢?它只是功能吗?JavaScript中的其他结构可以创建范围的气泡吗?

## 从功能范围

对这些问题最常见的回答是JavaScript具有基于函数的范围ㄢ也就是说,您声明的每个函数都为自己创建了一个气泡,但没有其他结构创建自己的范围气泡ㄢ正如我们将在一点点看到,这是不太真实的ㄢ

首先,让我们探究函数作用域及其含义ㄢ

考虑这个代码: 

```js
function foo(a) {
	var b = 2;

	// some code

	function bar() {
		// ...
	}

	// more code

	var c = 3;
}
```

在这个片段中,作用域气泡`富(ⅆ)`包括标识符`一`,`B`,`C`和`酒吧`ㄢ**没关系** _哪里_在声明出现的范围内,变量或函数属于包含范围气泡,不管ㄢ我们将探讨如何精确_那个_在下一章中工作ㄢ

`酒吧(ⅆ)`有自己的范围泡沫ㄢ全局范围也是如此,只有一个标识符附加在它上: `Foo`ㄢ

因为`一`,`B`,`C`,和`酒吧`都属于范围泡沫`富(ⅆ)`它们在外面是不可访问的ㄢ`富(ⅆ)`ㄢ也就是说,下面的代码将导致`引用错误`错误,因为标识符对全局范围不可用: 

```js
bar(); // fails

console.log( a, b, c ); // all 3 fail
```

但是,所有这些标识符(`一`,`B`,`C`,`Foo`,和`酒吧`)可_里面_属于`富(ⅆ)`而且确实也在里面`酒吧(ⅆ)`(假设内部没有阴影标识符声明)`酒吧(ⅆ)`)ㄢ

函数作用域鼓励所有变量都属于函数,并且可以在整个函数中使用和重用(甚至可以访问嵌套作用域)ㄢ这种设计方法非常有用,而且可以充分利用JavaScript变量的"动态ℽ特性,根据需要使用不同类型的值ㄢ

另一方面,如果不采取谨慎措施,整个范围内存在的变量可能会导致一些意想不到的陷阱ㄢ

## 藏在平原范围内

函数的传统方法是声明一个函数,然后在它里面添加代码ㄢ但是反向思维同样强大和有用: 取任意一段代码,并在它周围包装一个函数声明,这实际上"隐藏ℽ代码ㄢ

实际的结果是在问题代码周围创建一个范围气泡,这意味着该代码中的任何声明(变量或函数)现在都绑定到新包装函数的范围,而不是以前封闭的范围ㄢ换句话说,您可以将变量和函数隐藏在函数的范围内,从而"隐藏ℽ它们ㄢ

为什么隐藏变量和函数是一个有用的技术?

激发基于范围的隐藏的原因有很多种ㄢ它们往往来自软件设计原则"最小特权原则ℽㄢ[^注leastprivilege-]有时也称为"最小权威ℽ或"最少曝光ℽㄢ这一原则指出,在软件设计中,如模块/对象的API,您应该只暴露最低限度的必要性,并"隐藏ℽ所有其他东西ㄢ

这个原则扩展到选择包含变量和函数的范围ㄢ如果所有变量和函数都在全局范围内,那么它们当然可以访问任何嵌套范围ㄢ但是这违反了"最少ⅆⅆℽ原则,因为你可能会暴露许多你应该保持私有的变量或函数,因为正确使用代码会阻碍访问这些变量/函数ㄢ

例如:

```js
function doSomething(a) {
	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

function doSomethingElse(a) {
	return a - 1;
}

var b;

doSomething( 2 ); // 15
```

在这个片段中,`B`变量和`dosomethingelse(..)`功能很可能是"私人ℽ的细节`做(..)`做它的工作ㄢ给封闭范围"访问ℽ`B`和`dosomethingelse(..)`不仅是不必要的,而且可能是"危险的ℽ,因为它们可能被有意或无意地使用,这可能违反了`做(..)`ㄢ

更恰当的设计将这些私人细节隐藏在`做(..)`,例如: 

```js
function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}

	var b;

	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

doSomething( 2 ); // 15
```

现在,`B`和`dosomethingelse(..)`不受任何外来影响,而只能通过`做(..)`ㄢ功能和最终结果没有受到影响,但设计保持私有细节,这通常被认为是更好的软件ㄢ

### 防撞

在范围内"隐藏ℽ变量和函数的另一个好处是避免两个不同标识符之间的意外冲突,它们具有相同的名称,但不同的用途是不同的ㄢ碰撞的结果往往在意外重写值ㄢ

例如:

```js
function foo() {
	function bar(a) {
		i = 3; // changing the `i` in the enclosing scope's for-loop
		console.log( a + i );
	}

	for (var i=0; i<10; i++) {
		bar( i * 2 ); // oops, infinite loop ahead!
	}
}

foo();
```

这个`我= 3`分配在`酒吧(ⅆ)`覆盖,没想到,这`我`那是在`富(ⅆ)`在for循环ㄢ在这种情况下,它会`我`设置为一个固定值`三`那将永远存在`< 10`ㄢ

内部的分配`酒吧(ⅆ)`需要声明要使用的本地变量,而不管选择的标识符名称是什么ㄢ`var I=3;`将解决这个问题(并创建前面提到的"阴影变量ℽ声明)`我`)ㄢ一个_额外的_不是选项,而是完全选择另一个标识符名称,例如`var j=3;`ㄢ但是,您的软件设计可能会自然而然地调用相同的标识符名称,因此使用范围来隐藏"内部声明ℽ是您在这种情况下的最佳选择ㄢ

#### 全局名称空间

在全局范围内出现了一个特别强的(可能的)变量冲突示例ㄢ加载到程序中的多个库如果不正确隐藏它们的内部/私有函数和变量,就很容易相互冲突ㄢ

这样的库通常会在全局范围内创建一个具有惟一名称的变量声明,通常是一个对象ㄢ然后将该对象作为一个"命名空间ℽ的图书馆,那里的所有功能的特定风险为该对象的属性(命名空间),而不是作为顶层的词法作用域标识符本身ㄢ

例如:

```js
var MyReallyCoolLibrary = {
	awesome: "stuff",
	doSomething: function() {
		// ...
	},
	doAnotherThing: function() {
		// ...
	}
};
```

#### 模块管理

避免冲突的另一种选择是使用各种依赖管理器的更现代的"模块ℽ方法ㄢ使用这些工具,任何库都不会向全局范围添加任何标识符,而是需要通过依赖管理器的各种机制将它们的标识符显式导入到另一个特定的范围ㄢ

应该说,这些工具不具有"魔力ℽ的功能,免除词法作用域规则ㄢ他们只是使用范围的解释来执行,没有注入任何共享范围标识符的规则,是不是放在私人ㄡ非碰撞敏感的范围,以防止任何意外范围碰撞ㄢ

因此,如果您选择的话,可以在防御上进行编码,并取得与依赖管理器相同的结果,而无需实际使用它们ㄢ有关模块模式的更多信息,请参见第5章ㄢ

## 功能范围

我们已经看到,我们可以获取任何代码片段,并在它周围包装一个函数,并有效地从函数范围内的外部范围中"隐藏ℽ任何封闭变量或函数声明ㄢ

例如:

```js
var a = 2;

function foo() { // <-- insert this

	var a = 3;
	console.log( a ); // 3

} // <-- and this
foo(); // <-- and this

console.log( a ); // 2
```

虽然这种技术"有效ℽ,但并不一定非常理想ㄢ它引入了一些问题ㄢ第一个问题是我们必须声明一个命名函数ㄢ`foo()`,这意味着标识符名称ㄢ`Foo`本身"污染ℽ封闭的范围(在这种情况下是全局的)ㄢ我们还必须显式地调用函数的名称(`foo()`以便包装的代码实际执行ㄢ

如果函数不需要名称(或者更确切地说,名称不会污染包围范围),如果函数可以自动执行,那就更理想了ㄢ

幸运的是,JavaScript为这两个问题提供了解决方案ㄢ

```js
var a = 2;

(function foo(){ // <-- insert this

	var a = 3;
	console.log( a ); // 3

})(); // <-- and this

console.log( a ); // 2
```

让我们把这里发生的事弄清楚ㄢ

首先,注意包装函数语句以`(功能ⅆ`与公正相反`功能ⅆ`ㄢ虽然这看起来像是一个小细节,但它实际上是一个重大变化ㄢ函数不是将函数作为标准声明来处理,而是将函数视为函数表达式ㄢ

**注: **区分声明和表达式的最简单的方法是语句中"函数ℽ一词的位置(不只是一行,而是一个明确的语句)ㄢ如果"函数ℽ是语句中的第一件事,那么它就是函数声明ㄢ否则,它是函数表达式ㄢ

我们在函数声明和函数表达式之间可以观察到的关键区别是它的名字被绑定为标识符的位置ㄢ

比较前两段ㄢ在第一个片段中,这个名字`Foo`绑定在封闭范围内,我们直接调用它`foo()`ㄢ在第二个片段中,这个名字`Foo`不在封闭作用域中绑定,而是仅在其自身函数内绑定ㄢ

换言之,`(功能foo() { ..})`表达式表示标识符ㄢ`Foo`被发现_只有_在范围内`..`指示,而不是在外部范围内ㄢ隐藏的名字`Foo`内部意味着它不污染不必要的包围范围ㄢ

### 匿名与命名

您可能最熟悉函数表达式作为回调参数,例如: 

```js
setTimeout( function(){
	console.log("I waited 1 second!");
}, 1000 );
```

这称为"匿名函数表达式ℽ,因为`function()ⅆ`上面没有名称标识符ㄢ函数表达式可以是匿名的,但函数声明不能省略名称ℴℴ这将是非法的js语法ㄢ

匿名函数表达式是快速且容易输入的,许多库和工具都倾向于鼓励这种惯用的代码风格ㄢ然而,他们有几个考虑因素: 

1.  匿名函数在堆栈跟踪中没有可用的名称,这会使调试变得更加困难ㄢ

2.  没有名字,如果**过时的** `arguments.callee`不幸的是需要参考ㄢ另一个例子,需要自我参照是当一个事件处理函数要解放自己后的火灾ㄢ

3.  匿名函数省略了提供更多可读/可理解代码的名称ㄢ描述性名称有助于对所涉代码进行自我文档化ㄢ

**内联函数表达式**功能强大且有用ℴℴ匿名与命名的问题并不能减损这一点ㄢ你的函数表达式,比较有效地解决了所有这些缺点提供了一个名字,但没有有形的缺点ㄢ最好的做法是总是命名函数表达式: 

```js
setTimeout( function timeoutHandler(){ // <-- Look, I have a name!
	console.log( "I waited 1 second!" );
}, 1000 );
```

### 立即调用函数表达式

```js
var a = 2;

(function foo(){

	var a = 3;
	console.log( a ); // 3

})();

console.log( a ); // 2
```

既然我们把它封装成一个表达式,我们就有了一个表达式的函数ㄢ`()`对,我们可以通过添加另一个函数来执行该函数`()`最后,像`(功能foo() { ..})`ㄢ第一封`()`配对使函数成为表达式,第二个函数`()`执行函数ㄢ

这种模式很常见,几年前,社区就这个问题达成了协议: **生活**,代表**我**立刻**我**nvoked**F**功能**E**表达ㄢ

当然,生活是不需要名字,一定--生活中最常见的形式是使用一个匿名函数表达式ㄢ虽然肯定不常见,命名一个生活有上述的好处在匿名函数的表达式,所以采用一个好的实践ㄢ

```js
var a = 2;

(function IIFE(){

	var a = 3;
	console.log( a ); // 3

})();

console.log( a ); // 2
```

在传统的生活形式略有变化,其中一些喜欢: `(function() { ..}()`ㄢ仔细看看差异ㄢ在第一种形式中,函数表达式被包装在`()`然后调用`()`在它之后的右边ㄢ在第二种形式中,调用`()`一对被移到外面的内侧ㄢ`()`包装对ㄢ

这两种形式在功能上是相同的ㄢ**这纯粹是你喜欢的文体选择ㄢ**

在生活的这是相当普遍的另一个变化是使用的事实,他们是,事实上,只是函数调用,并通过参数(S)ㄢ

例如:

```js
var a = 2;

(function IIFE( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

})( window );

console.log( a ); // 2
```

我们通过`窗口`对象引用,但是我们命名参数`全球的`因此,我们对全局和非全局引用有明确的风格划分ㄢ当然,您可以从所需的封闭范围传递任何内容,并且可以将参数命名为适合您的任何参数ㄢ这主要只是文体上的选择ㄢ

这种模式的另一个应用程序解决了(小的利基)关注的默认值ㄢ`未定义`标识符的值可能被错误地覆盖,导致意外的结果ㄢ通过命名参数`未定义`但不能为该参数传递任何值,我们可以保证`未定义`标识符实际上是代码块中未定义的值: 

```js
undefined = true; // setting a land-mine for other code! avoid!

(function IIFE( undefined ){

	var a;
	if (a === undefined) {
		console.log( "Undefined is safe here!" );
	}

})();
```

的生活还有一个变化颠倒了事物的秩序,在执行函数是二,_之后_要传递给它的调用和参数ㄢ这种模式是用于UMD(通用模块定义)项目ㄢ有些人觉得理解起来稍微干净一些,尽管稍微有点罗嗦ㄢ

```js
var a = 2;

(function IIFE( def ){
	def( window );
})(function def( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

});
```

这个`DEF`函数表达式在片段的后半部分中定义,然后作为参数传递(也称为`DEF`)的`生活`在代码片段的前半部分定义的函数ㄢ最后,参数`DEF`(函数)被调用ㄡ传递ㄢ`窗口`在为`全球的`参数.

## 块范围

虽然函数是范围最常见的单位,当然也是大多数JS在循环中的最广泛的设计方法,但其他范围的单元是可能的,而这些其他范围单元的使用可能导致更优秀ㄡ更清洁的代码维护ㄢ

除了JavaScript之外,许多语言支持块作用域,因此来自这些语言的开发人员习惯于这种思维方式,而那些主要只在JavaScript工作的人可能会觉得这个概念稍微有些陌生ㄢ

但即使你从未写过一行代码块作用域的时尚,你仍然可能熟悉JavaScript这极为常见的成语: 

```js
for (var i=0; i<10; i++) {
	console.log( i );
}
```

我们声明变量`我`直接在for循环头,很可能是因为我们_意图_是使用`我`仅在for循环的上下文中,本质上忽略了变量实际将自身范围扩展到封闭作用域(函数或全局)的事实ㄢ

这是块作用域是所有关于ㄢ尽可能地尽可能地将变量声明为要使用的变量ㄢ另一个例子: 

```js
var foo = true;

if (foo) {
	var bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}
```

我们正在使用`酒吧`仅在if语句上下文中变量,因此它使我们在if块内声明它的意义ㄢ但是,我们声明变量在使用时并不相关ㄢ`VaR`因为它们永远属于封闭范围ㄢ这段基本上是"假ℽ的块范围,对文体的原因,依靠自我实施不小心使用`酒吧`在这个范围的另一个地方ㄢ

块作用域是扩展早期"最小原则ℽ的工具ㄢ~~特权~~曝光ℽ[^注leastprivilege-]从

再次考虑for循环示例: 

```js
for (var i=0; i<10; i++) {
	console.log( i );
}
```

为什么要用函数污染整个函数的作用域?`我`变量只会是(或仅)_应该是_至少用于for循环?

但更重要的是,开发人员可能更愿意_检查_防止意外地重新使用预期目的之外的变量,如在错误的地方使用未知变量时,会发出关于未知变量的错误ㄢ块作用域(如果可能的话)的`我`变会使`我`仅用于for循环,如果`我`在函数的其他地方访问ㄢ这有助于确保变量不再被用于混淆或难以维护的方式ㄢ

但是,令人悲哀的现实是,从表面上看,JavaScript没有用于阻止范围的工具ㄢ

那是,直到你再挖一点ㄢ

### `具有`

我们了解了`具有`在第2章ㄢ虽然它是一个皱眉头建设,它_是_一种(一种)块作用域的例子,因为从对象中创建的作用域只存在于它的生命周期中ㄢ`具有`语句,而不是在封闭范围内ㄢ

### `try/catch`

这是一个_非常_鲜为人知的事实,沙三段指定的JavaScript变量声明在`抓住`条款一`try/catch`是块的范围`抓住`块ㄢ

例如:

```js
try {
	undefined(); // illegal operation to force an exception!
}
catch (err) {
	console.log( err ); // works!
}

console.log( err ); // ReferenceError: `err` not found
```

正如你所看到的,`犯错`只存在于`抓住`子句,并在尝试将其引用到其他地方时抛出错误ㄢ

**注: **而这种行为被指定和几乎所有标准的JS环境真实(也许除了老IE),许多短绒似乎还如果你有两个或更多的抱怨`抓住`同一范围内的每个子句声明具有相同标识符名称的错误变量ㄢ这不是一个重新的定义,由于变量是安全的街区范围,但短绒似乎仍然,烦人,抱怨这个事实ㄢ

为了避免这些不必要的警告,一些开发者将其名下的`抓住`变量`打下良好的基础`,`err2`,等其他开发者将简单地关闭掉毛检查重复的变量名ㄢ

块作用域性质`抓住`这似乎是一个无用的学术事实,但请参阅附录B,了解它可能有多有用ㄢ

### `让`

到目前为止,我们已经看到JavaScript只有一些奇怪的利基行为,从而暴露了块作用域的功能ㄢ如果那是我们所拥有的一切,_这是_很多很多年,那块范围不会对JavaScript开发者非常有用ㄢ

幸运的是,6变化,并介绍了一种新的关键词`让`它坐在一起`VaR`作为声明变量的另一种方式ㄢ

这个`让`关键字将变量声明附加到任何块的范围(通常为`{ ..}`对)它包含在ㄢ换言之,`让`暗中劫持任何块的范围的变量声明ㄢ

```js
var foo = true;

if (foo) {
	let bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}

console.log( bar ); // ReferenceError
```

使用`让`将变量附加到现有块是有些隐式的ㄢ它可以迷惑你,如果你不关注这块变量的范围,并在移动块周围的习惯,包在其他模块等,为您的发展和演变的代码ㄢ

创建块范围明确的块可以解决这些问题,让它更明显,变量连接,不ㄢ通常,显式代码优于隐式或微妙代码ㄢ这种明确的块范围的风格是容易实现的,而且更适合自然与多块范围的其他语言的作品: 

```js
var foo = true;

if (foo) {
	{ // <-- explicit block
		let bar = foo * 2;
		bar = something( bar );
		console.log( bar );
	}
}

console.log( bar ); // ReferenceError
```

我们可以创建任意块`让`简单地包括`{ ..}`语句对任何地方都是有效语法ㄢ在这种情况下,我们做了显式块ㄢ_里面_if语句,这可能更容易作为一个整体块在重构之后移动,而不会影响封闭if语句的位置和语义ㄢ

**注: **另一种表达显式块作用域的方法,参见Appendix B.

在第4章中,我们将讨论提升,它谈到声明是为它们发生的整个范围而存在的ㄢ

但是,声明与`让`将_不_提升到他们所出现的区块的整个范围ㄢ这样的声明将不会显著地"存在ℽ在块直到声明语句ㄢ

```js
{
   console.log( bar ); // ReferenceError!
   let bar = 2;
}
```

#### 垃圾收集

另一个原因是有用的块范围涉及关闭和垃圾收集回收内存ㄢ我们将在这里简要说明,但是闭包机制在第5章中有详细的解释ㄢ

考虑: 

```js
function process(data) {
	// do something interesting
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
```

这个`点击`函数点击处理回调函数_需要_这个`somereallybigdata`变量在所有ㄢ这意味着,理论上说`过程(ⅆ)`运行时,大内存重数据结构可能会被垃圾收集ㄢ然而,很有可能(虽然依赖于实现),js引擎仍然需要保留结构,因为`点击`函数在整个范围上有一个闭包ㄢ

块作用域可以解决这个问题,使它更清晰的引擎,它不需要保持`somereallybigdata`围绕: 

```js
function process(data) {
	// do something interesting
}

// anything declared inside this block can go away after!
{
	let someReallyBigData = { .. };

	process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
```

为本地绑定声明变量的显式块是一个功能强大的工具,您可以添加到您的

#### `让`环

特殊情况下`让`正如我们前面讨论过的ㄢ

```js
for (let i=0; i<10; i++) {
	console.log( i );
}

console.log( i ); // ReferenceError
```

不仅`让`在for循环头中绑定`我`到for循环体,但事实上,它**再把它**每个_迭代_在循环中,确保重新分配它从前循环迭代结束的值ㄢ

这里有另一种方法来说明每次迭代绑定行为的发生: 

```js
{
	let j;
	for (j=0; j<10; j++) {
		let i = j; // re-bound for each iteration!
		console.log( i );
	}
}
```

第5章讨论闭包时,每个迭代绑定有趣的原因将变得清楚ㄢ

因为`让`声明附加到任意块而不是外围作用域(或全球),可以有问题,现有的代码有一个隐藏的依赖作用范围`VaR`声明,并替换`VaR`具有`让`重构代码时可能需要额外的注意ㄢ

考虑: 

```js
var foo = true, baz = 10;

if (foo) {
	var bar = 3;

	if (baz > bar) {
		console.log( baz );
	}

	// ...
}
```

这段代码很容易被重新计算为: 

```js
var foo = true, baz = 10;

if (foo) {
	var bar = 3;

	// ...
}

if (baz > bar) {
	console.log( baz );
}
```

但是,小心当使用块作用域的变量的变化: 

```js
var foo = true, baz = 10;

if (foo) {
	let bar = 3;

	if (baz > bar) { // <-- don't forget `bar` when moving!
		console.log( baz );
	}
}
```

看到另一个附录B(更明确)块范围可提供更容易维护和重构代码,这些场景更稳健的风格ㄢ

### `const`

除了`让`介绍,6`const`,这也造成了一块作用域的变量,但它的值是固定的(常数)ㄢ任何在稍后更改该值的尝试都会导致错误ㄢ

```js
var foo = true;

if (foo) {
	var a = 2;
	const b = 3; // block-scoped to the containing `if`

	a = 3; // just fine!
	b = 4; // error!
}

console.log( a ); // 3
console.log( b ); // ReferenceError!
```

## 回顾(TL;DR)

函数是JavaScript中最常见的作用域单位ㄢ在另一个函数中声明的变量和函数本质上是从任何封闭的"范围ℽ中隐藏的,这是一个好软件的有意设计原则ㄢ

但是函数绝不是范围的惟一单位ㄢ块作用域指的是变量和函数可以属于任意块的概念(一般来说,任何`{ ..}`对代码,而不是只对封闭函数ㄢ

从沙三段,该`try/catch`结构中的块作用域`抓住`条款.

在6,的`让`关键字`VaR`关键字)用于允许任意代码块中的变量声明ㄢ`如果(..){ a=2;}`将声明变量`一`这基本上劫持的范围`如果`的`{ ..}`块和附加在那里ㄢ

虽然有些人似乎相信,块范围不应被视为完全取代`VaR`功能范围ㄢ这两种功能并存,开发人员可以并且应该使用函数范围和块范围技术,分别适用于生成更好ㄡ更可读/可维护的代码ㄢ

[^注leastprivilege-]: [最小特权原则](http://en.wikipedia.org/wiki/Principle_of_least_privilege)
