
# 你不知道JS：范围和闭包

# 附录A：动态范围

在第2章中，我们讨论了“动态范围”作为与“词法范围”模型的对比，这是在JavaScript（实际上是大多数其他语言）中作用域的工作方式。

我们将简要考察动态范围，以锤击对比。但更重要的是，动态范围实际上是另一个机制的近亲。`这`）在JavaScript中，我们在“_对象原型_这本书的书名。

正如我们在第2章中看到的，词法范围是关于_发动机_可以查找变量并在哪里找到它。词法范围的主要特点是，它是在编写代码时在编写时定义的（假设您不使用`（）`或`具有`）。

动态范围似乎意味着，而且有充分的理由，有一个模型可以在运行时动态地确定范围，而不是在作者时间静态地确定。事实上是这样的。让我们通过代码来说明：

```js
function foo() {
	console.log( a ); // 2
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```

词法范围认为RHS参考`一`在里面`foo()`将被解析为全局变量。`一`会产生价值`二`输出。

与此相反，动态范围不涉及声明函数和作用域的位置和范围，而是**他们是从哪里来的**。换句话说，范围链基于调用堆栈，而不是代码中作用域的嵌套。

因此，如果JavaScript具有动态作用域，则`foo()`执行，**从理论上讲**下面的代码将导致`三`作为输出。

```js
function foo() {
	console.log( a ); // 3  (not 2!)
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```

怎么会这样呢？因为当`foo()`无法解析变量引用`一`而不是加紧嵌套（词法）范围链，它走上调用堆栈，找到哪里。`foo()`是_被称为从_。自`foo()`被称为从`bar()`它检查范围内的变量。`bar()`找到一个`一`有价值`三`。

奇怪吗？此刻你可能是这么想的。

但那只是因为你可能只做过（或至少深入考虑）这是词法作用域代码。所以，动态范围是外国。如果你在一个动态作用域的语言只写过代码，看起来自然，和词法范围将是奇数球。

要清楚，JavaScript**事实上，没有动态范围。**。它有词法范围。质朴。但`这`机制有点像动态范围。

关键的对比：**词法范围是写时间，而动态范围（和`这`！）是运行时**。词法范围的关心_函数被声明的地方_但动态范围关心函数的位置。_被称为从_。

最后：`这`关心_如何调用函数_这说明了`这`机制是动态范围的概念。挖掘更多`这`读标题_对象原型_“。
