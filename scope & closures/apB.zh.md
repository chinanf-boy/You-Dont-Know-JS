
# 你不知道JS: 范围和闭包

# 附录B: polyfilling块范围

在第3章中,我们探讨了块的范围. 我们看到,`具有`和`抓住`条款是块范围,存在于JavaScript至少自沙三段介绍两小例子. 

但它的6的介绍`让`最后给出了完整的ㄡ不受约束的能力,我们的代码块的作用域. 有许多令人兴奋的事情,无论在功能和代码上,那块范围将使. 

但是如果我们想在pre-es6环境使用块的范围?

考虑这个代码: 

```js
{
	let a = 2;
	console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

这将在6大工作环境. 但我们能做pre-es6?`抓住`是答案吗?. 

```js
try{throw 2}catch(a){
	console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

哇!那是一些丑陋的,奇怪的代码. 我们看到一个`try/catch`这似乎强行抛出一个错误,但它抛出的"错误"只是一个值. `二`然后,接收它的变量声明在`抓住(a)`条款.头脑: 吹. 

是的,`抓住`条款有块划定范围,这意味着它可以被用来作为一个在pre-es6环境块范围polyfill. 

"但是ⅆⅆ",你说. ⅆⅆ没人想写那样丑陋的代码!"那是真的. 没有人写(有些)由CoffeeScript编译器输出的代码,要么. 这不是重点. 

关键的一点是,工具可以transpile ES6代码在pre-es6环境下工作. 你可以使用块范围写代码,并受益于这样的功能,让一个构建步骤工具照顾生产代码会_工作_当部署. 

这实际上是所有优先迁移路径(咳咳,最)ES6: 使用代码transpiler采取6代码和pre-es6到6过渡期间产生ES5代码兼容. 

## 练习者

谷歌维持一个名为"Traceur"[^注名-],这正是负责transpiling ES6功能pre-es6(主要是ES5,但不是全部!)一般用法. TC39委员会依靠这种工具(和其他人)来测试他们指定特征的语义. 

Traceur是怎么从我们的片段产生的?你猜对了!

```js
{
	try {
		throw undefined;
	} catch (a) {
		a = 2;
		console.log( a );
	}
}

console.log( a );
```

因此,在使用这些工具,我们可以利用块范围无论如果我们瞄准的是6或没有,因为`try/catch`已经(和工作方式)从沙三天. 

## 隐式与显式块

在3章中,我们发现了一些潜在的缺陷代码的可维护性/ refactorability当我们介绍块作用域. 有没有另外一种利用区块范围的方法来减少这种负面影响呢?

考虑这个替代形式`让`称为"让块"或"让语句"(与之前的"让声明")相反. 

```js
let (a = 2) {
	console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

而不是隐式劫持现有的块,让语句创建一个显式块的范围绑定. 不仅明确块脱颖而出,也许票价在代码重构的更强劲,它产生一些更干净的代码,语法,迫使所有声明顶部的块. 这使得它更容易看任何块和知道的范围并不是. 

作为一种模式,它反映了函数作用域时,手动移动/提升他们把许多人的方法`VaR`函数顶端的声明. 如果你不使用的话,让语句按意图把它们放在块的顶部. `让`声明各处,你块作用域声明的确认和维护更方便. 

但是,有个问题. 让声明的形式不包括在6. 没有官方的traceur编译器接受形式的代码. 

我们有两个选择. 我们可以使用6有效语法和一点点洒纪律格式代码: 

```js
/*let*/ { let a = 2;
	console.log( a );
}

console.log( a ); // ReferenceError
```

但是,工具是用来解决我们的问题的. 因此,另一个选项是编写显式语句块,并让工具将它们转换为有效的工作代码. 

于是,我造了一个叫"让"的工具. [^ note-let_er]解决这个问题. _让二_是一个构建步骤代码transpiler,但它唯一的任务是找到让声明的形式和transpile他们. 它将剩下的代码中的任何一个,包括任何允许声明. 你可以安全使用_让二_作为第一个6 transpiler步,然后把你的代码通过像跑酷者必要时. 

此外,_让二_有一个配置标志`ℴℴES6`,当打开(默认关闭)时,更改生成的代码类型. 相反的`try/catch`沙三polyfill黑客,_让二_将我们的代码和产生完全ES6兼容,不容易: 

```js
{
	let a = 2;
	console.log( a );
}

console.log( a ); // ReferenceError
```

所以,你可以开始使用_让二_马上,和目标都pre-es6环境,当你只在乎ES6,您可以添加国旗瞬间目标只有6. 

最重要的是,**可以使用更优惠和更明确的让语句形式. **即使它不是任何ES版本的正式部分(尚未). 

## 性能

让我再加上最后一点关于性能的注释. `try/catch`,和/或解决的问题,"为什么不只是用生命创造的范围?"

首先,`try/catch` _是_速度慢一些,但没有合理的假设. _有_是日_总是会_这样. 自正式批准使用transpiler TC39 ES6`try/catch`,traceur小组已让Chrome性能的改善`try/catch`他们显然是有动机这样做的. 

其次,生活是不公平的苹果与苹果的比较`try/catch`因为一个封装在任意代码周围的函数改变了代码中的含义`这`,`返回`,`打破`,和`持续`. 生活是不是一个合适的总代. 它只能在某些情况下手动使用. 

真正的问题是: 你想要块作用域,或不. 如果你这样做,这些工具为你提供了选择. 如果没有,继续使用`VaR`继续你的编码!

[^注名-]: [谷歌名](http://traceur-compiler.googlecode.com/git/demo/repl.html)

[^ note-let_er]\\: [让二](https://github.com/getify/let-er)
