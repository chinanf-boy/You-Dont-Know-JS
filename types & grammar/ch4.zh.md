
# 你不知道JS：类型和语法

# 第4章胁迫

既然我们更全面地理解了JavaScript的类型和价值，我们将注意力转向一个非常有争议的话题：强制。

正如我们在第1章提到的，关于强迫是一个有用的特征还是语言设计中的缺陷（或者两者之间的某个地方）的争论。自第一天就开始肆虐。如果你读过其他流行的关于JS的书，你知道那是非常流行的。_消息_这种强制是魔法的，邪恶的，混乱的，而且完全是个坏主意。

在这本书系列的总的精神上，与其因为其他人所做的那样逃避胁迫，或者因为你被某些怪癖所咬，我认为你应该朝你不理解并寻求的方向前进。_了解了_更充分。

我们的目标是充分探索利弊（是的，有）_是_赞成！）强迫性的，以便你能在程序中对它的适当性作出明智的决定。

## 转换价值

将值从一种类型转换为另一种类型时，通常称为“类型转换”，当显式地执行时，“隐式”（当使用值的规则强制）时，就强制执行“强制”。

**注：**它可能不是很明显，但JavaScript强制总是导致一种标量原始（见2章）的值，如`一串`，`数`，或`布尔`。没有强制产生复杂的值，比如`对象`或`功能`。第3章介绍了“装箱”，它将标量原始值包装在`对象`但这并不是精确意义上的强迫。

这些术语通常区分的另一种方式如下：“类型转换”（或“类型转换”）在编译时在静态类型语言中发生，而“类型强制”是动态类型语言的运行时转换。

然而，在JavaScript中，大多数人将所有这些类型的转换引用为_强制_所以，我比较喜欢区分“隐性强迫”和“明显强迫”。

区别应该很明显：“显式强制”是指从类型转换中故意发生的代码中明显看出的情况，而“隐式强制”是当类型转换发生在其他有意操作的不明显的副作用时。

例如，考虑这两种方法来强制：

```js
var a = 42;

var b = a + "";			// implicit coercion

var c = String( a );	// explicit coercion
```

对于`B`发生的强制是隐式发生的，因为`+`运算符与其中一个操作数组合在一起的`一串`价值（`“”`将坚持经营是一个`一串`串联（将两个字符串相加）_作为一种（隐藏的）副作用_将力`四十二`价值`一`被迫`一串`等效：`“42”`。

相比之下，`字符串（..）`函数很明显地表示它显式地引用`一`并强迫它去`一串`表示。

这两种方法都达到了同样的效果：`“42”`来自`四十二`。但这是_怎样_这是关于JavaScript强制的激烈争论的核心。

**注：**从技术上讲，除了文体差异之外，还有一些细微的行为差异。我们将在本章后面更详细地讨论这一点，在“隐式：字符串&lt;数字”部分。

术语“显式”和“隐式”、“明显”和“隐藏的副作用”是_相对的_。

如果你确切知道什么`“+”`是做的，而你是故意这样做的`一串`你可能会觉得手术足够“明确”，反之，如果你从未见过`字符串（..）`函数用于`一串`胁迫，它的行为似乎隐藏得足够让你感到“含蓄”。

但是我们正在讨论“明确的”和“隐含的”，基于一个_平均，合理的通知，但不是专家或者JS规范信徒_开发商.无论你做了什么或没有发现自己完全适应了那个桶，你将需要根据我们的观察来调整你的观点。

请记住：我们编写代码是非常罕见的，而且是唯一读过它的代码。即使你是JS所有细节的专家，也要考虑一个经验不足的队友在阅读你的代码时会有什么感受。对你来说，它是“明确的”还是“含蓄的”？

## 摘要值操作

在我们探索之前_明确的_VS_隐性的_强迫，我们需要学习支配价值的基本规则。_成为_任何一个`一串`，`数`，或`布尔`。在9节中的ES5规范定义了几个“抽象操作”（花式规格说“内部操作”）与价值转换规则。我们会特别注意：`ToString`，`第`，和`布尔`在较小程度上，`toprimitive`。

### `ToString`

当任何非—`一串`值被强制为`一串`表示，转换由`ToString`规范第9.8节中的抽象操作。

建立在原始自然字符串化所带来的价值：`无效的`成为`“空”`，`未定义`成为`“未定义”`和`真正的`成为`“真正的”`。`数`s一般以你期望的自然方式表达，但正如我们在第2章中讨论的，非常小或非常大。`数`以指数形式表示：

```js
// multiplying `1.07` by `1000`, seven times over
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// seven times three digits => 21 digits
a.toString(); // "1.07e21"
```

对于常规对象，除非指定自己的默认值。`tostring()`（位于`对象，tostring()原型。`将返回_内部的`[阶级]`_（参见第3章），例如`“[对象对象]`。

但如前所示，如果一个对象有它自己的`tostring()`方法，然后在`一串`类似的方式，它的`tostring()`将自动被调用，并且`一串`将使用该调用的结果。

**注：**对象被强制为A的方式`一串`技术上经过`toprimitive`抽象操作（ES5的规格，9.1节），但那些微妙的细节中有更详细的介绍的`第`本章后面的部分，我们将在这里跳过它们。

数组具有重写默认值。`tostring()`这stringifies为（字符串）的所有值串联（每个字符化本身），与`“，”`在每个值之间：

```js
var a = [1,2,3];

a.toString(); // "1,2,3"
```

再一次,`tostring()`可以显式调用，也可以非自动调用—`一串`用于`一串`语境。

#### JSON字符串化所带来的

另一项似乎非常相关的任务`ToString`当你使用`JSON。stringify（..）`实用价值的JSON序列化兼容`一串`价值。

注意，这个字符串化所带来的是不完全一样的东西，强迫是很重要的。但因为它与`ToString`以上规则，我们将在这里盖JSON字符串化所带来的轻微的转移行为。

最简单的JSON字符串化所带来的价值观、行为基本相同`tostring()`转换，但序列化结果为_总是一个`一串`_：

```js
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" (a string with a quoted string value in it)
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

任何_JSON安全_值可以是字符串化的`JSON。stringify（..）`。但什么是_JSON安全_？可以在JSON表示中有效地表示的任何值。

考虑值是比较容易的。**不**JSON安全。一些例子：`未定义`S，`功能`S，（6 +）`符号`S，和`对象`s循环引用（其中对象结构中的属性引用创建了一个相互循环的循环）。这些都是标准JSON结构的非法值，主要是因为它们不适合使用JSON值的其他语言。

这个`JSON。stringify（..）`实用程序将自动省略`未定义`，`功能`，和`符号`价值观。如果在一个`阵列`该值被替换为`无效的`（这样数组位置信息不会改变）。如果作为一个属性发现`对象`那财产将被排除在外。

考虑：

```js
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}"
```

但是如果你尝试`JSON。stringify（..）`一个`对象`在循环引用中，会抛出一个错误。

JSON字符串化所带来的特殊的行为，如果一个`对象`价值有一个`tojson()`方法定义后，将首先调用此方法以获得用于序列化的值。

如果你打算stringify JSON对象可能包含非法JSON值（S），或者如果你在才有价值`对象`不适合序列化，应该定义一个`tojson()`返回a的方法_JSON安全_版本的`对象`。

例如:

```js
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// create a circular reference inside `a`
o.e = a;

// would throw an error on the circular reference
// JSON.stringify( a );

// define a custom JSON value serialization
a.toJSON = function() {
	// only include the `b` property for serialization
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

这是一个很常见的误解。`tojson()`应该返回一个JSON字符串化所带来的表示。这可能是不正确的，除非你真的想stringify`一串`本身（通常不是！）。`tojson()`应该返回适当的实际规则值（任何类型），以及`JSON。stringify（..）`它将处理字符串化所带来的。

换言之，`tojson()`应该解释为“一种适用于JSON字符串化所带来的安全价值，”而不是“一个JSON字符串”，许多开发商误以为。

考虑：

```js
var a = {
	val: [1,2,3],

	// probably correct!
	toJSON: function(){
		return this.val.slice( 1 );
	}
};

var b = {
	val: [1,2,3],

	// probably incorrect!
	toJSON: function(){
		return "[" +
			this.val.slice( 1 ).join() +
		"]";
	}
};

JSON.stringify( a ); // "[2,3]"

JSON.stringify( b ); // ""[2,3]""
```

第二呼叫，我们返回的字符串化`一串`而不是`阵列`本身，这可能不是我们想做的事。

当我们谈论`JSON。stringify（..）`让我们来讨论一些不太为人所知的功能，这些功能仍然非常有用。

可选的第二个参数可以传递给`JSON。stringify（..）`这被称为_替代品_。这个论点可以是`阵列`或`功能`。它用于自定义一个`对象`通过提供一种过滤机制，使其属性应该和不应该包含，方法类似于`tojson()`可以为序列化准备一个值。

如果_替代品_是一个`阵列`应该是`阵列`属于`一串`s，每一个都将指定一个属性名，允许在序列化中包含`对象`。如果不存在此列表中的属性，则将跳过该属性。

如果_替代品_是一个`功能`它将被调用一次。`对象`本身，然后一次为每一个属性`对象`并且每次都传递两个参数，_钥匙_和_价值_。跳过_钥匙_在序列化中，返回`未定义`。否则，返回_价值_提供。

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"

JSON.stringify( a, function(k,v){
	if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
```

**注：**在`功能`替代品_替代品_案例，关键论点`K`是`未定义`第一次打电话（在那里）`一`对象本身正在传入）。这个`如果`陈述**滤出**命名属性`“C”`。字符串化所带来的是递归的，所以`[1,2,3]`数组具有它的每个值（`一`，`二`，和`三`）过去了`v`到_替代品_用索引（`零`，`一`，和`二`）为`K`。

第三个可选参数也可以传递给`JSON。stringify（..）`，称为_空间_它用作缩进以获得更美观的人性化输出。_空间_可以是一个正整数，表示每个缩进级别应该使用多少空格字符。或，_空间_可以是一个`一串`在这种情况下，其值的前十个字符将用于每个缩进级别。

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, null, 3 );
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

记得,`JSON。stringify（..）`不是直接的胁迫形式。然而，我们在这里介绍了两个原因，将其行为与`ToString`强制：

1.  `一串`，`数`，`布尔`，和`无效的`所有stringify JSON值基本相同如何强迫`一串`通过规则的值`ToString`摘要操作。
2.  如果你通过`对象`价值`JSON。stringify（..）`，，，`对象`有一个`tojson()`方法，`tojson()`自动调用（排序）“强制”值。_JSON安全_在字符串化所带来的。

### `第`

如果有非—`数`值的使用方式要求它是`数`，如数学运算的ES5规格定义`第`第9.3节中的抽象操作。

例如,`真正的`成为`一`和`假`成为`零`。`未定义`成为`南`（但奇怪的是）`无效的`成为`零`。

`第`对于一个`一串`数值基本上与数字文本的规则/语法一样有效（参见第3章）。如果失败，结果是`南`（而不是语法错误）`数`文字）。一个不同的例子是`零`前缀八进制数处理不作为octals（就像正常的10十进制）在这次行动中，虽然这样的octals是有效的`数`文字（见第2章）。

**注：**之间的差异`数`文字和语法`第`在一个`一串`价值是微妙的和高度微妙的，因此不会在这里进一步介绍。参照第9.3.1的ES5规格的更多信息。

对象（和数组）首先将转换为它们的原始等价的值，并生成结果值（如果是原始的，但还没有`数`）被强制为`数`根据`第`刚才提到的规则。

若要转换为此原始值等效，则`toprimitive`抽象操作（ES5的规格，9.1节）将参考值（使用内部`默认值`操作-- ES5的规格，截面8.12.8）问题是否有`valueof()`方法。如果`valueof()`是可用的，它返回一个原始值，_那个_值用于强制。如果没有，但`tostring()`是可用的，它将为强制值提供价值。

如果两个操作都不能提供原始值，则`TypeError`抛出。

由于ES5，您可以创建这样一个noncoercible对象--一个没有`valueof()`和`tostring()`——如果它有`无效的`对于它的价值`[原型]`，通常用`对象创建（null）`。看到_对象原型_本系列的标题，了解更多信息`[原型]`S.

**注：**我们讨论如何强制`数`s在本章后面的细节中，但是对于下一个代码片段，只需假设`数字（..）`函数是这样的。

考虑：

```js
var a = {
	valueOf: function(){
		return "42";
	}
};

var b = {
	toString: function(){
		return "42";
	}
};

var c = [4,2];
c.toString = function(){
	return this.join( "" );	// "42"
};

Number( a );			// 42
Number( b );			// 42
Number( c );			// 42
Number( "" );			// 0
Number( [] );			// 0
Number( [ "abc" ] );	// NaN
```

### `布尔`

接下来，让我们聊一聊`布尔`js的行为。有**许多困惑和误解**围绕这个话题漂浮着，所以要密切关注！

首先，js有实际关键字`真正的`和`假`他们的行为完全符合你的期望。`布尔`价值观。人们普遍认为这些价值观是错误的。`一`和`零`是相同的`真正的`/`假`。虽然在其他语言中可能是这样的，但在js中`数`S`数`S和`布尔`S`布尔`你可以胁迫`一`到`真正的`（反之亦然）或`零`到`假`（反之亦然）。但它们不一样。

#### falsy值

但故事还没有结束。我们需要讨论二者的价值观。`布尔`你胁迫的时候要表现出来_到_他们的`布尔`等效。

所有JavaScript的值可以分为两类：

1.  将成为的价值观`假`如果强迫`布尔`
2.  其他一切（显然会变成）`真正的`）

我不是在开玩笑。js规范定义了一个特定的、狭窄的值列表，它将强制`假`胁迫时`布尔`价值。

我们如何知道值列表是什么？在ES5的规格，9.2节的定义`布尔`抽象操作，它精确地表示当你试图强迫它们“布尔”时，所有可能的值会发生什么。

从表中，我们可以得到下面的所谓“falsy“值列表：

-   `未定义`
-   `无效的`
-   `假`
-   `+ 0`，`- 0`，和`南`
-   `“”`

够了就要这些。如果一个值是在名单上，这是一个“falsy”值，它将强迫`假`如果你强迫某人`布尔`胁迫它。

根据逻辑结论，如果值是_不_在那个名单上，它必须在_另一个列表_，我们称之为“真相”的价值观清单。但JS无法定义“真相”列表本身。它给出了一些例子，如明确的话，所有的对象都是真相，但大多只是意味着规格：**没有明确的falsy列表因此真相。**

#### falsy对象

等一下，那一节标题听起来甚至矛盾。我真的_只是说_规范要求所有对象的真实性，对吗？应该没有这样的东西作为一个“falsy对象。”

这可能意味着什么呢？

你也许会认为这是一个包装对象（见3章）在falsy值（如`“”`，`零`或`假`）。但别陷入那_陷阱_。

**注：**这是一个微妙的规范笑话，有些人可能会得到。

考虑：

```js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );
```

我们知道所有三个值对象（见3章）缠falsy值明显。但是这些物体是否表现为`真正的`或为`假`？那很容易回答：

```js
var d = Boolean( a && b && c );

d; // true
```

所以，三者都表现为`真正的`因为这是唯一的方法`D`可能会结束`真正的`。

**提示：**通知`布尔（…）`缠`健康与健康`表达——你可能想知道为什么会这样。我们将在本章后面提到这一点，所以请记下它。偷看一眼（小聪明），自己试试看`D`如果你只是做`a并购与并购`没有`布尔（…）`呼叫！

所以，如果“falsy对象”**不只是反对缠falsy值**他们到底是什么？

棘手的部分是它们可以出现在js程序中，但它们实际上并不是JavaScript本身的一部分。

**什么!？**

在某些情况下，浏览器已经创建了自己的类型。_异国情调的_价值观的行为，即“falsy对象”上定期JS语义。

“falsy对象”是一种价值，看上去像一个正常的对象（属性，等等），但是当你强迫它一`布尔`，它强迫一个`假`价值。

**为什么!？**

最著名的例子是`document.all`：提供给JS程序的数组（对象）_通过DOM_（不是js引擎本身），它将页面中的元素暴露到js程序中。它_习惯于_要像一个正常的对象，它将采取行动，一些。但不再。

`document.all`自己从来没有真正的“标准”，早已过时了。

“他们就不能把它移走吗？”对不起，很好的尝试。希望他们能。但是，有太多遗留下来的JS代码基础依赖于它。

那么，为什么把它作为falsy？因为强制的`document.all`到`布尔`（像`如果`语句几乎总是用来检测旧的、不标准的IE。

IE浏览器早就达到了标准的标准化，而且在很多情况下，它比任何其他浏览器都要推进Web的数量。但是所有那些旧的`如果（文件all）{它是IE }`代码仍然存在，其中大部分可能永远不会消失。所有这些遗留代码仍然假设它运行在十年前的IE，这只会导致IE用户的浏览体验不佳。

所以，我们不能移除`document.all`完全不需要`如果（文件all）{}`代码再工作，使现代IE用户获得新的、符合标准的代码逻辑。

“我们该怎么办？”\*\*“我明白了！让我们低落的JS型系统和假装`document.all`是falsy！”

啊。吮吸。这是一个疯狂的疑难杂症，大多数JS开发者不理解。但另一种选择（对上述不成功的问题不采取行动）很糟糕。_只要再多一点。_。

所以…这是我们得到了什么：疯狂的，非标准的“falsy对象添加到JavaScript的浏览器。耶！

#### Truthy的价值观

回到一些列表。价值观的真相到底是什么？记得:**一个值是一些如果不在falsy列表。**

考虑：

```js
var a = "false";
var b = "0";
var c = "''";

var d = Boolean( a && b && c );

d;
```

你期望什么价值？`D`来这里？它必须是要么`真正的`或`假`。

它是`真正的`。为什么？因为尽管这些内容`一串`价值观像falsy值的`一串`价值观本身是所有的真相，因为`“”`是唯一的`一串`在falsy列表值。

这些怎么样？

```js
var a = [];				// empty array -- truthy or falsy?
var b = {};				// empty object -- truthy or falsy?
var c = function(){};	// empty function -- truthy or falsy?

var d = Boolean( a && b && c );

d;
```

是的，你猜对了，`D`仍然是`真正的`在这里.为什么？和以前一样。不管它看起来是什么样子，`[ ]`，`{ }`，和`function() { }`是_不_在falsy列表，因此一些值。

换句话说，真相是无限长的列表。做这样的清单是不可能的。你只能做有限的falsy列表和参考_它_。

花五分钟的时间，写falsy名单贴到你的电脑显示器，或记住它，如果你喜欢。无论哪种方式，你能够轻松地构建一个虚拟的一些清单，每当你需要问它在falsy列表或不简单。

的真实性和falsy的重要性了解价值的行为如果你强迫它（无论是明示或暗示）一`布尔`价值。既然您已经记住了这两个列表，我们就可以深入到强制示例本身了。

## 明确强制

_明确的_强制指的是明显的类型转换。_明确的_大多数开发者的胁迫类别。

这里的目标是识别模式在我们的代码中，我们可以清晰和明显的，我们的值转换为另一种类型，从而不留坑洼未来开发商去。我们越是明确，就越有可能以后有人能读懂我们的代码，不费力地理解我们的意图。

很难找到任何明显的分歧。_明确的_强制，因为它最接近于在静态类型语言中普遍接受的类型转换实践。因此，我们现在认为这是理所当然的。_明确的_胁迫可以被认为不是邪恶的或有争议的。不过，我们稍后会重新讨论这个问题。

### 显式：字符串&lt;数字

我们将从最简单的也许是最常见的强制操作：强迫值之间`一串`和`数`表示。

强迫之间`一串`S和`数`s，我们使用内置的`字符串（..）`和`数字（..）`函数（在第3章中我们称之为“本地构造函数”），但是**很重要的是**我们不使用`新的`前面的关键字。因此，我们不创建对象包装器。

事实上，我们实际上_明确强制_这两种类型之间：

```js
var a = 42;
var b = String( a );

var c = "3.14";
var d = Number( c );

b; // "42"
d; // 3.14
```

`字符串（..）`强迫任何其他价值的原始`一串`价值，使用的规则`ToString`前面讨论的操作。`数字（..）`强迫任何其他价值的原始`数`价值，使用的规则`第`前面讨论的操作。

我把这称为_明确的_强制，因为一般情况下，大多数开发人员都非常清楚，这些操作的最终结果是适用的类型转换。

事实上，这种用法看起来非常像在其他静态类型语言中的用法。

例如，在C和C++中，你可以说`（int）x`或`int（x）`两个都将转换`X`整数。两种形式都是有效的，但是很多都喜欢后者，它看起来像一个函数调用。在JavaScript中，当你说`数字（x）`看起来非常相似。它是否重要？_事实上_js中的函数调用？不是真的。

除了`字符串（..）`和`数字（..）`还有其他方法可以显式地将这些值转换为`一串`和`数`：

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42"
d; // 3.14
```

打电话`A. tostring()`表面上是明确的（很明显，“说明”是指“字符串”），但有一些隐藏的含蓄在这里。`tostring()`不能被调用_原始的_价值`四十二`。所以js自动“框”（参见第3章）`四十二`在对象包装器中，以便`tostring()`可以针对对象调用。换句话说，你可以称它为“显式隐式”。

`+ C`这里是展示_一元运算符_窗体（只有一个操作数的运算符）`+`算子。不是执行数学加法（或字符串连接（见下文）），而是一元的。`+`明确强迫其操作数（`C`）一个`数`价值。

是`+ C`明确的_胁迫？取决于你的经验和观点。如果你知道（你现在做了！）这一元_+`明确地打算`数`胁迫，那么它是非常明确和明显的。然而，如果你以前从未见过它，它似乎非常混乱，隐含，隐藏的副作用，等等。`注：

**开源JS社区中普遍接受的观点是一元的。**+`是一种公认的形式。`明确的_强制。_即使你真的喜欢

\+ C`形式上，肯定有一些地方看起来很混乱。考虑：`一元

```js
var c = "3.14";
var d = 5+ +c;

d; // 8.14
```

—`运营商还强迫喜欢`+`是的，但它也翻转了数字的符号。然而，你不能把两个`——`邻近unflip的标志，这是解析为递减运算符。相反，你需要做：`-“3.14”`在两者之间有一个空格，这将导致强制`三点一四`。`你可能会想出各种各样的二进制运算符的可怕组合（比如

\+`加法）在运算符的一元形式旁边。这里又是一个疯狂的例子：`你应该极力考虑避免一元。

```js
1 + - + + + - + 1;	// 2
```

\+`（或`—`当它与其他操作符相邻时强制。虽然上述工作，它几乎普遍被认为是一个坏主意。即使`D＝C`（或`D＝C`对那件事！）很容易被混淆`d＝c`这是完全不同的！`注：

**另一个非常混乱的地方**+`与另一个运算符相邻使用的将是`+ +`增量运算符和`——`减量运算符。例如:`++`，`++`，和`++`。参见第5章中的“表达式副作用”`+ +`。`记住，我们试图做到明确

减少**混乱，而不是更糟！**日期

#### `以`数`一元的另一常用用法`

\+`经营者是强制`日期`对象为`数`，因为结果是Unix时间戳（毫秒时间自1970年1月1日00:00:00 UTC）表示的日期/时间值：`这个习语最常见的用法是获取当前信息。

```js
var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

+d; // 1408369986000
```

现在_作为时间戳的时刻，例如_作为时间戳的时刻，例如：

```js
var timestamp = +new Date();
```

**注：**有些开发人员意识到JavaScript中有一种特殊的语法“技巧”，也就是说`（）`设置构造函数调用（调用的函数）`新的`）是_可选择的_如果没有参数可以通过。所以你可以跑过`时间戳=新日期；`形式。然而，并不是所有的开发人员都同意省略`（）`提高可读性，因为这是一种罕见的语法例外，只适用于`新的fn()`通话形式而不是常规`fn()`调用形式。

但是强制不是唯一的方法来获得时间戳。`日期`对象。一个noncoercion方法也许更可取，因为它更显：

```js
var timestamp = new Date().getTime();
// var timestamp = (new Date()).getTime();
// var timestamp = (new Date).getTime();
```

但一个_甚至更多_较好的noncoercion选项是使用ES5添加`now()日期。`静态函数：

```js
var timestamp = Date.now();
```

如果你想polyfill`now()日期。`进入较旧的浏览器，这是非常简单的：

```js
if (!Date.now) {
	Date.now = function() {
		return +new Date();
	};
}
```

我建议跳过与日期相关的强制形式。使用`now()日期。`当前_现在_时间戳，和`新日期（..）gettime()。`获取特定时间戳_非现在_需要指定的日期/时间。

#### 奇怪的情况`~`

一个强制JS算子是往往被忽视，通常很迷茫是波浪线`~`算子（又名“位”）。许多人甚至理解它所做的事情，但往往还是想避免它。但是，在这本书和系列文章中，坚持我们的方法精神，让我们深入探究它是否`~`有什么有用的东西可以给我们吗？。

在32位整数（签名）”部分的2章，我们覆盖在JS运算符如何只为32位的操作定义，这意味着他们的力量他们的操作符合32位值表示。这种情况如何发生的规则由`toint32`抽象操作（ES5的规格，9.5节）。

`toint32`第一次做`第`胁迫，这意味着如果值是`“123”`它将首先成为`一百二十三`之前`toint32`规则被应用。

而不是_技术上_强制本身（因为类型不改变！），使用运算符（如`|`或`~`）具有某种特殊性`数`值产生强制效果，导致不同的结果。`数`价值。

例如，让我们首先考虑`|`“按位或“用于否则没有OP成语算子`0 | X`（正如第2章所示）基本上只做`toint32`转换：

```js
0 | -0;			// 0
0 | NaN;		// 0
0 | Infinity;	// 0
0 | -Infinity;	// 0
```

这些特殊的数字不是32位表示（因为他们来自64位IEEE 754标准见2章），所以`toint32`只是指定`零`作为这些值的结果。

如果有争议的话`0 | __`是一个_明确的_这种强制形式`toint32`操作或如果它是更多_隐性的_。从规范的角度来看，这是毫无疑问的。_明确的_，但如果你不懂这一水平位操作，它似乎更多一点_隐式_神奇的.然而，与本章中的其他断言一致，我们将称之为_明确的_。

所以，让我们把注意力转移到`~`。这个`~`运营商“要挟”到一个32位的第一`数`值，然后执行按位求反运算（翻转每个比特的奇偶校验）。

**注：**这很相似。`！`不仅使其价值`布尔`但也会翻转其奇偶性（参见“一元”的讨论）。`！`“后来”。

但…什么!为什么我们关心比特被翻转？这是一些非常专业的，细致入微的东西。js开发人员很少需要对单个位进行推理。

关于定义的另一种思考方式`~`来自老派的计算机科学/离散数学：`~`执行二进制补码。太好了，谢谢，那就更清楚了！

让我们再试一次：`~ X`大致相同`-（x + 1）`。这很奇怪，但稍微容易一点。所以：

```js
~42;	// -(42+1) ==> -43
```

你可能还在想这到底是怎么回事`~`事情是关于什么的，或者为什么对强迫讨论真的很重要。让我们迅速到达要点。

考虑`-（x + 1）`。您能执行的操作的唯一值是什么？`零`（或`- 0`技术！）结果呢？`- 1`。换言之，`~`用于一系列`数`值将产生一个falsy（很容易转换成`假`）`零`值为`- 1`输入的值，和其他一些`数`否则。

这有什么关系？

`- 1`通常称为“哨兵值”，基本上是指在同一类型的较大值集内赋予任意语义的值。`数`S）。C语言的使用`- 1`许多回归函数的哨兵值`> = 0`“成功”的价值观`- 1`因为“失败”。

JavaScript在定义时使用了这个先例`一串`操作`IndexOf（..）`搜索一个字符串，如果发现返回其下标的位置，或`- 1`如果没有找到。

尝试使用是很常见的。`IndexOf（..）`不仅仅是为了获得这个职位，而是作为一个`布尔`存在/不存在在另一个字符串检查`一串`。下面是开发人员通常如何执行这样的检查：

```js
var a = "Hello World";

if (a.indexOf( "lo" ) >= 0) {	// true
	// found it!
}
if (a.indexOf( "lo" ) != -1) {	// true
	// found it
}

if (a.indexOf( "ol" ) < 0) {	// true
	// not found!
}
if (a.indexOf( "ol" ) == -1) {	// true
	// not found!
}
```

我觉得这很恶心。`> = 0`或`= 1`。它基本上是一个“泄露的抽象”。`- 1`对于“失败”——进入我的代码。我宁愿隐瞒这样的细节。

现在，我们终于明白为什么了`~`能帮助我们！使用`~`具有`indexof()`“要挟”（实际上只是变换）的价值**要适当`布尔`-强制**：

```js
var a = "Hello World";

~a.indexOf( "lo" );			// -4   <-- truthy!

if (~a.indexOf( "lo" )) {	// true
	// found it!
}

~a.indexOf( "ol" );			// 0    <-- falsy!
!~a.indexOf( "ol" );		// true

if (!~a.indexOf( "ol" )) {	// true
	// not found!
}
```

`~`取返回值`IndexOf（..）`并将其转化为“失败”`- 1`我们得到的falsy`零`，和所有其他价值是真相。

**注：**这个`-（x + 1）`伪算法`~`将意味着`~ - 1`是`- 0`但实际上它产生`零`因为基本的操作实际上是位，不是数学。

技术上，`如果（~ a.indexof（..））`仍然依赖_隐性的_强迫其结果`零`到`假`或非零`真正的`。但总的来说，`~`仍然觉得我更像一个_明确的_强制机制，只要你知道它在这个成语中打算做什么。

我发现这是比以前更干净的代码。`> = 0`/`= 1`杂波。

##### 截断位

还有一个地方`~`可能会在代码中你遇到：一些开发商利用双波浪线`~ ~`截断小数部分`数`（即“强迫”为整数“整数”）。它通常（但错误地）说，这是由于调用相同`数学（地板）`。

怎么`~ ~`作品是第一个`~`应用`toint32`“强制”和按位翻转，然后第二`~`另一位翻转，翻转所有的位都回到原来的状态。最终的结果就是`toint32`“胁迫”（亦称截断）。

**注：**位双翻转`~ ~`非常类似于奇偶否定。`！！`行为，稍后在“显式：\* -布尔”一节中解释。

然而,`~ ~`需要小心/澄清。首先，它只在32位值上可靠地工作。但更重要的是，它在负数上不起作用。`数学（地板）`做!

```js
Math.floor( -49.6 );	// -50
~~-49.6;				// -49
```

设置`数学（地板）`差异不谈，`~ ~ X`可以截断为（32位）整数。但这样做`X | 0`，似乎（略微）_较少的努力_。

那么，你为什么会选择`~ ~ X`结束`X | 0`，然后呢？运算符优先级（参见第5章）：

```js
~~1E20 / 10;		// 166199296

1E20 | 0 / 10;		// 1661992960
(1E20 | 0) / 10;	// 166199296
```

就像这里所有其他建议一样，使用`~`和`~ ~`作为“强制”和“值转换”的显式机制，只有读写这样代码的每个人都能正确地知道这些操作符是如何工作的！

### 显式：解析数字字符串

一个类似的结果，强迫`一串`一个`数`可以通过解析a来实现`数`从一个`一串`人物的内容。但是，这种解析和我们上面检查的类型转换有明显的区别。

考虑：

```js
var a = "42";
var b = "42px";

Number( a );	// 42
parseInt( a );	// 42

Number( b );	// NaN
parseInt( b );	// 42
```

解析字符串中的数字值是_宽容_对于非数字字符，它只在遇到时向左解析，而强制是_不宽容_失败导致`南`价值。

解析不应被视为胁迫的替代品。这两个任务虽然相似，但却有不同的目的。解析`一串`作为一个`数`当你不知道/关心什么其他非数字字符可能在右手边。强迫`一串`（一个`数`当唯一可接受的值是数值的和类似的`“42px”`应拒绝作为`数`。

**提示：**parseInt（..）`有双胞胎，`parseFloat（..）`，从一个字符串中提取一个浮点数。`别忘了

parseInt（..）`操作上`一串`价值观。通过一件事是毫无意义的。`数`价值`parseInt（..）`。传递任何其他类型的值也没有意义，比如`真正的`，`function() {等}`或`\[1,2,3]`。`如果您通过非—

一串`您传递的值将自动被强制为`一串`首先（见）`ToString`“早些时候”，这显然是一种隐藏。`隐性的_强制。在程序中依赖这样的行为是一个很糟糕的想法，所以千万不要使用。_parseInt（..）`用非—`一串`价值。`另一个问题之前ES5，存在

parseInt（..）`这是许多js程序错误的根源。如果没有传递第二个参数来指示用于解释数字的数字基（又名基数）。`一串`内容，`parseInt（..）`先看看开头的字符，然后猜一猜。`如果前两个字符是

“0x”`或`“0x”`根据惯例，猜测是你想解释的。`一串`为一个十六进制（16进制）`数`。否则，如果第一个字符是`“0”`这个猜测（又是惯例）是你想解释的。`一串`作为一个八进制（base-8）`数`。`十六进制

一串`（领先）`0x`或`0x`不是很容易混在一起。但八进制数的猜测是非常常见的。例如:`似乎无害，对吗？请选择

```js
var hour = parseInt( selectedHour.value );
var minute = parseInt( selectedMinute.value );

console.log( "The time you selected was: " + hour + ":" + minute);
```

08`时间和`09`暂时。你会得到`0`。为什么？因为没有`八`也没有`九`在八base-8有效字符。`的pre-es5修复很简单，但却很容易忘记：

总是擦肩而过**十`作为第二个论点`。这是完全安全的：**由于ES5，

```js
var hour = parseInt( selectedHour.value, 10 );
var minute = parseInt( selectedMiniute.value, 10 );
```

parseInt（..）`不再猜八进制。除非你说，否则，它假定10（或16进制为`“`“0x”`前缀）。That's much nicer. 只是要小心，如果你的代码运行在pre-es5环境，在这种情况下，你仍然需要通过`十`为了基数。

#### 非字符串解析

一个有点臭名昭著的例子`parseInt（..）`几年前，在一篇讽刺笑话中，人们的行为被突显出来，取笑这个JS行为：

```js
parseInt( 1/0, 19 ); // 18
```

假设（但完全无效）的说法是，“如果我通过无限，和整数解析出来，我应该得到无限回来了，不是18。”当然，JS一定是疯了，这个结局，对吗？

虽然这个例子显然是做作和虚幻的，让我们暂时放纵一下疯狂，看看JS是否真的疯了。

首先，这里犯下的最明显的罪过是不通过—`一串`到`parseInt（..）`。那是不允许的。这样做，你是在自找麻烦。但即使你礼貌地强迫你，JS通过成`一串`它可以尝试解析。

有些人会说这是不合理的行为。`parseInt（..）`应拒绝经营非—`一串`价值。它可能会抛出一个错误吗？这很像java，坦率地说。想到JS开始到处乱丢错误，我就不寒而栗。`试试。赶上`几乎每一行都需要。

它应该返回`南`？也许吧.但…怎么样：

```js
parseInt( new String( "42") );
```

那也会失败吗？这是非—`一串`价值。如果你想要的话`字符串`包装对象是办法`“42”`那真的很不寻常吗？`四十二`首先成为`“42”`以便`四十二`可以解析回来吗？

我认为这一半—_明确的_，半—_隐性的_可能发生的胁迫常常是非常有益的事情。例如:

```js
var a = {
	num: 21,
	toString: function() { return String( this.num * 2 ); }
};

parseInt( a ); // 42
```

事实上，`parseInt（..）`强行逼迫其值为`一串`执行解析是相当明智的。如果你把垃圾扔进垃圾桶，然后把垃圾拿出来，不要责怪垃圾桶——它只是忠实地完成了它的工作。

所以，如果传入一个值，比如`无穷`（结果）`1 / 0`显然）什么样的`一串`代表权对其胁迫最有意义？只有两个合理的选择出现在脑海中：`“无限”`和`“∞”`。JS选择`“无限”`。我很高兴它做到了。

我认为这是件好事。**所有的值**js中有某种默认值`一串`表示，所以它们不是神秘的黑盒，我们无法调试和推理。

现在，base-19呢？显然，完全是伪造的。没有真正的JS程序使用base-19。太荒谬了。但是，让我们沉迷的荒谬。在base-19，有效数字字符`零`—`九`和`一`—`我`（不区分大小写）。

所以，回到我们的`parseInt（1 / 0, 19）`例子.它本质上是`parseInt（“无限”，19）`。它是如何解析的？第一个字符是`“我”`，这是价值`十八`在愚蠢的base-19。第二特征`“N”`不在有效的数字字符集中，因此解析简单地礼貌地停止，就像它跨越时一样。`“P”`在里面`“42px”`。

结果呢？`十八`。理智地认为它应该是。让我们到达那里的行为，而不是错误或`无穷`本身，是**非常重要**对JS，不应该这么轻易丢弃。

这种行为的其他例子`parseInt（..）`这可能令人惊讶，但相当明智的包括：

```js
parseInt( 0.000008 );		// 0   ("0" from "0.000008")
parseInt( 0.0000008 );		// 8   ("8" from "8e-7")
parseInt( false, 16 );		// 250 ("fa" from "false")
parseInt( parseInt, 16 );	// 15  ("f" from "function..")

parseInt( "0x10" );			// 16
parseInt( "103", 2 );		// 2
```

`parseInt（..）`实际上在行为上是相当可预测和一致的。如果你正确地使用它，你会得到合理的结果。如果你不正确地使用它，你得到的疯狂结果并不是JavaScript的错误。

### 显式：\*

现在，让我们检查强迫任何非—`布尔`价值一`布尔`。

就像`字符串（..）`和`数字（..）`以上，`布尔（…）`（没有`新的`当然可以！）是一种强制的明确方法。`布尔`强制：

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

Boolean( a ); // true
Boolean( b ); // true
Boolean( c ); // true

Boolean( d ); // false
Boolean( e ); // false
Boolean( f ); // false
Boolean( g ); // false
```

而`布尔（…）`显然是明确的，它根本不是普通的或惯用的。

就像一元`+`算子胁值一`数`（见上文），一元`！`否定算子明确胁值一`布尔`。这个_问题_也就是把价值从一些对falsy反之亦然。因此，js开发人员明确地强制使用的最常见方式是`布尔`是使用`！！`双否定运算符，因为第二个运算符`！`将奇偶性翻转回原来的值：

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a;	// true
!!b;	// true
!!c;	// true

!!d;	// false
!!e;	// false
!!f;	// false
!!g;	// false
```

任何这些`布尔`强制转换会发生_隐式_没有`布尔（…）`或`！！`如果用在`布尔`上下文，例如`如果……`声明。但这里的目标是显式地将值强制为`布尔`为了更清楚地说明`布尔`胁迫是故意的。

另一个显式用例的例子`布尔`胁迫就是如果你想强迫一个`真正的`/`假`数据结构JSON序列化中的值强制：

```js
var a = [
	1,
	function(){ /*..*/ },
	2,
	function(){ /*..*/ }
];

JSON.stringify( a ); // "[1,null,2,null]"

JSON.stringify( a, function(key,val){
	if (typeof val == "function") {
		// force `ToBoolean` coercion of the function
		return !!val;
	}
	else {
		return val;
	}
} );
// "[1,true,2,true]"
```

如果你到JavaScript从java，你可能认识这个成语：

```js
var a = 42;

var b = a ? true : false;
```

这个`？：`三元运算符检验`一`为事实，并在此基础上，试验将分配`真正的`或`假`到`B`，因此。

从表面上看，这个成语看上去像是一种_明确的_布尔`-类型强制，因为很明显只有`真正的`或`假`从手术中出来`从手术中出来。

但是，有一个隐藏的_隐性的_胁迫，在`一`表达式必须首先被强制为`布尔`执行测试的事实。我把这个成语叫做“隐式显式”。**你应该完全避免这个成语。**在JavaScript。它没有提供真正的好处，更糟糕的是，伪装成什么也不是。

`布尔（a）`和`！！一`要好得多_明确的_强制选项。

## 隐式强制

_隐性的_强制是指隐藏的类型转换，从其他操作中隐式地出现非明显的副作用。换言之，_隐式强制转换_是否对您不明显的任何类型转换。

虽然很清楚的目标是什么_明确的_强制是（使代码更明确，更易于理解），它可能是_太_明显的，_隐性的_强制有相反的目标：使代码更难理解。

从表面上看，我认为这是对胁迫的愤怒来自于。大多数关于“JavaScript强制”的抱怨实际上是针对（不管他们是否意识到）。_隐性的_强制。

**注：**道格拉斯克罗克福德，作家_“JavaScript：好的部分”_他在许多会议演讲和著作中声称，应该避免JavaScript强制。但他似乎是指_隐性的_胁迫是坏的（在他看来）。然而，如果您阅读了他自己的代码，就会发现很多强制的例子，两者都是。_隐性的_和_明确的_！事实上，他的焦虑似乎主要针对的是`= =`操作，但正如您在本章中看到的，这只是强制机制的一部分。

所以，**隐式强制**邪恶吗？有危险吗？这是javascript设计中的缺陷吗？我们应该不惜一切代价避免它吗？

我打赌你们大多数读者都会热情地欢呼，“是的！”

**不这么快。**听我说。

让我们换个角度看什么_隐性的_强迫是，也可以是，它只是“与明显的强制形式相反”，这是太狭隘了，忽略了一个重要的细微差别。

让我们定义目标_隐性的_胁迫：减少冗长、样板、和/或不必要的实现细节，杂波与分散更重要的意图噪声码。

### 简化式

在我们还没到JavaScript，让我提出一些pseudo-code'ish从一些理论强类型语言说明：

```js
SomeType x = SomeType( AnotherType( y ) )
```

在这个例子中，我有一些任意类型的值`Y`我想转换成`基类型`型。问题是，这种语言不能直接来自任何事物。`Y`目前是`基类型`。它需要一个中间步骤，首先转换为`另一种类型的`，然后`另一种类型的`到`基类型`。

现在，如果这种语言（或者你可以用语言创造的定义）怎么办？_做_就让你说：

```js
SomeType x = SomeType( y )
```

您一般不会同意我们简化了这里的类型转换，以减少中间转换步骤的不必要的“噪音”吗？我是说，是吗？_真正地_所有这些重要的，在这里，在这一点上的代码，看到和处理的事实`Y`去`另一种类型的`先到那时再去`基类型`？

有些人会争辩说，至少在某些情况下，是的。但我认为，在许多其他情况下，可以用同样的论点来简化。**实际上艾滋病代码的可读性**通过抽象或隐藏这些细节，无论是在语言本身还是在我们自己的抽象中。

毫无疑问，在幕后，某个地方，中间的转换步骤仍在发生。但是，如果这个细节被隐藏在这里，我们可以解释为什么`Y`型`基类型`作为一种泛型操作，隐藏混乱的细节。

虽然这不是一个完美的类比，我要在本章其余部分中讨论的是JS。_隐性的_强制可以被认为是对代码提供类似的帮助。

但，**这是非常重要的。**这不是一个无限制的绝对陈述。肯定有很多_罪恶_潜伏在_隐性的_强制，这将损害您的代码远远超过任何潜在的可读性改进。显然，我们必须学会如何避免这样的构造，这样我们就不会用各种各样的bug毒害我们的代码。

许多开发人员认为，如果一个机制可以做一些有用的事情。**一**但也可以被滥用或滥用做一些可怕的事情。**Z**为了安全，我们应该完全放弃那个机制。

我对你的鼓励是：不要满足于此。不要把婴儿连同洗澡水一起倒掉”。不要以为_隐性的_胁迫是不好的，因为你认为你所见过的一切都是它的“坏部分”，我认为这里有“好的部分”，我想帮助和激励更多的人去发现并拥抱它们！

### 隐式地：字符串&lt;数字

在本章的前面，我们探讨了_明确地_强迫之间`一串`和`数`价值观。现在，让我们探索同一个任务，但_隐性的_强制的方法。但在此之前，我们必须检查一些怒江。_隐式_强迫。

这个`+`运算符重载，以满足两个目的。`数`此外，`一串`级联。那么js如何知道要使用哪种操作呢？考虑：

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

不同的原因是什么？`“420”`VS`四十二`？常见的误解是，一个或两个操作数是否是一个`一串`因为那意味着`+`将承担`一串`级联。虽然这是部分真实的，但它比那更复杂。

考虑：

```js
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

这些操作数都不是`一串`但显然他们都被强迫`一串`然后`一串`并置踢。那到底是怎么回事？

（**警告：**深入细节规格说来，所以跳过下一段如果恐吓你！）

* * *

根据规范第11.6.1的ES5，`+`算法（当`对象`价值是一个操作数）将连接如果一个操作数是不是已经`一串`或者以下步骤生成`一串`表示。所以，当`+`接收`对象`（包括`阵列`对于两个操作数，它首先调用`toprimitive`关于值的抽象操作（第9.1节），然后调用`【[默认值] ]`算法（第8.12.8）与上下文的暗示`数`。

如果你密切注意，你会注意到这个操作现在与`第`摘要操作手柄`对象`s（参见“`第`“前面的部分）。这个`valueof()`操作上的`阵列`会产生一个简单的原始，所以它掉到一个`tostring()`表示。两`阵列`S因此成为`“1”`和`“3”`，分别。现在,`+`将两`一串`正如你通常预料的那样：`“1,23,4”`。

* * *

让我们抛开那些杂乱的细节，回到先前的，简化的解释：如果两个操作数都到`+`是一个`一串`（或成为上述步骤的一个！）手术将是`一串`级联。否则，它总是数字加法。

**注：**一个常被引用的强迫你`[] + {}`vs.`{ [ } ]`，这两个表达式分别在`“[对象对象]`和`零`。不过，还有更多的内容，我们在第5章的“区块”中详细介绍了这些细节。

这意味着什么？_隐性的_胁迫？

你可以胁迫一个`数`一个`一串`简单地说“添加”`数`和`“”`空的`一串`：

```js
var a = 42;
var b = a + "";

b; // "42"
```

**提示：**数值加法`+`运算符是交换的，这意味着`2 + 3`是一样的`3 + 2`。字符串连接用`+`显然不是一般的交换，**但是**以具体案例`“”`它实际上是可交换的，如`“+”`和`"" + a`产生相同的结果。

这是非常普遍/习惯的。_隐式_）胁迫`数`到`一串`用一个`+“”`操作。事实上，有趣的是，即使是一些最直言不讳的批评者_隐性的_强制仍然在自己的代码中使用这种方法，而不是其中的一种。_明确的_选择.

**我认为这是一个很好的例子。**一种有用的形式_隐性的_强迫，尽管这种机制经常受到批评！

比较_隐性的_强制`“+”`我们前面的例子`字符串（a）`明确的_胁迫，还有一个额外的怪癖要知道。因为如何_toprimitive`抽象作业，`“+”`调用`valueof()`上`一`值，其返回值最后转换为`一串`通过内部`ToString`摘要操作。但`字符串（a）`只是调用`tostring()`直接。`这两种方法最终导致

一串`但是如果你使用`对象`而不是普通的原语`数`值，您可能不一定得到`相同的_一串_价值！`考虑：`一般来说，这类问题不会咬你除非你真的想创造混乱的数据结构和操作，但是你要小心，如果你定义你自己

valueof()

```js
var a = {
	valueOf: function() { return 42; },
	toString: function() { return 4; }
};

a + "";			// "42"

String( a );	// "4"
```

和`tostring()`方法对一些`对象`正如你如何强迫价值可能影响结果一样。`另一个方向呢？我们怎么能`隐式强制

从_一串_到`数`？`这个`—

```js
var a = "3.14";
var b = a - 0;

b; // 3.14
```

运算符仅定义用于数字减法，因此`一- 0`军队`一`被胁迫的价值`数`。虽然不太常见，`* 1`或`一/ 1`将完成相同的结果，因为这些运算符也仅定义为数字操作。`怎么样`对象

值与`—`运营商？类似的故事`+`以上：`两`阵列

```js
var a = [3];
var b = [1];

a - b; // 2
```

价值观必须成为`数`S，但他们最终是被迫的`串`（使用预期的`tostring()`序列化），然后被强制为`数`s，为`—`减法执行。`所以，是`隐性的

强制_一串_和`数`珍惜你经常听到的恐怖故事吧？我个人不这么认为。`比较`b =字符串（a）

（`明确的`）来_“+”_（`隐性的`）。我认为这两种方法在代码中都有用。当然_“+”_在js程序中相当常见，不管它如何证明它自己的实用性。`感情`关于优点或危害_实现_关于优点或危害_隐性的_一般胁迫。

### 隐式：布尔值——>号码

我想一个例子_隐性的_强制真的能使某些复杂的类型变得简单。`布尔`逻辑为简单的数字加法。当然，这不是一种通用技术，而是针对特定情况的特定解决方案。

考虑：

```js
function onlyOne(a,b,c) {
	return !!((a && !b && !c) ||
		(!a && b && !c) || (!a && !b && c));
}

var a = true;
var b = false;

onlyOne( a, b, b );	// true
onlyOne( b, a, b );	// true

onlyOne( a, b, a );	// false
```

这`一个（..）`实用程序只能返回`真正的`如果其中一个参数是`真正的`/真相。它的使用_隐性的_在一些检查和强迫_明确的_对其他人的胁迫，包括最后的返回值。

但是，如果我们需要该实用程序能够以同样的方式处理四、五或二十个标志呢？很难想象执行能够处理所有这些比较排列的代码。

不过这里看`布尔`价值观`数`S（`零`或`一`很明显）可以很大的帮助：

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		// skip falsy values. same as treating
		// them as 0's, but avoids NaN's.
		if (arguments[i]) {
			sum += arguments[i];
		}
	}
	return sum == 1;
}

var a = true;
var b = false;

onlyOne( b, a );		// true
onlyOne( b, a, b, b, b );	// true

onlyOne( b, b );		// false
onlyOne( b, a, b, b, b, a );	// false
```

**注：**当然，而不是`对于`环`一个（..）`，你可以更简洁地使用ES5`reduce(..)`实用，但我不想模糊概念。

我们在这里所做的是依靠`一`对于`真正的`/还是强制，数值加起来。`总和=参数[ i ]`使用_隐性的_强迫使之发生。如果一个和唯一一个值在`争论`列表`真正的`然后，数字和将是`一`否则总数就不会是`一`因此，所期望的条件没有得到满足。

我们当然可以这样做_明确的_强制代替：

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		sum += Number( !!arguments[i] );
	}
	return sum === 1;
}
```

我们首先使用`！[论据]`迫使价值的强制`真正的`或`假`。这样你就可以通过非—`布尔`值，例如`一个（42，0）`它仍然会像预期的那样工作。`一串`连接和逻辑是不正确的）。

一旦我们确定它是`布尔`我们做另一个_明确的_强制手段`数字（..）`确定值是`零`或`一`。

是的_明确的_这个工具的强制形式“更好”？它确实避免了`南`代码注释中的陷阱。但最终，这取决于你的需要。我个人认为前一版本，依靠_隐性的_胁迫是更优雅的（如果你不会通过）`未定义`或`南`）以及_明确的_版本不必要更冗长。

但正如我们在这里讨论的几乎所有事情一样，这是一个判断。

**注：**不管_隐性的_或_明确的_接近，你很容易做到`2（..）`或`五（..）`通过改变最后的比较来改变`一`，以`二`或`五`，分别。这比添加一大堆`&`和`| |`表达.一般来说，强制在这种情况下是非常有用的。

### 隐式地：\*

现在，让我们把注意力转向_隐性的_胁迫`布尔`价值观，因为它是迄今为止最常见的，也是迄今为止最具有潜在麻烦的。

记得,_隐性的_当你使用一个值迫使它转换时，强制就是其中的一部分。数字和`一串`操作，很容易看出的强制转换可以发生。

但是，操作需要什么类型的表达式/强制（_隐式_）一个`布尔`胁迫？

1.  中的测试表达式`如果（…）`声明。
2.  a中的测试表达式（第二子句）`为（。；..；..）`头。
3.  测试表达式`虽然（…）`和`当……时`环。
4.  测试表达式（第一项）`？：`三元表达式。
5.  左操作数（用作测试表达式）见下文！到`| |`（“逻辑”或“”）`&`（“逻辑”和“”运算符）。

在这些上下文中使用的值，该值尚未`布尔`将_隐式_强迫一个`布尔`使用的规则`布尔`本章前面所述的抽象操作。

让我们看一些例子：

```js
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
	console.log( "yep" );		// yep
}

while (c) {
	console.log( "nope, never runs" );
}

c = d ? a : b;
c;					// "abc"

if ((a && d) || c) {
	console.log( "yep" );		// yep
}
```

在所有这些上下文中，非—`布尔`值_隐式强制_他们的`布尔`作出测试决定的等价物。

### 运营商`| |`和`&`

很可能你已经看过了。`| |`（“逻辑”或“”）`&`（“逻辑”和“”）运算符在您使用的大多数或所有其他语言中。所以很自然地假设它们在JavaScript中的工作与其他类似语言基本相同。

这里有一些鲜为人知却很重要的细微差别。

事实上，我认为这些运营商甚至不应该被称为“逻辑\_\_\_算子”，那叫不完全描述他们做什么。如果我给他们一个更准确（如果更笨拙）的名字，我会叫他们“选择器操作符”，或者更完全地说，“操作数选择器操作符”。

为什么？因为它们实际上并没有导致_逻辑_价值（又名`布尔`）在JavaScript中，就像在其他语言中一样。

那又怎么样_做_结果是什么？它们导致两个操作数中的一个（只有一个）的值。换言之，**它们选择两个操作数中的一个值。**。

引用ES5规格从11.11节：

> 价值产生于与或| |运营商不一定是布尔类型。生成的值总是两个操作数表达式中的一个值。

让我们举例说明：

```js
var a = 42;
var b = "abc";
var c = null;

a || b;		// 42
a && b;		// "abc"

c || b;		// "abc"
c && b;		// null
```

**W**想想看。在像C和PHP这样的语言中，这些表达式导致`真正的`或`假`但在js（Python和Ruby，在这方面）！结果来自价值观本身。

两`| |`和`&`运营商执行`布尔`试验研究**第一个操作数**（`一`或`C`）。如果操作数还没有`布尔`（这不是，这里），正常的`布尔`强制发生，以便可以执行测试。

对于`| |`操作员，如果测试是`真正的`，的`| |`表达式的结果是_第一个操作数_（`一`或`C`）。如果测试是`假`，的`| |`表达式的结果是_第二个操作数_（`B`）。

相反，对于`&`操作员，如果测试是`真正的`，的`&`表达式的结果是_第二个操作数_（`B`）。如果测试是`假`，的`&`表达式的结果是_第一个操作数_（`一`或`C`）。

结果`| |`或`&`表达式总是一个操作数的底层值，**不**测试的（可能是强迫的）结果。在`中西医结合`，`C`是`无效的`，从而falsy。但`&`表达式本身导致`无效的`（值在`C`不是被迫的`假`用于测试。

你看到现在这些操作符是如何作为操作数选择器的吗？

关于这些操作符的另一种思考方式：

```js
a || b;
// roughly equivalent to:
a ? a : b;

a && b;
// roughly equivalent to:
a ? b : a;
```

**注：**我叫`一个| | B`大致相当于`一个吗？答：B`因为结果是相同的，但有细微差别。在`一个吗？答：B`，如果`一`是一个更复杂的表达式（比如说可能有副作用的表达式，比如调用a）。`功能`等等，然后`一`表达可能是评价两次（如果第一次评估真实性）。相比之下，`一个| | B`，的`一`表达式只被求值一次，该值同时用于强制测试和结果值（如果合适）。同样的细微差别也适用于`甲与乙`和`一个吗？B：一`表达.

这种行为的一个非常普遍和有用的用法，它有一个很好的机会，你可能会使用之前，并没有完全理解，是：

```js
function foo(a,b) {
	a = a || "hello";
	b = b || "world";

	console.log( a + " " + b );
}

foo();					// "hello world"
foo( "yeah", "yeah!" );	// "yeah yeah!"
```

这个`a一个| |“你好”`成语（有时称为JavaScript的版本的C #“null合并运算符”）行为测试`一`如果它没有价值（或只是一个意外的falsy值），提供了一个备份的默认值（`“你好”`）。

**小心**，虽然！

```js
foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

看到问题了吗？`“”`作为第二个参数是一个falsy值（见`布尔`在本章的前面），所以`B = B | |“世界”`测试失败，并且`“世界”`默认值被替换，尽管意图可能是显式传递。`“”`是分配给的值`B`。

这`| |`习语是非常普遍的，也是非常有用的，但是只有在这种情况下才能使用它。_所有的falsy值_应该跳过。否则，您将需要在测试中更加明确，并可能使用`？：`三元代替。

这_默认值分配_习语是如此普遍（有用）！即使那些公开强烈谴责JavaScript强制经常使用它自己的代码！

怎么样`&`？

还有一个成语，是一种不常用的手动撰写，但这是用JS minifiers频繁。这个`&`运营商的“选择”的第二个操作数当且仅当第一个操作数测试一些，这种用法有时被称为“护商”（参见“短路”5章）--第一个表达测试的“守卫”二表达：

```js
function foo() {
	console.log( a );
}

var a = 42;

a && foo(); // 42
```

`foo()`只因为`一`测试真实性。如果测试失败，则`一个与foo()`表达式语句会默默地停止——这就是所谓的“短路”——而且从不调用。`foo()`。

同样，写这种东西的人也几乎不常见。通常他们会这样做`如果（一）{ foo()；}`相反。但是，JS minifiers选择`一个与foo()`因为它短得多。所以，现在，如果你不得不破译这些代码，你就会知道它在做什么，为什么。

好的，所以`| |`和`&`只要你愿意，就有一些灵巧的技巧。_隐性的_胁迫混合。

**注：**两`A = B | |“东西”`和`一个与b()`习语依赖于短路行为，我们在第5章中更详细地介绍了它。

事实上，这些操作符实际上并没有导致`真正的`和`假`现在可能会把你的头弄得一团糟。你可能想知道你是怎么做到的`如果`报表和`对于`循环一直在工作，如果它们包含了复合逻辑表达式，比如`一个与（B | | C）`。

不必担心，天空没有坠落。你的代码（可能）很好。只是你可能从来没有意识到之前有一个_隐性的_胁迫`布尔`去**之后**对化合物的表达进行了评价。

考虑：

```js
var a = 42;
var b = null;
var c = "foo";

if (a && (b || c)) {
	console.log( "yep" );
}
```

这段代码仍然像你一直认为的那样工作，除了一个微妙的额外细节。这个`一个与（B | | C）`表达_事实上_结果`“foo”`，不`真正的`。因此，该`如果`陈述_然后_部队`“foo”`价值强制`布尔`这当然是`真正的`。

看到了吗？没有理由惊慌。您的代码可能仍然是安全的。但现在你更了解我

现在您也意识到这样的代码正在使用中。_隐性的_强制。如果你在“避免（隐含的）强迫阵营”中，你需要回去做所有这些测试。_明确的_：

```js
if (!!a && (!!b || !!c)) {
	console.log( "yep" );
}
```

祝你好运！…对不起，只是玩玩而已。

### 符号强制

到目前为止，几乎没有观察到的结果之间的差异。_明确的_和_隐性的_强制——只有代码的可读性受到威胁。

但6符号介绍了进入强制制度，我们需要简要探讨。原因远远超出我们在本书中讨论的范围，_明确的_强迫一个`符号`一个`一串`是允许的，但是_隐性的_相同的强制禁止，抛出一个错误。

考虑：

```js
var s1 = Symbol( "cool" );
String( s1 );					// "Symbol(cool)"

var s2 = Symbol( "not cool" );
s2 + "";						// TypeError
```

`符号`价值观不能强迫`数`不管怎样，都会出错，但奇怪的是两者都可以。_明确地_和_隐式_强迫`布尔`（总是`真正的`）。

一致性总是更容易学习，也没有乐趣去处理，但我们只需要围绕新6小心`符号`价值观和我们如何强迫他们。

好消息是：你可能需要强迫一个`符号`价值。他们通常使用的方式（见第3章）可能不会要求在正常的基础上强制。

## 松散等于等于严格

松等于`= =`运算符和严格相等是`= = =`算子。这两个操作符用于比较两个值为“相等”，但是“松”和“严格”表示一个**非常重要**两者之间的行为差异，特别是他们如何决定“平等”。

关于这两个运营商的一个非常普遍的误解是：`= =`检查相等的值和`= = =`检查值和类型是否相等。无数受人尊敬的JavaScript书籍和博客都这么说，但不幸的是它们都是。_错误的_。

正确的描述是：“`= =`允许在相等比较和`= = =`不允许强迫。”

### 平等的表现

停下来想想第一个（不准确）解释和第二个（准确）解释之间的区别。

在第一种解释中，似乎很明显`= = =`是_做更多的工作_比`= =`因为它必须_也_检查类型。在第二种解释中，`= =`是一个_做更多的工作_因为如果类型不同，则必须遵循强制步骤。

不要像许多人那样陷入陷阱，认为这与性能有关，不过，好像`= =`会慢于`= = =`以任何相关的方式。虽然胁迫是可以测量的_一点点_处理时间，那是微秒（是的，这是一个二！万分之二）。

如果比较相同类型的两个值，`= =`和`= = =`使用相同的算法，除了引擎实现中的细微差别外，它们应该做同样的工作。

如果比较不同类型的两个值，那么性能不是重要的因素。你应该问自己的是：当比较这两个值时，我是否需要强制？

如果你想要强迫，使用`= =`松散的相等，但如果您不想强制使用，请使用`= = =`严格的平等。

**注：**这里的含义是，两者都`= =`和`= = =`检查它们的操作数类型。不同之处在于，如果类型不匹配，它们将如何响应。

### 摘要平等

这个`= =`经营者的行为定义为“抽象的平等比较算法”对ES5的规格什么的上市有一个全面而简单的算法，明确规定每一种可能的组合类型部分11.9.3，以及如何强制（如果需要）应该为每个组合发生。

**警告：**当（_隐性的_）强制是诬蔑为太复杂的缺陷是_有用的好的部分_正是这些“抽象平等”的规则受到谴责。一般来说，他们说是过于复杂而不直观的开发商实际的学习和使用，并且他们比提高代码的可读性，更容易造成JS程序错误。我相信这是一个有缺陷的前提——读者是有能力编写（阅读和理解）的开发人员。算法（又名代码）一整天。因此，下面简单地描述了“抽象的平等”。但我恳求你也读ES5规格部分11.9.3。我想你会惊讶于它是多么的合理。

基本上，第一款（11.9.3.1）说，如果这两个值相比是同一类型的，他们是简单而自然地通过身份会比较。例如,`四十二`仅等于`四十二`，和`“ABC”`仅等于`“ABC”`。

对正常期望的一些微小的例外：

-   `南`永远不等于自己（见第2章）。
-   `+ 0`和`- 0`彼此平等（见第2章）

第11.9.3.1最终提供的是`= =`松散相等比较`对象`S（包括`功能`S和`阵列`S）。只有两个这样的值_平等的_如果他们都提到_完全相同的值_。这里没有强迫。

**注：**这个`= = =`严格的定义是相同的11.9.3.1相等的比较，包括两条款`对象`价值观。这是一个鲜为人知的事实。**`= =`和`= = =`相同的行为**在两个例子中`对象`S正在被比较！

在11.9.3其余算法的规定，如果你使用`= =`通过比较不同类型的两个值，可以得到一个或两个值。_隐式_强迫。这种强制发生，使两个值最终以相同的类型结束，然后可以直接使用简单的值一致性来比较相等。

**注：**这个`！=`松散不平等操作是完全按照您的期望定义的，因为它实际上是`= =`操作比较是整体的，然后是结果的否定。同样的道理也适用于`！= =`严格不平等操作。

#### 比较:`一串`S`数`S

说明`= =`胁迫，让我们首先建立`一串`和`数`本章前面的例子：

```js
var a = 42;
var b = "42";

a === b;	// false
a == b;		// true
```

正如我们所预料的，`a = b`失败，因为不允许强制，而且确实`四十二`和`“42”`价值观不同。

然而，第二比较`a = b`使用松散相等，这意味着如果类型不同，则比较算法将执行。_隐性的_对一个或两个值的强制。

但究竟是什么样的胁迫发生在这里？做`一`价值`四十二`成为一个`一串`或者是`B`价值`“42”`成为一个`数`？

在ES5规格、条款11.9.3.4-5说：

> 4.  如果类型（x）是数字和类型（y）是字符串，
> 5.  返回结果的比较x = =数字（Y）。

**如果type（x）是String，type（y）是数字，**返回数字的比较结果（x）= = Y。`警告：`规范使用`数`和`字符串`作为类型的正式名称，而这本书更喜欢`数`和`一串`对于原始类型。不要让资本化`数`在规格混淆你为

number()`原生功能。对于我们的目的来说，类型名的大写是不相关的——它们基本上是相同的意思。`很明显，说明书上说的是`“42”`值被强制为_数_为了比较。这个`怎样`这种胁迫以前已经被提到过了，特别是`第`摘要操作。在这种情况下，结果非常明显。

#### 四十二`值相等。`

相比之下：任何东西_布尔_其中一个最大的陷阱与`隐性的`强制`= =`当您尝试直接比较值时，会出现松散的相等。`真正的`或

假

```js
var a = "42";
var b = true;

a == b;	// false
```

。`考虑：`等等，这里发生什么事了？！我们知道`“42”`是一个真实性价值（见本章前面）。那么，为什么不是呢？`= =`松等于

真正的

？

> 6.  原因很简单，看似棘手的。很容易误解，很多js开发人员从来没有足够的关注去完全掌握它。
> 7.  让我们再次引用规范，条款11.9.3.6-7：

如果类型（x）是布尔型，

```js
var x = true;
var y = "42";

x == y; // false
```

返回数字的比较结果（x）= = Y。`如果Type（y）是布尔函数，`返回结果的比较x = =数字（Y）。`让我们把它打破。第一:`这个`类型（x）`的确是`布尔`所以它执行`第（x）`，胁迫`真正的`到`一`。现在,`1 =“42”`评价。类型也不同，所以（本质上是递归的）我们重新征求意见，就像上面的算法，将迫使`“42”`到`四十二`，和

1 = 42

```js
var x = "42";
var y = false;

x == y; // false
```

显然是`假`。`扭转它，我们仍然得到相同的结果：`这个`类型（y）`是`布尔`这一次，所以`ToNumber（Y）`产量`零`。`“42”＝0`递归成为

42 = 0**这当然是`假`。`换言之，`的价值`“42”`既不**= =真

也没有

`= =假`。`起初，这个声明可能看起来很疯狂。一个价值如何能既不真实性也不falsy？`但这就是问题所在！你问的问题完全错了。这不是你的错，真的吗？。你的大脑是骗你的。**“42”**的确是真相，但`“42”=真的`不执行布尔测试/强制。_总之，不管你的大脑怎么说。_“42”`是不是`被胁迫`布尔`（`真正的`但是，而不是`真正的`被强制为`一`，然后`“42”`被强迫

四十二`。`不管我们喜不喜欢，`布尔`甚至没有参与进来，所以事实或falsiness的`“42”`与…无关

= =_操作！_什么`是`相关的是了解如何`= =`比较算法的行为与所有不同类型的组合。因为它认为`布尔`两边的值`= =`，一个`布尔`总是强迫一个_数_第一

。`如果你觉得这很奇怪，你并不孤单。我个人建议在任何情况下都不要使用。`= =真`或`= =假

。曾经。`但是记住，我只是在说`= =`在这里.`=真`和`= false`不允许强制，所以他们从这个隐藏的安全`第

强制。

```js
var a = "42";

// bad (will fail!):
if (a == true) {
	// ..
}

// also bad (will fail!):
if (a === true) {
	// ..
}

// good enough (works implicitly):
if (a) {
	// ..
}

// better (works explicitly):
if (!!a) {
	// ..
}

// also great (works explicitly):
if (Boolean( a )) {
	// ..
}
```

考虑：`如果你避免使用`= =真`或`= =假`（亦称松散等式）`布尔

#### 在你的C中`无效的`S`未定义`S

另一个例子_隐性的_可以用`= =`宽松的平等之间的关系`无效的`和`未定义`价值观。再次引用ES5规格、条款11.9.3.2-3：

> 2.  如果x为null，y未定义，则返回true。
> 3.  如果x未定义，y为null，则返回true。

`无效的`和`未定义`相比之下`= =`松散的平等，等同于（强迫胁迫）彼此（显然是他们自己），在整个语言中没有其他价值观。

这意味着什么？`无效的`和`未定义`如果您使用的话，可以被视为无法比较的目的。`= =`允许它们相互作用的松散相等运算符_隐性的_强制。

```js
var a = null;
var b;

a == b;		// true
a == null;	// true
b == null;	// true

a == false;	// false
b == false;	// false
a == "";	// false
b == "";	// false
a == 0;		// false
b == 0;		// false
```

胁迫之间`无效的`和`未定义`是安全的和可预测的，并且没有其他的值能在这样的检查中给出假阳性。我建议使用这种强制措施允许`无效的`和`未定义`不可区分，因此被视为相同的价值。

例如:

```js
var a = doSomething();

if (a == null) {
	// ..
}
```

这个`a = null`支票只准通过`dosomething()`返回`无效的`或`未定义`，并将无法与任何其他值，甚至其他falsy价值`零`，`假`，和`“”`。

这个_明确的_检查的形式，它不允许任何强制，是（我认为）不必要的更难看（也许还有一点点不完整！）：

```js
var a = doSomething();

if (a === undefined || a === null) {
	// ..
}
```

在我看来，形式`a = null`又是另一个例子_隐性的_强制提高代码可读性，但以可靠的安全方式实现。

#### 比较:`对象`非非—`对象`S

如果一个`对象`/`功能`/`阵列`与简单标量原语进行比较。`一串`，`数`，或`布尔`），该条款11.9.3.8-9 ES5规格说：

> 8.  如果类型（x）是字符串或数字，类型（y）是对象，
> 9.  返回结果的比较x = = toprimitive（Y）。

**如果type（x）是对象，类型（y）是字符串或数字，**返回的结果比较toprimitive（x）= = Y。`注：`你可能会注意到这些条款只提到`字符串`和`数`，但不`布尔`。这是因为，正如之前引用条款11.9.3.6-7照顾强迫任何`布尔`提交给a的操作数

数

```js
var a = 42;
var b = [ 42 ];

a == b;	// true
```

第一.`考虑：`这个`[ 42 ]`价值的`toprimitive`调用了抽象操作（参见“抽象值操作”一节），这导致`“42”`价值。从那里，它只是`42 =“42”`正如我们已经涵盖的那样`42 = 42`，所以`一`和

**B**被强制的平等。`提示：`所有的怪癖`toprimitive`我们在本章前面讨论的抽象操作（`tostring()`，`valueof()`请按照您的期望应用于此。如果您想定义一个复杂的数据结构，那么这将非常有用。

valueof()`方法，为相等比较目的提供简单值。`在3章中，我们覆盖的“拆箱，”其中一个`对象`包装器围绕一个原始值（如从`新字符串（“ABC”）`例如，）被解包，底层的原始值（`“ABC”`）返回。这种行为与`toprimitive`强制的

```js
var a = "abc";
var b = Object( a );	// same as `new String( a )`

a === b;				// false
a == b;					// true
```

`= =`算法:`a = b`是`真正的`因为`B`被胁迫（又名“拆箱，通过“打开）`toprimitive`它背后的`“ABC”`简单标量原始值，其值与

一`。`但是，有一些值在这种情况下并非如此，因为

```js
var a = null;
var b = Object( a );	// same as `Object()`
a == b;					// false

var c = undefined;
var d = Object( c );	// same as `Object()`
c == d;					// false

var e = NaN;
var f = Object( e );	// same as `new Number( e )`
e == f;					// false
```

= =`算法.考虑：`这个`无效的`和`未定义`值不能装箱——它们没有对象包装器等价物——所以`对象（null）`就像

`object()`在这两者中只产生一个普通对象。`南`可以盒装到它的`数`对象包装器等效，但当`= =`拆箱的原因，`南=南`比较失败的原因

### 南

永远不等于自己（见第2章）。_边缘情况_现在我们已经彻底检查了`隐性的`强制

= =

#### 宽松平等的作品（在合理的和令人惊讶的方式），让我们试着打坏，疯狂的案例，我们可以看到我们需要避免不被强迫的错误。

```js
Number.prototype.valueOf = function() {
	return 3;
};

new Number( 2 ) == 3;	// true
```

**首先，让我们研究如何修改内置的本机原型可以产生疯狂的结果：**任何其他值的数字都会…`警告：`2 = 3`不会掉进这个陷阱，因为两者都不会。`二`也没有`三`将调用内置的`valueof()数。原型。`方法，因为它们都已经是原始的。`数`值，可以直接比较。然而,`新号码（2）`必须通过`toprimitive`胁迫，从而调用`valueof()

。_邪恶，嗯？当然是。任何人都不应该做这样的事。你这个事实_可以`这种做法有时被用作对胁迫的批评吗？`= =_。但这是误导的挫折。JavaScript不是_坏的_因为你可以做这样的事情，开发人员_坏的**如果他们这样做**。不要陷入“我的编程语言应该保护我自己”的谬论。

接下来，让我们考虑另一个狡猾的示例，它将前一示例中的恶带到另一个级别：

```js
if (a == 2 && a == 3) {
	// ..
}
```

你可能认为这是不可能的，因为`一`永远不能等同于两者`二`和`三`同时_。但是“在_。但是“同时”是不准确的，因为第一个表达式`a＝2`发生严_之前_a＝3`。`那么，如果我们做

A. valueof()`每次调用时都有副作用，所以第一次返回时会有副作用。`二`第二次叫它回来。`三`？很容易：`再说一遍，这些都是邪恶的把戏。不要这样做。但也不要把它们当作对胁迫的控诉。潜在的滥用机制并不是充分谴责这种机制的证据。只要避免这些疯狂的把戏，只坚持有效和恰当的强制手段。

```js
var i = 2;

Number.prototype.valueOf = function() {
	return i++;
};

var a = new Number( 42 );

if (a == 2 && a == 3) {
	console.log( "Yep, this happened." );
}
```

false-y比较

#### 最常见的投诉

隐性的_强制_= =`比较来自于falsy值表现令人惊讶的是当相互比较。`例如，我们在名单的角落都falsy值比较一下，看看哪些是合理的，这是麻烦：

在这24个比较表中，有17个比较合理和可预测。例如，我们知道

```js
"0" == null;			// false
"0" == undefined;		// false
"0" == false;			// true -- UH OH!
"0" == NaN;				// false
"0" == 0;				// true
"0" == "";				// false

false == null;			// false
false == undefined;		// false
false == NaN;			// false
false == 0;				// true -- UH OH!
false == "";			// true -- UH OH!
false == [];			// true -- UH OH!
false == {};			// false

"" == null;				// false
"" == undefined;		// false
"" == NaN;				// false
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
"" == {};				// false

0 == null;				// false
0 == undefined;			// false
0 == NaN;				// false
0 == [];				// true -- UH OH!
0 == {};				// false
```

“”`和`南`在所有合理的价值都没有，而且他们不强迫是宽松平等的，而`“0”`和`零`是合理的，合理的`做_胁迫等于。_然而，七的比较都标有“哦，哦！”因为误报，他们更可能会把你绊倒的陷阱。

“”`和`零`绝对是完全不同的价值观，这是罕见的你想把他们视为合理的，所以他们的相互压制麻烦。注意这里没有任何假阴性。`疯子

#### 不过我们不必停在那里。我们可以继续寻找更麻烦的强制：

哦，这似乎是在一个更高层次的疯狂，权！？你的大脑可能欺骗你，你还是一个比较falsy值，所以

```js
[] == ![];		// true
```

真正的`结果是令人惊讶的，因为我们`知道_一个价值不可同时还是和falsy！_但事实并非如此。让我们把它分解。关于这个我们知道些什么？

！`一元运算符？它明确地强迫一个`布尔`使用`布尔`规则（它也会翻转奇偶校验）。所以之前`\[ =！\[ ]`甚至处理，实际上已经翻译成`\[] = false`。我们已经在上面的列表中看到了这个表单。`false = \[ \[] ]`所以它的惊喜结果是`不是新的_我们。_其他街角的案子呢？

As we said earlier in our

```js
2 == [2];		// true
"" == [null];	// true
```

第`讨论，右手边`\[ 2 ]`和`\[空]`价值观将通过`toprimitive`强制使它们更容易与简单原语相比较（`二`和`“”`（分别）在左手边。自`valueof()`对于`阵列`值只是返回`阵列`本身，胁迫下的stringifying`阵列`。`\[ 2 ]

`将成为`“2”`那就是`第`强迫`二`对于第一比较中的右手边值。`\[空]`直接成为`“”`。`所以，

2 = 2`和`“”“=”`完全可以理解。`如果你的直觉是仍然不喜欢这些结果，你的挫折感并不是像你可能认为的那样。这实际上是对违约的控诉。

阵列`价值观`toprimitive`强迫一个行为`一串`价值。更可能的是，你只是希望`\[ 2 ]。tostring()`没有回报`“2”`，或`\[空]。tostring()`没有回报`“”`。`但究竟是什么

应该_这些_一串`强制转换的结果吗？我真的想不出其他合适的了。`一串`强制`\[ 2 ]`比`“2”`也许，除了`“\[ 2 ]`但在其他情况下这可能很奇怪！`你可以正确地说明

字符串（NULL）`成为`“空”`，然后`字符串（\[空]）`也应该成为`“空”`。这是一个合理的断言。所以，那才是真正的罪犯。`隐性的

_胁迫本身不是这里的邪恶。即使是一个_明确的_强制_\[空]`一个`一串`结果`“”`。不确定的是它是否明智。`阵列`价值观的内容stringify等效，到底这是怎么发生的。所以，你要对规则感到沮丧。`字符串（\[…]）`因为那是疯狂的来源。也许应该没有字符串化所带来的威胁`阵列`真的吗？但是，就在语言的其他部分其他缺点很多。`另一个著名的引用问题：

正如我们前面所讨论的，空的

```js
0 == "\n";		// true
```

“”`，`“n”`（或`“”`或任何其他空格组合）是被迫通过`第`结果是`零`。其他的什么`数`你期望的空白来要挟的价值吗？你是否感到烦恼？`明确的_数字（“”）_产量`零`？`真的是唯一合理的`数

空字符串或空白字符串可以强迫值是`南`。但那会`真正地`会更好吗？比较_“”= =_当然会失败，但不清楚我们是否真的会失败。`固定的`任何潜在的担忧。_现实世界js程序失败的可能性是因为_0 =“n”

非常罕见，这样的角案很容易避免。`类型转换`总是

在任何语言中都有死角，没有强迫的具体内容。这里的问题是**总是**在任何语言中都有死角，没有强迫的具体内容。这里的问题是猜测一组角的情况（也许是正确的）！但是，这并不是反对整体强制机制的一个突出论点。

底线：几乎任何疯狂的胁迫之间_正常值_你可能会遇到（除了有意的狡猾）`valueof()`或`tostring()`黑客早）将归结为疑难杂症强制我们上述的七项短名单。

对比对这24个可能的嫌疑人胁迫问题，考虑另一个像这样的名单：

```js
42 == "43";							// false
"foo" == 42;						// false
"true" == true;						// false

42 == "42";							// true
"foo" == [ "foo" ];					// true
```

在这些nonfalsy，noncorner例（和字面上有无限数量的比较，我们可以把这个列表），强制的结果是完全安全的，合理的，并解释。

#### 完整性检查

好吧，当我们深入研究的时候，我们肯定发现了一些疯狂的东西。_隐性的_强制。难怪大多数开发商声称强制是邪恶的，应该避免，对吗？！？

但是让我们后退一步，做一个健康检查。

通过大小比较，我们有_一个列表_七麻烦了强制，但我们有_另一个列表_的（至少17，但实际上是无限的）强制，完全清醒和解释。

如果你正在寻找一个教科书“把婴儿连同洗澡水一起倒掉，“这就是：丢弃强迫整体（安全行为）和有用的无限大名单，因为名单真的只是七的陷阱。

更谨慎的反应是：“我如何使用无数？_好的部分_胁迫，但避免少数_坏的部分_？”

让我们再看看_坏的_列表：

```js
"0" == false;			// true -- UH OH!
false == 0;				// true -- UH OH!
false == "";			// true -- UH OH!
false == [];			// true -- UH OH!
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
0 == [];				// true -- UH OH!
```

清单上七项中的四项涉及`= =假`比较，我们前面说过，你应该**永远，永远**避免。这是一个很容易记住的规则。

现在名单下降到三个。

```js
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
0 == [];				// true -- UH OH!
```

这些是合理的强制你做在一个正常的JavaScript程序吗？他们在什么情况下真的会发生？

我不认为你真的会使用它。`= [ [] ]`在一个`布尔`在你的程序中测试，至少不知道你在做什么。你可能会这样做`=“”`或`= = 0`，像：

```js
function doSomething(a) {
	if (a == "") {
		// ..
	}
}
```

如果你不小心叫有啊`做（0）`或`做（[ ]）`。另一个场景：

```js
function doSomething(a,b) {
	if (a == b) {
		// ..
	}
}
```

同样，如果你做了类似的事情，这可能会崩溃。`（“做”，0）`或`做（[ ]，”）`。

所以，尽管情况_可以_存在这些强制会咬你，你就要小心周围的人，他们可能不是超级常见的对您的代码库的整体。

#### 安全地使用隐性强制

我能给你的最重要的建议是：检查你的程序和关于什么值可以出现在A的两边的原因。`= =`比较。为了有效避免这种比较的问题，以下是一些启发式规则：

1.  如果比较的任何一方都可以`真正的`或`假`价值观，永远不要使用`= =`。
2.  如果比较的任何一方都可以`[ ]`，`“”`，或`零`价值观，认真考虑不使用`= =`。

在这些场景中，使用`= = =`而不是`= =`为了避免不必要的胁迫。遵循这两个简单的规则，几乎所有的强制陷阱，可以合理地将有效地避免伤害你。

**在这些情况下，更明确/详细的话可以帮你避免很多麻烦。**

的问题`= =`vs.`= = =`是否真的被适当地框为：是否允许强制比较？

有很多情况下，这种强制是有益的，让你更加简洁地表达一些比较逻辑（如`无效的`和`未定义`例如）。

在总体方案中，相对较少的情况下_隐性的_胁迫确实是危险的。但在那些地方，为了安全起见，一定要使用。`= = =`。

**提示：**另一个受到胁迫的地方_不_咬你是与`类型`算子。`类型`总是返回七个字符串中的一个（参见第1章），没有一个是空的。`“”`字符串。因此，没有的情况下，检查一些值的类型要触犯_隐性的_强制。`类型= =“功能”`100%是否安全可靠？`类型= = =“功能”`。从字面上看，规范说算法在这种情况下是相同的。所以，不要盲目地使用`= = =`到处都是因为那是你的代码工具告诉你做的，或者（最糟糕的），因为你在某本书中被告知**不去想它**。您拥有代码的质量。

是_隐性的_胁迫邪恶和危险？在少数情况下，是的，但绝大多数情况下，没有。

做一个负责任、成熟的开发人员。学习如何使用强制的力量（两者都是）_明确的_和_隐性的_）安全有效。并且教你周围的人做同样的事情。

这是一种简便的表由Alex Dorey（@多雷在GitHub）设想的各种比较：

<img src="fig1.png" width="600">

源：[https://github.com/dorey/javascript-equality-table](https://github.com/dorey/JavaScript-Equality-Table)

## 摘要关系比较

虽然这部分_隐性的_强迫经常G`< B`比较（类似于我们刚刚检查过的`a = b`深入地）。

在第11.8.5 ES5的“抽象关系”的比较算法基本上分为两部分：做什么如果比较涉及`一串`值（下半部分）或其他（上半部分）。

**注：**该算法仅定义为`< B`。所以，`一> B`是处理`B＜`。

算法首先调用`toprimitive`对两个值进行强制，如果两个调用的返回结果都不是`一串`然后，两个值都被强制`数`值的使用`第`运算规则，并进行数值比较。

例如:

```js
var a = [ 42 ];
var b = [ "43" ];

a < b;	// true
b < a;	// false
```

**注：**类似的告诫`- 0`和`南`应用在这里，因为他们在`= =`前面讨论的算法。

但是，如果两个值都是`一串`对于`<`比较简单的字典（自然拼音）上进行特征比较：

```js
var a = [ "42" ];
var b = [ "043" ];

a < b;	// false
```

`一`和`B`是_不_强迫`数`S，因为它们最终都是`一串`后`toprimitive`胁迫两人`阵列`所以，`“42”`按字符比较`“043”`从第一个字符开始`“4”`和`“0”`，分别。自`“0”`在字典序_小于_比`“4”`比较返回`假`。

同样的行为和推理也适用于：

```js
var a = [ 4, 2 ];
var b = [ 0, 4, 3 ];

a < b;	// false
```

在这里,`一`成为`“4”`和`B`成为`“0,4,3”`，和那些字典比较与以前的片段。

怎么样：

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// ??
```

`< B`是也`假`，因为`一`成为`[对象]`和`B`成为`[对象]`如此清楚`一`不是字典序小于`B`。

但奇怪的是：

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// false
a == b;	// false
a > b;	// false

a <= b;	// true
a >= b;	// true
```

为什么`a = b`不`真正的`？它们是一样的。`一串`价值（`“[对象对象]`）看来它们应该相等，对吧？不.回想先前关于如何进行的讨论`= =`作品`对象`引用。

但那怎么会呢？`a = b`和`a = b`导致`真正的`，如果`< B`和**a = b**和`一> B`都是**假**？`因为规格说明`a = b`它实际上会评估`B＜

首先，然后否定这个结果。自`B＜`是`也`假`, the result of`a = b_是_真正的`。`这很可能与你可能解释的相反。`< =`直到现在，这可能是字面上的：“小于`或`等于“JS更准确地考虑

&lt; =`“不大于”`！（a）_，js将其视为_！（b &lt;）`）。此外，`a = b`首先解释为`b =`然后应用同样的推理。`不幸的是，没有“严格的关系比较”，因为这是平等的。换句话说，没有办法阻止。`隐性的`用关系比较产生的强制`< B`除了确保

一_和_B`在进行比较之前，都是同类型的。`用我们早先的推理`= =`vs.`= = =`理智检查讨论。如果强制是有益的和相当安全的，例如

42 &lt; &lt; 43 >`比较，`使用它`。另一方面，如果您需要对关系比较安全，`明确强制`值在使用前先`&lt;**（或其对应者）。**回顾_在本章中，我们将注意力转向JavaScript类型转换是如何发生的，称为_强制`，其特征可以是`明确的

```js
var a = [ 42 ];
var b = "043";

a < b;						// false -- string comparison!
Number( a ) < Number( b );	// true -- number comparison!
```

## 或

隐性的**。**胁迫会受到不良影响，但实际上它在很多情况下非常有用。负责任的js开发人员的一个重要任务是花时间去学习所有的胁迫的来龙去脉，以决定哪些部分有助于改进代码，哪些部分是他们真正应该避免的。_明确的_强制是代码，很明显其意图是将值从一种类型转换为另一种类型。好处是通过减少混淆来提高代码的可读性和可维护性。_隐性的_强制是作为其他操作的副作用“隐藏”的强制，在这种情况下不会出现类型转换。虽然似乎是

隐性的

_胁迫是相反的。_明确的

_因此，这是糟糕的（事实上，很多人都这么认为！）实际上，_隐性的_强制也是提高代码可读性的方法。_尤其是_隐性的_胁迫必须有责任地、有意识地使用。知道你为什么要写你正在写的代码，以及它是如何工作的。努力编写别人容易学习和理解的代码。_隐性的_强制也是提高代码可读性的方法。

尤其是_隐性的_胁迫必须有责任地、有意识地使用。知道你为什么要写你正在写的代码，以及它是如何工作的。努力编写别人容易学习和理解的代码。
