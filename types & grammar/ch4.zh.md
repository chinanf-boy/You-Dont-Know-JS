
# 你不知道JS: 类型和语法

# 第4章胁迫

既然我们更全面地理解了JavaScript的类型和价值,我们将注意力转向一个非常有争议的话题: 强制ㄢ

正如我们在第1章提到的,关于强迫是一个有用的特征还是语言设计中的缺陷(或者两者之间的某个地方)的争论ㄢ自第一天就开始肆虐ㄢ如果你读过其他流行的关于JS的书,你知道那是非常流行的ㄢ_消息_这种强制是魔法的,邪恶的,混乱的,而且完全是个坏主意ㄢ

在这本书系列的总的精神上,与其因为其他人所做的那样逃避胁迫,或者因为你被某些怪癖所咬,我认为你应该朝你不理解并寻求的方向前进ㄢ_了解了_more fully.

我们的目标是充分探索利弊(是的,有)_是_赞成!)强迫性的,以便你能在程序中对它的适当性作出明智的决定ㄢ

## 转换价值

将值从一种类型转换为另一种类型时,通常称为"类型转换ℽ,当显式地执行时,"隐式ℽ(当使用值的规则强制)时,就强制执行"强制ℽㄢ

**注: **它可能不是很明显,但JavaScript强制总是导致一种标量原始(见2章)的值,如`一串`,`数`,或`布尔`ㄢ没有强制产生复杂的值,比如`对象`或`功能`ㄢ第3章介绍了"装箱ℽ,它将标量原始值包装在`对象`但这并不是精确意义上的强迫ㄢ

这些术语通常区分的另一种方式如下: "类型转换ℽ(或"类型转换ℽ)在编译时在静态类型语言中发生,而"类型强制ℽ是动态类型语言的运行时转换ㄢ

然而,在JavaScript中,大多数人将所有这些类型的转换引用为_强制_所以,我比较喜欢区分"隐性强迫ℽ和"明显强迫ℽㄢ

区别应该很明显: "显式强制ℽ是指从类型转换中故意发生的代码中明显看出的情况,而"隐式强制ℽ是当类型转换发生在其他有意操作的不明显的副作用时ㄢ

例如,考虑这两种方法来强制: 

```js
var a = 42;

var b = a + "";			// implicit coercion

var c = String( a );	// explicit coercion
```

对于`B`发生的强制是隐式发生的,因为`+`运算符与其中一个操作数组合在一起的`一串`价值(`"ℽ`将坚持经营是一个`一串`串联(将两个字符串相加)_作为一种(隐藏的)副作用_将力`四十二`价值`一`被迫`一串`等效: `"42ℽ`ㄢ

相比之下,`字符串(..)`函数很明显地表示它显式地引用`一`并强迫它去`一串`表示ㄢ

这两种方法都达到了同样的效果: `"42ℽ`来自`四十二`ㄢ但这是_怎样_这是关于JavaScript强制的激烈争论的核心ㄢ

**注: **从技术上讲,除了文体差异之外,还有一些细微的行为差异ㄢ我们将在本章后面更详细地讨论这一点,在"隐式: 字符串&lt;数字ℽ部分ㄢ

术语"显式ℽ和"隐式ℽㄡ"明显ℽ和"隐藏的副作用ℽ是_相对的_ㄢ

如果你确切知道什么`"+ℽ`是做的,而你是故意这样做的`一串`你可能会觉得手术足够"明确ℽ,反之,如果你从未见过`字符串(..)`函数用于`一串`胁迫,它的行为似乎隐藏得足够让你感到"含蓄ℽㄢ

但是我们正在讨论"明确的ℽ和"隐含的ℽ,基于一个_平均,合理的通知,但不是专家或者JS规范信徒_开发商.无论你做了什么或没有发现自己完全适应了那个桶,你将需要根据我们的观察来调整你的观点ㄢ

请记住: 我们编写代码是非常罕见的,而且是唯一读过它的代码ㄢ即使你是JS所有细节的专家,也要考虑一个经验不足的队友在阅读你的代码时会有什么感受ㄢ对你来说,它是"明确的ℽ还是"含蓄的ℽ?

## 摘要值操作

在我们探索之前_明确的_VS_隐性的_强迫,我们需要学习支配价值的基本规则ㄢ_成为_任何一个`一串`,`数`,或`布尔`ㄢ在9节中的ES5规范定义了几个"抽象操作ℽ(花式规格说"内部操作ℽ)与价值转换规则ㄢ我们会特别注意: `ToString`,`第`,和`布尔`在较小程度上,`toprimitive`ㄢ

### `ToString`

当任何非ℴ`一串`值被强制为`一串`表示,转换由`ToString`规范第9.8节中的抽象操作ㄢ

建立在原始自然字符串化所带来的价值: `无效的`成为`"空ℽ`,`未定义`成为`"未定义ℽ`和`真正的`成为`"真正的ℽ`ㄢ`数`s一般以你期望的自然方式表达,但正如我们在第2章中讨论的,非常小或非常大ㄢ`数`以指数形式表示: 

```js
// multiplying `1.07` by `1000`, seven times over
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// seven times three digits => 21 digits
a.toString(); // "1.07e21"
```

对于常规对象,除非指定自己的默认值ㄢ`tostring()`(位于`对象,tostring()原型ㄢ`将返回_内部的`[阶级]`_(参见第3章),例如`"[对象对象]`ㄢ

但如前所示,如果一个对象有它自己的`tostring()`方法,然后在`一串`类似的方式,它的`tostring()`将自动被调用,并且`一串`将使用该调用的结果ㄢ

**注: **对象被强制为A的方式`一串`技术上经过`toprimitive`抽象操作(ES5的规格,9.1节),但那些微妙的细节中有更详细的介绍的`第`本章后面的部分,我们将在这里跳过它们ㄢ

数组具有重写默认值ㄢ`tostring()`这stringifies为(字符串)的所有值串联(每个字符化本身),与`",ℽ`在每个值之间: 

```js
var a = [1,2,3];

a.toString(); // "1,2,3"
```

再一次,`tostring()`可以显式调用,也可以非自动调用ℴ`一串`用于`一串`语境ㄢ

#### JSON字符串化所带来的

另一项似乎非常相关的任务`ToString`当你使用`JSONㄢstringify(..)`实用价值的JSON序列化兼容`一串`价值ㄢ

注意,这个字符串化所带来的是不完全一样的东西,强迫是很重要的ㄢ但因为它与`ToString`以上规则,我们将在这里盖JSON字符串化所带来的轻微的转移行为ㄢ

最简单的JSON字符串化所带来的价值观ㄡ行为基本相同`tostring()`转换,但序列化结果为_总是一个`一串`_: 

```js
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" (a string with a quoted string value in it)
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

任何_JSON安全_值可以是字符串化的`JSONㄢstringify(..)`ㄢ但什么是_JSON安全_?可以在JSON表示中有效地表示的任何值ㄢ

考虑值是比较容易的ㄢ**不**JSON安全ㄢ一些例子: `未定义`S,`功能`S,(6 +)`符号`S,和`对象`s循环引用(其中对象结构中的属性引用创建了一个相互循环的循环)ㄢ这些都是标准JSON结构的非法值,主要是因为它们不适合使用JSON值的其他语言ㄢ

这个`JSONㄢstringify(..)`实用程序将自动省略`未定义`,`功能`,和`符号`价值观ㄢ如果在一个`阵列`该值被替换为`无效的`(这样数组位置信息不会改变)ㄢ如果作为一个属性发现`对象`那财产将被排除在外ㄢ

考虑: 

```js
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}"
```

但是如果你尝试`JSONㄢstringify(..)`一个`对象`在循环引用中,会抛出一个错误ㄢ

JSON字符串化所带来的特殊的行为,如果一个`对象`价值有一个`tojson()`方法定义后,将首先调用此方法以获得用于序列化的值ㄢ

如果你打算stringify JSON对象可能包含非法JSON值(S),或者如果你在才有价值`对象`不适合序列化,应该定义一个`tojson()`返回a的方法_JSON安全_版本的`对象`ㄢ

例如:

```js
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// create a circular reference inside `a`
o.e = a;

// would throw an error on the circular reference
// JSON.stringify( a );

// define a custom JSON value serialization
a.toJSON = function() {
	// only include the `b` property for serialization
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

这是一个很常见的误解ㄢ`tojson()`应该返回一个JSON字符串化所带来的表示ㄢ这可能是不正确的,除非你真的想stringify`一串`本身(通常不是!)ㄢ`tojson()`应该返回适当的实际规则值(任何类型),以及`JSONㄢstringify(..)`它将处理字符串化所带来的ㄢ

换言之,`tojson()`应该解释为"一种适用于JSON字符串化所带来的安全价值,ℽ而不是"一个JSON字符串ℽ,许多开发商误以为ㄢ

考虑: 

```js
var a = {
	val: [1,2,3],

	// probably correct!
	toJSON: function(){
		return this.val.slice( 1 );
	}
};

var b = {
	val: [1,2,3],

	// probably incorrect!
	toJSON: function(){
		return "[" +
			this.val.slice( 1 ).join() +
		"]";
	}
};

JSON.stringify( a ); // "[2,3]"

JSON.stringify( b ); // ""[2,3]""
```

第二呼叫,我们返回的字符串化`一串`而不是`阵列`本身,这可能不是我们想做的事ㄢ

当我们谈论`JSONㄢstringify(..)`让我们来讨论一些不太为人所知的功能,这些功能仍然非常有用ㄢ

可选的第二个参数可以传递给`JSONㄢstringify(..)`这被称为_替代品_ㄢ这个论点可以是`阵列`或`功能`ㄢ它用于自定义一个`对象`通过提供一种过滤机制,使其属性应该和不应该包含,方法类似于`tojson()`可以为序列化准备一个值ㄢ

如果_替代品_是一个`阵列`应该是`阵列`属于`一串`s,每一个都将指定一个属性名,允许在序列化中包含`对象`ㄢ如果不存在此列表中的属性,则将跳过该属性ㄢ

如果_替代品_是一个`功能`它将被调用一次ㄢ`对象`本身,然后一次为每一个属性`对象`并且每次都传递两个参数,_钥匙_和_价值_ㄢ跳过_钥匙_在序列化中,返回`未定义`ㄢ否则,返回_价值_提供ㄢ

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"

JSON.stringify( a, function(k,v){
	if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
```

**注: **在`功能` _替代品_CA`K`是`未定义`第一次打电话(在那里)`一`对象本身正在传入)ㄢ这个`如果`陈述**滤出**命名属性`"Cℽ`ㄢ字符串化所带来的是递归的,所以`[1,2,3]`数组具有它的每个值(`一`,`二`,和`三`)过去了`v`到_替代品_用索引(`零`,`一`,和`二`)为`K`ㄢ

第三个可选参数也可以传递给`JSONㄢstringify(..)`,称为_空间_它用作缩进以获得更美观的人性化输出ㄢ_空间_可以是一个正整数,表示每个缩进级别应该使用多少空格字符ㄢ或,_空间_可以是一个`一串`在这种情况下,其值的前十个字符将用于每个缩进级别ㄢ

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, null, 3 );
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

记得,`JSONㄢstringify(..)`不是直接的胁迫形式ㄢ然而,我们在这里介绍了两个原因,将其行为与`ToString`强制: 

1.  `一串`,`数`,`布尔`,和`无效的`所有stringify JSON值基本相同如何强迫`一串`通过规则的值`ToString`摘要操作ㄢ
2.  如果你通过`对象`价值`JSONㄢstringify(..)`,,,`对象`有一个`tojson()`方法,`tojson()`自动调用(排序)"强制ℽ值ㄢ_JSON安全_在字符串化所带来的ㄢ

### `第`

如果有非ℴ`数`值的使用方式要求它是`数`,如数学运算的ES5规格定义`第`第9.3节中的抽象操作ㄢ

例如,`真正的`成为`一`和`假`成为`零`ㄢ`未定义`成为`南`(但奇怪的是)`无效的`成为`零`ㄢ

`第`对于一个`一串`数值基本上与数字文本的规则/语法一样有效(参见第3章)ㄢ如果失败,结果是`南`(而不是语法错误)`数`文字)ㄢ一个不同的例子是`零`前缀八进制数处理不作为octals(就像正常的10十进制)在这次行动中,虽然这样的octals是有效的`数`文字(见第2章)ㄢ

**注: **之间的差异`数`文字和语法`第`在一个`一串`价值是微妙的和高度微妙的,因此不会在这里进一步介绍ㄢ参照第9.3.1的ES5规格的更多信息ㄢ

对象(和数组)首先将转换为它们的原始等价的值,并生成结果值(如果是原始的,但还没有`数`)被强制为`数`根据`第`刚才提到的规则ㄢ

若要转换为此原始值等效,则`toprimitive`抽象操作(ES5的规格,9.1节)将参考值(使用内部`默认值`操作-- ES5的规格,截面8.12.8)问题是否有`valueof()`方法ㄢ如果`valueof()`是可用的,它返回一个原始值,_那个_值用于强制ㄢ如果没有,但`tostring()`是可用的,它将为强制值提供价值ㄢ

如果两个操作都不能提供原始值,则`TypeError`抛出ㄢ

由于ES5,您可以创建这样一个noncoercible对象--一个没有`valueof()`和`tostring()`ℴℴ如果它有`无效的`对于它的价值`[原型]`,通常用`对象创建(null)`ㄢ看到_对象原型_本系列的标题,了解更多信息`[原型]`S.

**注: **我们讨论如何强制`数`s在本章后面的细节中,但是对于下一个代码片段,只需假设`数字(..)`函数是这样的ㄢ

考虑: 

```js
var a = {
	valueOf: function(){
		return "42";
	}
};

var b = {
	toString: function(){
		return "42";
	}
};

var c = [4,2];
c.toString = function(){
	return this.join( "" );	// "42"
};

Number( a );			// 42
Number( b );			// 42
Number( c );			// 42
Number( "" );			// 0
Number( [] );			// 0
Number( [ "abc" ] );	// NaN
```

### `布尔`

接下来,让我们聊一聊`布尔`js的行为ㄢ有**许多困惑和误解**围绕这个话题漂浮着,所以要密切关注!

首先,js有实际关键字`真正的`和`假`他们的行为完全符合你的期望ㄢ`布尔`价值观ㄢ人们普遍认为这些价值观是错误的ㄢ`一`和`零`是相同的`真正的`/`假`ㄢ虽然在其他语言中可能是这样的,但在js中`数`S`数`S和`布尔`S`布尔`你可以胁迫`一`到`真正的`(反之亦然)或`零`到`假`(反之亦然)ㄢ但它们不一样ㄢ

#### falsy值

但故事还没有结束ㄢ我们需要讨论二者的价值观ㄢ`布尔`你胁迫的时候要表现出来_到_他们的`布尔`等效ㄢ

所有JavaScript的值可以分为两类: 

1.  将成为的价值观`假`如果强迫`布尔`
2.  其他一切(显然会变成)`真正的`)

我不是在开玩笑ㄢjs规范定义了一个特定的ㄡ狭窄的值列表,它将强制`假`胁迫时`布尔`价值ㄢ

我们如何知道值列表是什么?在ES5的规格,9.2节的定义`布尔`抽象操作,它精确地表示当你试图强迫它们"布尔ℽ时,所有可能的值会发生什么ㄢ

从表中,我们可以得到下面的所谓"falsy"值列表: 

-   `未定义`
-   `无效的`
-   `假`
-   `+ 0`,`- 0`,和`南`
-   `"ℽ`

够了就要这些ㄢ如果一个值是在名单上,这是一个"falsyℽ值,它将强迫`假`如果你强迫某人`布尔`胁迫它ㄢ

的逻_不_在那个名单上,它必须在_另一个列表_,我们称之为"真相ℽ的价值观清单ㄢ但JS无法定义"真相ℽ列表本身ㄢ它给出了一些例子,如明确的话,所有的对象都是真相,但大多只是意味着规格: **没有明确的falsy列表因此真相ㄢ**

#### falsy对象

等一下,那一节标题听起来甚至矛盾ㄢ我真的_只是说_规范要求所有对象的真实性,对吗?应该没有这样的东西作为一个"falsy对象ㄢℽ

这可能意味着什么呢?

你也许会认为这是一个包装对象(见3章)在falsy值(如`"ℽ`,`零`或`假`)ㄢ但别陷入那_陷阱_ㄢ

**注: **这是一个微妙的规范笑话,有些人可能会得到ㄢ

考虑: 

```js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );
```

我们知道所有三个值对象(见3章)缠falsy值明显ㄢ但是这些物体是否表现为`真正的`或为`假`?那很容易回答: 

```js
var d = Boolean( a && b && c );

d; // true
```

所以,三者都表现为`真正的`因为这是唯一的方法`D`可能会结束`真正的`ㄢ

**提示: **通知`布尔(ⅆ)`缠`健康与健康`表达ℴℴ你可能想知道为什么会这样ㄢ我们将在本章后面提到这一点,所以请记下它ㄢ偷看一眼(小聪明),自己试试看`D`如果你只是做`a并购与并购`没有`布尔(ⅆ)`呼叫!

所以,如果"falsy对象ℽ**不只是反对缠falsy值**他们到底是什么?

棘手的部分是它们可以出现在js程序中,但它们实际上并不是JavaScript本身的一部分ㄢ

**什么!?**

在某些情况下,浏览器已经创建了自己的类型ㄢ_异国情调的_价值观的行为,即"falsy对象ℽ上定期JS语义ㄢ

"falsy对象ℽ是一种价值,看上去像一个正常的对象(属性,等等),但是当你强迫它一`布尔`,它强迫一个`假`价值ㄢ

**为什么!?**

最著名的例子是`document.all`: 提供给JS程序的数组(对象)_通过DOM_(不是js引擎本身),它将页面中的元素暴露到js程序中ㄢ它_习惯于_要像一个正常的对象,它将采取行动,一些ㄢ但不再ㄢ

`document.all`自己从来没有真正的"标准ℽ,早已过时了ㄢ

"他们就不能把它移走吗?ℽ对不起,很好的尝试ㄢ希望他们能ㄢ但是,有太多遗留下来的JS代码基础依赖于它ㄢ

那么,为什么把它作为falsy?因为强制的`document.all`到`布尔`(像`如果`语句几乎总是用来检测旧的ㄡ不标准的IEㄢ

IE浏览器早就达到了标准的标准化,而且在很多情况下,它比任何其他浏览器都要推进Web的数量ㄢ但是所有那些旧的`如果(文件all){它是IE }`代码仍然存在,其中大部分可能永远不会消失ㄢ所有这些遗留代码仍然假设它运行在十年前的IE,这只会导致IE用户的浏览体验不佳ㄢ

所以,我们不能移除`document.all`完全不需要`如果(文件all){}`代码再工作,使现代IE用户获得新的ㄡ符合标准的代码逻辑ㄢ

"我们该怎么办?ℽ\*\*"I've got it! 让我们低落的JS型系统和假装`document.all`是falsy!ℽ

啊ㄢ吮吸ㄢ这是一个疯狂的疑难杂症,大多数JS开发者不理解ㄢ但另一种选择(对上述不成功的问题不采取行动)很糟糕ㄢ_只要再多一点ㄢ_ㄢ

所以ⅆ这是我们得到了什么: 疯狂的,非标准的"falsy对象添加到JavaScript的浏览器ㄢ耶!

#### Truthy的价值观

回到一些列表ㄢ价值观的真相到底是什么?记得:**一个值是一些如果不在falsy列表ㄢ**

考虑: 

```js
var a = "false";
var b = "0";
var c = "''";

var d = Boolean( a && b && c );

d;
```

你期望什么价值?`D`来这里?它必须是要么`真正的`或`假`ㄢ

它是`真正的`ㄢ为什么?因为尽管这些内容`一串`价值观像falsy值的`一串`价值观本身是所有的真相,因为`"ℽ`是唯一的`一串`在falsy列表值ㄢ

这些怎么样?

```js
var a = [];				// empty array -- truthy or falsy?
var b = {};				// empty object -- truthy or falsy?
var c = function(){};	// empty function -- truthy or falsy?

var d = Boolean( a && b && c );

d;
```

是的,你猜对了,`D`仍然是`真正的`在这里.为什么?Same reason as before. 不管它看起来是什么样子,`[ ]`,`{ }`,和`function() { }`是_不_在falsy列表,因此一些值ㄢ

换句话说,真相是无限长的列表ㄢ做这样的清单是不可能的ㄢ你只能做有限的falsy列表和参考_它_ㄢ

花五分钟的时间,写falsy名单贴到你的电脑显示器,或记住它,如果你喜欢ㄢ无论哪种方式,你能够轻松地构建一个虚拟的一些清单,每当你需要问它在falsy列表或不简单ㄢ

的真实性和falsy的重要性了解价值的行为如果你强迫它(无论是明示或暗示)一`布尔`价值ㄢ既然您已经记住了这两个列表,我们就可以深入到强制示例本身了ㄢ

## 明确强制

_明确的_强制指的是明显而明确的类型转换ㄢ有广泛的类型转换使用_明确的_大多数开发者的胁迫类别ㄢ

这里的目标是识别模式在我们的代码中,我们可以清晰和明显的,我们的值转换为另一种类型,从而不留坑洼未来开发商去ㄢ我们越是明确,就越有可能以后有人能读懂我们的代码,不费力地理解我们的意图ㄢ

很难找到任何明显的分歧ㄢ_明确的_强制,因为它最接近于在静态类型语言中普遍接受的类型转换实践ㄢ因此,我们现在认为这是理所当然的ㄢ_明确的_胁迫可以被认为不是邪恶的或有争议的ㄢ不过,我们稍后会重新讨论这个问题ㄢ

### 显式: 字符串&lt;数字

我们将从最简单的也许是最常见的强制操作: 强迫值之间`一串`和`数`表示ㄢ

强迫之间`一串`S和`数`s,我们使用内置的`字符串(..)`和`数字(..)`函数(在第3章中我们称之为"本地构造函数ℽ),但是**很重要的是**我们不使用`新的`前面的关键字ㄢ因此,我们不创建对象包装器ㄢ

事实上,我们实际上_明确强制_这两种类型之间: 

```js
var a = 42;
var b = String( a );

var c = "3.14";
var d = Number( c );

b; // "42"
d; // 3.14
```

`字符串(..)`强迫任何其他价值的原始`一串`价值,使用的规则`ToString`前面讨论的操作ㄢ`数字(..)`强迫任何其他价值的原始`数`价值,使用的规则`第`前面讨论的操作ㄢ

我把这称为_明确的_强制,因为一般情况下,大多数开发人员都非常清楚,这些操作的最终结果是适用的类型转换ㄢ

事实上,这种用法看起来非常像在其他静态类型语言中的用法ㄢ

例如,在C和C++中,你可以说`(int)x`或`int(x)`两个都将转换`X`整数ㄢ两种形式都是有效的,但是很多都喜欢后者,它看起来像一个函数调用ㄢ在JavaScript中,当你说`数字(x)`看起来非常相似ㄢ它是否重要?_事实上_js中的函数调用?不是真的ㄢ

除了`字符串(..)`和`数字(..)`还有其他方法可以显式地将这些值转换为`一串`和`数`: 

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42"
d; // 3.14
```

打电话`A. tostring()`表面上是明确的(很明显,"说明ℽ是指"字符串ℽ),但有一些隐藏的含蓄在这里ㄢ`tostring()`不能被调用_原始的_价值`四十二`ㄢ所以js自动"框ℽ(参见第3章)`四十二`在对象包装器中,以便`tostring()`可以针对对象调用ㄢ换句话说,你可以称它为"显式隐式ℽㄢ

`+ C`这里是展示_一元运算符_窗体(只有一个操作数的运算符)`+`算子ㄢ不是执行数学加法(或字符串连接(见下文)),而是一元的ㄢ`+`明确强迫其操作数(`C`)一个`数`价值ㄢ

是`+ C` _明确的_胁迫?取决于你的经验和观点ㄢ如果你知道(你现在做了!)这一元`+`明确地打算`数`胁迫,那么它是非常明确和明显的ㄢ然而,如果你以前从未见过它,它似乎非常混乱,隐含,隐藏的副作用,等等ㄢ

**注: **开源JS社区中普遍接受的观点是一元的ㄢ`+`是一种公认的形式ㄢ_明确的_强制ㄢ

即使你真的喜欢`+ C`形式上,肯定有一些地方看起来很混乱ㄢ考虑: 

```js
var c = "3.14";
var d = 5+ +c;

d; // 8.14
```

一元`ℴ`运营商还强迫喜欢`+`是的,但它也翻转了数字的符号ㄢ然而,你不能把两个`ℴℴ`邻近unflip的标志,这是解析为递减运算符ㄢ相反,你需要做: `-"3.14ℽ`在两者之间有一个空格,这将导致强制`三点一四`ㄢ

你可能会想出各种各样的二进制运算符的可怕组合(比如`+`加法)在运算符的一元形式旁边ㄢ这里又是一个疯狂的例子: 

```js
1 + - + + + - + 1;	// 2
```

你应该极力考虑避免一元ㄢ`+`(或`ℴ`当它与其他操作符相邻时强制ㄢ虽然上述工作,它几乎普遍被认为是一个坏主意ㄢ即使`D=C`(或`D=C`对那件事!)很容易被混淆`d=c`这是完全不同的!

**注: **另一个非常混乱的地方`+`与另一个运算符相邻使用的将是`+ +`增量运算符和`ℴℴ`减量运算符ㄢ例如:`++`,`++`,和`++`ㄢ参见第5章中的"表达式副作用ℽ`+ +`ㄢ

记住,我们试图做到明确**减少**混乱,而不是更糟!

#### `日期`以`数`

一元的另一常用用法`+`经营者是强制`日期`对象为`数`,因为结果是Unix时间戳(毫秒时间自1970年1月1日00:00:00 UTC)表示的日期/时间值: 

```js
var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

+d; // 1408369986000
```

这个习语最常见的用法是获取当前信息ㄢ_现在_作为时间戳的时刻,这样的

```js
var timestamp = +new Date();
```

**注: **有些开发人员意识到JavaScript中有一种特殊的语法"技巧ℽ,也就是说`()`设置构造函数调用(调用的函数)`新的`)是_可选择的_如果没有参数可以通过ㄢ所以你可以跑过`时间戳=新日期;`形式ㄢ然而,并不是所有的开发人员都同意省略`()`提高可读性,因为这是一种罕见的语法例外,只适用于`新的fn()`通话形式而不是常规`fn()`调用形式ㄢ

但是强制不是唯一的方法来获得时间戳ㄢ`日期`对象ㄢ一个noncoercion方法也许更可取,因为它更显: 

```js
var timestamp = new Date().getTime();
// var timestamp = (new Date()).getTime();
// var timestamp = (new Date).getTime();
```

但一个_甚至更多_较好的noncoercion选项是使用ES5添加`now()日期ㄢ`静态函数: 

```js
var timestamp = Date.now();
```

如果你想polyfill`now()日期ㄢ`进入较旧的浏览器,这是非常简单的: 

```js
if (!Date.now) {
	Date.now = function() {
		return +new Date();
	};
}
```

我建议跳过与日期相关的强制形式ㄢ使用`now()日期ㄢ`当前_现在_时间戳,和`新日期(..)gettime()ㄢ`获取特定时间戳_非现在_需要指定的日期/时间ㄢ

#### 奇怪的情况`~`

一个强制JS算子是往往被忽视,通常很迷茫是波浪线`~`算子(又名"位ℽ)ㄢ许多人甚至理解它所做的事情,但往往还是想避免它ㄢ但是,在这本书和系列文章中,坚持我们的方法精神,让我们深入探究它是否`~`有什么有用的东西可以给我们吗?ㄢ

在32位整数(签名)ℽ部分的2章,我们覆盖在JS运算符如何只为32位的操作定义,这意味着他们的力量他们的操作符合32位值表示ㄢ这种情况如何发生的规则由`toint32`抽象操作(ES5的规格,9.5节)ㄢ

`toint32`第一次做`第`胁迫,这意味着如果值是`"123ℽ`它将首先成为`一百二十三`之前`toint32`规则被应用ㄢ

而不是_技术上_强制本身(因为类型不改变!),使用运算符(如`Ɯ`或`~`)具有某种特殊性`数`值产生强制效果,导致不同的结果ㄢ`数`价值ㄢ

例如,让我们首先考虑`Ɯ`"按位或"用于否则没有OP成语算子`0 Ɯ X`(正如第2章所示)基本上只做`toint32`转换: 

```js
0 Ɯ -0;			// 0
0 Ɯ NaN;		// 0
0 Ɯ Infinity;	// 0
0 Ɯ -Infinity;	// 0
```

这些特殊的数字不是32位表示(因为他们来自64位IEEE 754标准见2章),所以`toint32`只是指定`零`作为这些值的结果ㄢ

如果有争议的话`0 Ɯ __`是一个_明确的_这种强制形式`toint32`操作或如果它是更多_隐性的_ㄢ从规范的角度来看,这是毫无疑问的ㄢ_明确的_,但如果你不懂这一水平位操作,它似乎更多一点_隐式_神奇的.然而,与本章中的其他断言一致,我们将称之为_明确的_ㄢ

所以,让我们把注意力转移到`~`ㄢ这个`~`运营商"要挟ℽ到一个32位的第一`数`值,然后执行按位求反运算(翻转每个比特的奇偶校验)ㄢ

**注: **这很相似ㄢ`!`不仅使其价值`布尔`但也会翻转其奇偶性(参见"一元ℽ的讨论)ㄢ`!`"后来ℽㄢ

但ⅆ什么!为什么我们关心比特被翻转?这是一些非常专业的,细致入微的东西ㄢjs开发人员很少需要对单个位进行推理ㄢ

关于定义的另一种思考方式`~`来自老派的计算机科学/离散数学: `~`执行二进制补码ㄢ太好了,谢谢,那就更清楚了!

让我们再试一次: `~ X`大致相同`-(x + 1)`ㄢ这很奇怪,但稍微容易一点ㄢ所以: 

```js
~42;	// -(42+1) ==> -43
```

你可能还在想这到底是怎么回事`~`事情是关于什么的,或者为什么对强迫讨论真的很重要ㄢ让我们迅速到达要点ㄢ

考虑`-(x + 1)`ㄢ您能执行的操作的唯一值是什么?`零`(或`- 0`技术!)结果呢?`- 1`ㄢ换言之,`~`用于一系列`数`值将产生一个falsy(很容易转换成`假`)`零`值为`- 1`输入的值,和其他一些`数`否则ㄢ

这有什么关系?

`- 1`通常称为"哨兵值ℽ,基本上是指在同一类型的较大值集内赋予任意语义的值ㄢ`数`S)ㄢC语言的使用`- 1`许多回归函数的哨兵值`> = 0`"成功ℽ的价值观`- 1`因为"失败ℽㄢ

JavaScript在定义时使用了这个先例`一串`操作`IndexOf(..)`搜索一个字符串,如果发现返回其下标的位置,或`- 1`如果没有找到ㄢ

尝试使用是很常见的ㄢ`IndexOf(..)`不仅仅是为了获得这个职位,而是作为一个`布尔`存在/不存在在另一个字符串检查`一串`ㄢ下面是开发人员通常如何执行这样的检查: 

```js
var a = "Hello World";

if (a.indexOf( "lo" ) >= 0) {	// true
	// found it!
}
if (a.indexOf( "lo" ) != -1) {	// true
	// found it
}

if (a.indexOf( "ol" ) < 0) {	// true
	// not found!
}
if (a.indexOf( "ol" ) == -1) {	// true
	// not found!
}
```

我觉得这很恶心ㄢ`> = 0`或`= 1`ㄢ它基本上是一个"抽象泄漏,"在它的泄漏的底层实现`- 1`对于"失败ℽℴℴ进入我的代码ㄢ我宁愿隐瞒这样的细节ㄢ

现在,我们终于明白为什么了`~`能帮助我们!使用`~`具有`indexof()`"要挟ℽ(实际上只是变换)的价值**要适当`布尔`-强制**: 

```js
var a = "Hello World";

~a.indexOf( "lo" );			// -4   <-- truthy!

if (~a.indexOf( "lo" )) {	// true
	// found it!
}

~a.indexOf( "ol" );			// 0    <-- falsy!
!~a.indexOf( "ol" );		// true

if (!~a.indexOf( "ol" )) {	// true
	// not found!
}
```

`~`取返回值`IndexOf(..)`并将其转化为"失败ℽ`- 1`我们得到的falsy`零`,和所有其他价值是真相ㄢ

**注: **这个`-(x + 1)`伪算法`~`将意味着`~ - 1`是`- 0`但实际上它产生`零`因为基本的操作实际上是位,不是数学ㄢ

技术上,`如果(~ a.indexof(..))`仍然依赖_隐性的_强迫其结果`零`到`假`或非零`真正的`ㄢ但总的来说,`~`仍然觉得我更像一个_明确的_强制机制,只要你知道它在这个成语中打算做什么ㄢ

我发现这是比以前更干净的代码ㄢ`> = 0`/`= 1`杂波ㄢ

##### 截断位

还有一个地方`~`可能会在代码中你遇到: 一些开发商利用双波浪线`~ ~`截断小数部分`数`(即"强迫ℽ为整数"整数ℽ)ㄢ它通常(但错误地)说,这是由于调用相同`数学(地板)`ㄢ

怎么`~ ~`作品是第一个`~`应用`toint32`"强制ℽ和按位翻转,然后第二`~`另一位翻转,翻转所有的位都回到原来的状态ㄢ最终的结果就是`toint32`"胁迫ℽ(亦称截断)ㄢ

**注: **位双翻转`~ ~`非常类似于奇偶否定ㄢ`!!`行为,稍后在"显式: \* -布尔ℽ一节中解释ㄢ

然而,`~ ~`需要小心/澄清ㄢ首先,它只在32位值上可靠地工作ㄢ但更重要的是,它在负数上不起作用ㄢ`数学(地板)`做!

```js
Math.floor( -49.6 );	// -50
~~-49.6;				// -49
```

设置`数学(地板)`差异不谈,`~ ~ X`可以截断为(32位)整数ㄢ但这样做`X Ɯ 0`,似乎(略微)_较少的努力_ㄢ

那么,你为什么会选择`~ ~ X`结束`X Ɯ 0`,然后呢?运算符优先级(参见第5章): 

```js
~~1E20 / 10;		// 166199296

1E20 Ɯ 0 / 10;		// 1661992960
(1E20 Ɯ 0) / 10;	// 166199296
```

就像这里所有其他建议一样,使用`~`和`~ ~`作为"强制ℽ和"值转换ℽ的显式机制,只有读写这样代码的每个人都能正确地知道这些操作符是如何工作的!

### 显式: 解析数字字符串

一个类似的结果,强迫`一串`一个`数`可以通过解析a来实现`数`从一个`一串`人物的内容ㄢ但是,这种解析和我们上面检查的类型转换有明显的区别ㄢ

考虑: 

```js
var a = "42";
var b = "42px";

Number( a );	// 42
parseInt( a );	// 42

Number( b );	// NaN
parseInt( b );	// 42
```

解析字符串中的数字值是_宽容_对于非数字字符,它只在遇到时向左解析,而强制是_不宽容_失败导致`南`价值ㄢ

解析不应被视为胁迫的替代品ㄢ这两个任务虽然相似,但却有不同的目的ㄢ解析`一串`作为一个`数`当你不知道/关心什么其他非数字字符可能在右手边ㄢ强迫`一串`(一个`数`当唯一可接受的值是数值的和类似的`"42pxℽ`应拒绝作为`数`ㄢ

**提示: ** `parseInt(..)`有双胞胎,`parseFloat(..)`,从一个字符串中提取一个浮点数ㄢ

别忘了`parseInt(..)`操作上`一串`价值观ㄢ通过一件事是毫无意义的ㄢ`数`价值`parseInt(..)`ㄢ传递任何其他类型的值也没有意义,比如`真正的`,`function() {等}`或`[1,2,3]`ㄢ

如果您通过非ℴ`一串`您传递的值将自动被强制为`一串`首先(见)`ToString`"早些时候ℽ,这显然是一种隐藏ㄢ_隐性的_强制ㄢ在程序中依赖这样的行为是一个很糟糕的想法,所以千万不要使用ㄢ`parseInt(..)`用非ℴ`一串`价值ㄢ

另一个问题之前ES5,存在`parseInt(..)`这是许多js程序错误的根源ㄢ如果没有传递第二个参数来指示用于解释数字的数字基(又名基数)ㄢ`一串`内容,`parseInt(..)`先看看开头的字符,然后猜一猜ㄢ

如果前两个字符是`"0xℽ`或`"0xℽ`根据惯例,猜测是你想解释的ㄢ`一串`为一个十六进制(16进制)`数`ㄢ否则,如果第一个字符是`"0ℽ`这个猜测(又是惯例)是你想解释的ㄢ`一串`作为一个八进制(base-8)`数`ㄢ

十六进制`一串`(领先)`0x`或`0x`不是很容易混在一起ㄢ但八进制数的猜测是非常常见的ㄢ例如:

```js
var hour = parseInt( selectedHour.value );
var minute = parseInt( selectedMinute.value );

console.log( "The time you selected was: " + hour + ":" + minute);
```

似乎无害,对吗?请选择`08`时间和`09`暂时ㄢ你会得到`0`ㄢ为什么?因为没有`八`也没有`九`在八base-8有效字符ㄢ

的pre-es5修复很简单,但却很容易忘记: **总是擦肩而过`十`作为第二个论点**ㄢ这是完全安全的: 

```js
var hour = parseInt( selectedHour.value, 10 );
var minute = parseInt( selectedMiniute.value, 10 );
```

由于ES5,`parseInt(..)`不再猜八进制ㄢ除非你说,否则,它假定10(或16进制为`"0x`前缀)ㄢ那样好多了ㄢ只是要小心,如果你的代码运行在pre-es5环境,在这种情况下,你仍然需要通过`十`为了基数ㄢ

#### 非字符串解析

一个有点臭名昭著的例子`parseInt(..)`几年前,在一篇讽刺笑话中,人们的行为被突显出来,取笑这个JS行为: 

```js
parseInt( 1/0, 19 ); // 18
```

假设(但完全无效)的说法是,"如果我通过无限,和整数解析出来,我应该得到无限回来了,不是18ㄢℽ当然,JS一定是疯了,这个结局,对吗?

虽然这个例子显然是做作和虚幻的,让我们暂时放纵一下疯狂,看看JS是否真的疯了ㄢ

首先,这里犯下的最明显的罪过是不通过ℴ`一串`到`parseInt(..)`ㄢ那是不允许的ㄢ这样做,你是在自找麻烦ㄢ但即使你礼貌地强迫你,JS通过成`一串`它可以尝试解析ㄢ

有些人会说这是不合理的行为ㄢ`parseInt(..)`应拒绝经营非ℴ`一串`价值ㄢ它可能会抛出一个错误吗?这很像java,坦率地说ㄢ想到JS开始到处乱丢错误,我就不寒而栗ㄢ`试试ㄢ赶上`几乎每一行都需要ㄢ

它应该返回`南`?也许吧.但ⅆ怎么样: 

```js
parseInt( new String( "42") );
```

那也会失败吗?这是非ℴ`一串`价值ㄢ如果你想要的话`字符串`包装对象是办法`"42ℽ`那真的很不寻常吗?`四十二`首先成为`"42ℽ`以便`四十二`可以解析回来吗?

我认为这一半ℴ_明确的_,半ℴ_隐性的_可能发生的胁迫常常是非常有益的事情ㄢ例如:

```js
var a = {
	num: 21,
	toString: function() { return String( this.num * 2 ); }
};

parseInt( a ); // 42
```

事实上,`parseInt(..)`强行逼迫其值为`一串`执行解析是相当明智的ㄢ如果你把垃圾扔进垃圾桶,然后把垃圾拿出来,不要责怪垃圾桶ℴℴ它只是忠实地完成了它的工作ㄢ

所以,如果传入一个值,比如`无穷`(结果)`1/0`显然)什么样的`一串`代表权对其胁迫最有意义?只有两个合理的选择出现在脑海中: `"无限ℽ`和`"∞ℽ`ㄢJS选择`"无限ℽ`ㄢ我很高兴它做到了ㄢ

我认为这是件好事ㄢ**所有的值**js中有某种默认值`一串`表示,所以它们不是神秘的黑盒,我们无法调试和推理ㄢ

现在,base-19呢?显然,完全是伪造的ㄢ没有真正的JS程序使用base-19ㄢ太荒谬了ㄢ但是,让我们沉迷的荒谬ㄢ在base-19,有效数字字符`零`ℴ`九`和`一`ℴ`我`(不区分大小写)ㄢ

所以,回到我们的`parseInt(1 / 0, 19)`例子.它本质上是`parseInt("无限ℽ,19)`ㄢ它是如何解析的?第一个字符是`"我ℽ`,这是价值`十八`在愚蠢的base-19ㄢ第二特征`"Nℽ`不在有效的数字字符集中,因此解析简单地礼貌地停止,就像它跨越时一样ㄢ`"Pℽ`在里面`"42pxℽ`ㄢ

结果呢?`十八`ㄢ理智地认为它应该是ㄢ让我们到达那里的行为,而不是错误或`无穷`本身,是**非常重要**对JS,不应该这么轻易丢弃ㄢ

这种行为的其他例子`parseInt(..)`这可能令人惊讶,但相当明智的包括: 

```js
parseInt( 0.000008 );		// 0   ("0" from "0.000008")
parseInt( 0.0000008 );		// 8   ("8" from "8e-7")
parseInt( false, 16 );		// 250 ("fa" from "false")
parseInt( parseInt, 16 );	// 15  ("f" from "function..")

parseInt( "0x10" );			// 16
parseInt( "103", 2 );		// 2
```

`parseInt(..)`实际上在行为上是相当可预测和一致的ㄢ如果你正确地使用它,你会得到合理的结果ㄢ如果你不正确地使用它,你得到的疯狂结果并不是JavaScript的错误ㄢ

### 显式: \*

现在,让我们检查强迫任何非ℴ`布尔`价值一`布尔`ㄢ

就像`字符串(..)`和`数字(..)`以上,`布尔(ⅆ)`(没有`新的`当然可以!)是一种强制的明确方法ㄢ`布尔`强制: 

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

Boolean( a ); // true
Boolean( b ); // true
Boolean( c ); // true

Boolean( d ); // false
Boolean( e ); // false
Boolean( f ); // false
Boolean( g ); // false
```

而`布尔(ⅆ)`显然是明确的,它根本不是普通的或惯用的ㄢ

就像一元`+`算子胁值一`数`(见上文),一元`!`否定算子明确胁值一`布尔`ㄢ这个_问题_也就是把价值从一些对falsy反之亦然ㄢ因此,js开发人员明确地强制使用的最常见方式是`布尔`是使用`!!`双否定运算符,因为第二个运算符`!`将奇偶性翻转回原来的值: 

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a;	// true
!!b;	// true
!!c;	// true

!!d;	// false
!!e;	// false
!!f;	// false
!!g;	// false
```

任何这些`布尔`强制转换会发生_隐式_没有`布尔(ⅆ)`或`!!`如果用在`布尔`上下文,例如`如果ⅆⅆ`声明ㄢ但这里的目标是显式地将值强制为`布尔`为了更清楚地说明`布尔`胁迫是故意的ㄢ

另一个显式用例的例子`布尔`胁迫就是如果你想强迫一个`真正的`/`假`数据结构JSON序列化中的值强制: 

```js
var a = [
	1,
	function(){ /*..*/ },
	2,
	function(){ /*..*/ }
];

JSON.stringify( a ); // "[1,null,2,null]"

JSON.stringify( a, function(key,val){
	if (typeof val == "function") {
		// force `ToBoolean` coercion of the function
		return !!val;
	}
	else {
		return val;
	}
} );
// "[1,true,2,true]"
```

如果你到JavaScript从java,你可能认识这个成语: 

```js
var a = 42;

var b = a ? true : false;
```

这个`?: `三元运算符检验`一`为事实,并在此基础上,试验将分配`真正的`或`假`到`B`,因此ㄢ

从表面上看,这个成语看上去像是一种_明确的_ `布尔`-类型强制,因为很明显只有`真正的`或`假`从手术中出来ㄢ

然而_隐性的_胁迫,在`一`表达式必须首先被强制为`布尔`执行测试的事实ㄢ我把这个成语叫做"隐式显式ℽㄢ**你应该完全避免这个成语ㄢ**在JavaScriptㄢ它没有提供真正的好处,更糟糕的是,伪装成什么也不是ㄢ

`布尔(a)`和`!!一`要好得多_明确的_强制选项ㄢ

## 隐式强制

_隐性的_强制是指隐藏的类型转换,从其他操作中隐式地出现非明显的副作用ㄢ换言之,_隐式强制转换_是否对您不明显的任何类型转换ㄢ

虽然很清楚的目标是什么_明确的_强制是(使代码更明确,更易于理解),它可能是_太_明显的,_隐性的_强制有相反的目标: 使代码更难理解ㄢ

从表面上看,我认为这是对胁迫的愤怒来自于ㄢ大多数关于"JavaScript强制ℽ的抱怨实际上是针对(不管他们是否意识到)ㄢ_隐性的_强制ㄢ

**注: **道格拉斯克罗克福德,作家_"JavaScript: 好的部分ℽ_他在许多会议演讲和著作中声称,应该避免JavaScript强制ㄢ但他似乎是指_隐性的_胁迫是坏的(在他看来)ㄢ然而,如果您阅读了他自己的代码,就会发现很多强制的例子,两者都是ㄢ_隐性的_和_明确的_!事实上,他的焦虑似乎主要针对的是`= =`操作,但正如您在本章中看到的,这只是强制机制的一部分ㄢ

所以,**隐式强制**邪恶吗?有危险吗?这是javascript设计中的缺陷吗?我们应该不惜一切代价避免它吗?

我打赌你们大多数读者都会热情地欢呼,"是的!ℽ

**不这么快ㄢ**听我说ㄢ

让我们换个角度看什么_隐性的_强迫是,也可以是,它只是"与明显的强制形式相反ℽ,这是太狭隘了,忽略了一个重要的细微差别ㄢ

让我们定义目标_隐性的_胁迫: 减少冗长ㄡ样板ㄡ和/或不必要的实现细节,杂波与分散更重要的意图噪声码ㄢ

### 简化式

在我们还没到JavaScript,让我提出一些pseudo-code'ish从一些理论强类型语言说明: 

```js
SomeType x = SomeType( AnotherType( y ) )
```

在这个例子中,我有一些任意类型的值`Y`我想转换成`基类型`型ㄢ问题是,这种语言不能直接来自任何事物ㄢ`Y`目前是`基类型`ㄢ它需要一个中间步骤,首先转换为`另一种类型的`,然后`另一种类型的`到`基类型`ㄢ

现在,如果这种语言(或者你可以用语言创造的定义)怎么办?_做_就让你说: 

```js
SomeType x = SomeType( y )
```

您一般不会同意我们简化了这里的类型转换,以减少中间转换步骤的不必要的"噪音ℽ吗?我是说,是吗?_真正地_所有这些重要的,在这里,在这一点上的代码,看到和处理的事实`Y`去`另一种类型的`先到那时再去`基类型`?

有些人会争辩说,至少在某些情况下,是的ㄢ但我认为,在许多其他情况下,可以用同样的论点来简化ㄢ**实际上艾滋病代码的可读性**通过抽象或隐藏这些细节,无论是在语言本身还是在我们自己的抽象中ㄢ

毫无疑问,在幕后,某个地方,中间的转换步骤仍在发生ㄢ但是,如果这个细节被隐藏在这里,我们可以解释为什么`Y`型`基类型`作为一种泛型操作,隐藏混乱的细节ㄢ

虽然这不是一个完美的类比,我要在本章其余部分中讨论的是JSㄢ_隐性的_强制可以被认为是对代码提供类似的帮助ㄢ

但,**这是非常重要的ㄢ**这不是一个无限制的绝对陈述ㄢ肯定有很多_罪恶_潜伏在_隐性的_强制,这将损害您的代码远远超过任何潜在的可读性改进ㄢ显然,我们必须学会如何避免这样的构造,这样我们就不会用各种各样的bug毒害我们的代码ㄢ

许多开发人员认为,如果一个机制可以做一些有用的事情ㄢ**一**但也可以被滥用或滥用做一些可怕的事情ㄢ**Z**为了安全,我们应该完全放弃那个机制ㄢ

我对你的鼓励是: 不要满足于此ㄢ不要把婴儿连同洗澡水一起倒掉ℽㄢ不要以为_隐性的_胁迫是不好的,因为你认为你所见过的一切都是它的"坏部分ℽ,我认为这里有"好的部分ℽ,我想帮助和激励更多的人去发现并拥抱它们!

### 隐式地: 字符串&lt;数字

在本章的前面,我们探讨了_明确地_强迫之间`一串`和`数`价值观ㄢ现在,让我们探索同一个任务,但_隐性的_强制的方法ㄢ但在此之前,我们必须检查操作的一些细微差别ㄢ_隐式_力矫

这个`+`运算符重载,以满足两个目的ㄢ`数`此外,`一串`级联ㄢ那么js如何知道要使用哪种操作呢?考虑: 

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

不同的原因是什么?`"420ℽ`VS`四十二`?常见的误解是,一个或两个操作数是否是一个`一串`因为那意味着`+`将承担`一串`级联ㄢ虽然这是部分真实的,但它比那更复杂ㄢ

考虑: 

```js
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

这些操作数都不是`一串`但显然他们都被强迫`一串`然后`一串`并置踢ㄢ那到底是怎么回事?

(**警告: **深入细节规格说来,所以跳过下一段如果恐吓你!)

* * *

根据规范第11.6.1的ES5,`+`算法(当`对象`价值是一个操作数)将连接如果一个操作数是不是已经`一串`或者以下步骤生成`一串`表示ㄢ所以,当`+`接收`对象`(包括`阵列`对于两个操作数,它首先调用`toprimitive`关于值的抽象操作(第9.1节),然后调用`㄰[默认值] ]`算法(第8.12.8)与上下文的暗示`数`ㄢ

如果你密切注意,你会注意到这个操作现在与`第`摘要操作手柄`对象`s(参见"`第`"前面的部分)ㄢ这个`valueof()`操作上的`阵列`会产生一个简单的原始,所以它掉到一个`tostring()`表示ㄢ两`阵列`S因此成为`"1ℽ`和`"3ℽ`,分别ㄢ现在,`+`将两`一串`正如你通常预料的那样: `"1,23,4ℽ`ㄢ

* * *

让我们抛开那些杂乱的细节,回到先前的,简化的解释: 如果两个操作数都到`+`是一个`一串`(或成为上述步骤的一个!)手术将是`一串`级联ㄢ否则,它总是数字加法ㄢ

**注: **一个常被引用的强迫你`[ ] { }`vs.`{ [ } ]`,这两个表达式分别在`"[对象对象]`和`零`ㄢ不过,还有更多的内容,我们在第5章的"区块ℽ中详细介绍了这些细节ㄢ

这意味着什么?_隐性的_胁迫?

你可以胁迫一个`数`一个`一串`简单地说"添加ℽ`数`和`"ℽ`空的`一串`: 

```js
var a = 42;
var b = a + "";

b; // "42"
```

**提示: **数值加法`+`运算符是交换的,这意味着`2 + 3`是一样的`3 + 2`ㄢ字符串连接用`+`显然不是一般的交换,**但是**以具体案例`"ℽ`它实际上是可交换的,如`"+ℽ`和`"+ℽ`产生相同的结果ㄢ

这是非常普遍/习惯的ㄢ_隐式_)胁迫`数`到`一串`用一个`+"ℽ`操作ㄢ事实上,有趣的是,即使是一些最直言不讳的批评者_隐性的_强制仍然在自己的代码中使用这种方法,而不是其中的一种ㄢ_明确的_选择.

**我认为这是一个很好的例子ㄢ**一种有用的形式_隐性的_强迫,尽管这种机制经常受到批评!

比较_隐性的_强制`"+ℽ`我们前面的例子`字符串(a)` _明确的_胁迫,还有一个额外的怪癖要知道ㄢ因为如何`toprimitive`抽象作业,`"+ℽ`调用`valueof()`上`一`值,其返回值最后转换为`一串`通过内部`ToString`摘要操作ㄢ但`字符串(a)`只是调用`tostring()`直接ㄢ

这两种方法最终导致`一串`但是如果你使用`对象`而不是普通的原语`数`值,您可能不一定得到_相同的_ `一串`价值!

考虑: 

```js
var a = {
	valueOf: function() { return 42; },
	toString: function() { return 4; }
};

a + "";			// "42"

String( a );	// "4"
```

一般来说,这类问题不会咬你除非你真的想创造混乱的数据结构和操作,但是你要小心,如果你定义你自己`valueof()`和`tostring()`方法对一些`对象`正如你如何强迫价值可能影响结果一样ㄢ

另一个方向呢?我们怎么能_隐式强制_从`一串`到`数`?

```js
var a = "3.14";
var b = a - 0;

b; // 3.14
```

这个`ℴ`运算符仅定义用于数字减法,因此`一- 0`军队`一`被胁迫的价值`数`ㄢ虽然不太常见,`* 1`或`一/ 1`将完成相同的结果,因为这些运算符也仅定义为数字操作ㄢ

怎么样`对象`值与`ℴ`运营商?类似的故事`+`以上: 

```js
var a = [3];
var b = [1];

a - b; // 2
```

两`阵列`价值观必须成为`数`S,但他们最终是被迫的`串`(使用预期的`tostring()`序列化),然后被强制为`数`s,为`ℴ`减法执行ㄢ

所以,是_隐性的_强制`一串`和`数`珍惜你经常听到的恐怖故事吧?我个人不这么认为ㄢ

比较`b =字符串(a)`(_明确的_)来`"+ℽ`(_隐性的_)ㄢ我认为这两种方法在代码中都有用ㄢ当然`"+ℽ`在js程序中相当常见,不管它如何证明它自己的实用性ㄢ_感情_关于优点或危害_隐性的_一般胁迫ㄢ

### 含蓄

我想一个例子_隐性的_强制真的能使某些复杂的类型变得简单ㄢ`布尔`逻辑为简单的数字加法ㄢ当然,这不是一种通用技术,而是针对特定情况的特定解决方案ㄢ

考虑: 

```js
function onlyOne(a,b,c) {
	return !!((a && !b && !c) ƜƜ
		(!a && b && !c) ƜƜ (!a && !b && c));
}

var a = true;
var b = false;

onlyOne( a, b, b );	// true
onlyOne( b, a, b );	// true

onlyOne( a, b, a );	// false
```

这`一个(..)`实用程序只能返回`真正的`如果其中一个参数是`真正的`/真相ㄢ它的使用_隐性的_在一些检查和强迫_明确的_对其他人的胁迫,包括最后的返回值ㄢ

但是,如果我们需要该实用程序能够以同样的方式处理四ㄡ五或二十个标志呢?很难想象执行能够处理所有这些比较排列的代码ㄢ

不过这里看`布尔`价值观`数`S(`零`或`一`很明显)可以很大的帮助: 

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		// skip falsy values. same as treating
		// them as 0's, but avoids NaN's.
		if (arguments[i]) {
			sum += arguments[i];
		}
	}
	return sum == 1;
}

var a = true;
var b = false;

onlyOne( b, a );		// true
onlyOne( b, a, b, b, b );	// true

onlyOne( b, b );		// false
onlyOne( b, a, b, b, b, a );	// false
```

**注: **当然,而不是`对于`环`一个(..)`,你可以更简洁地使用ES5`减少(ⅆ)`实用,但我不想模糊概念ㄢ

我们在这里所做的是依靠`一`对于`真正的`/还是强制,数值加起来ㄢ`总和=参数[ i ]`使用_隐性的_强迫使之发生ㄢ如果一个和唯一一个值在`争论`列表`真正的`然后,数字和将是`一`否则总数就不会是`一`因此,所期望的条件没有得到满足ㄢ

我们当然可以这样做_明确的_强制代替: 

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		sum += Number( !!arguments[i] );
	}
	return sum === 1;
}
```

我们首先使用`![论据]`迫使价值的强制`真正的`或`假`ㄢ这样你就可以通过非ℴ`布尔`值,例如`一个(42,0)`它仍然会像预期的那样工作ㄢ`一串`连接和逻辑是不正确的)ㄢ

一旦我们确定它是`布尔`我们做另一个_明确的_强制手段`数字(..)`确定值是`零`或`一`ㄢ

是的_明确的_这个工具的强制形式"更好ℽ?它确实避免了`南`代码注释中的陷阱ㄢ但最终,这取决于你的需要ㄢ我个人认为前一版本,依靠_隐性的_胁迫是更优雅的(如果你不会通过)`未定义`或`南`)以及_明确的_版本不必要更冗长ㄢ

但正如我们在这里讨论的几乎所有事情一样,这是一个判断ㄢ

**注: **不管_隐性的_或_明确的_接近,你很容易做到`2(..)`或`五(..)`通过改变最后的比较来改变`一`,以`二`或`五`,分别ㄢ这比添加一大堆`&`和`Ɯ Ɯ`表达.一般来说,强制在这种情况下是非常有用的ㄢ

### 隐式地: \*

现在,让我们把注意力转向_隐性的_胁迫`布尔`价值观,因为它是迄今为止最常见的,也是迄今为止最具有潜在麻烦的ㄢ

记得,_隐性的_当你使用一个值迫使它转换时,强制就是其中的一部分ㄢ数字和`一串`操作,很容易看出的强制转换可以发生ㄢ

但是,操作需要什么类型的表达式/强制(_隐式_)一个`布尔`胁迫?

1.  中的测试表达式`如果(ⅆ)`声明ㄢ
2.  a中的测试表达式(第二子句)`为(ㄢ;..;..)`头ㄢ
3.  测试表达式`虽然(ⅆ)`和`当ⅆⅆ时`环ㄢ
4.  测试表达式(第一项)`?: `三元表达式ㄢ
5.  左操作数(用作测试表达式)见下文!到`Ɯ Ɯ`("逻辑ℽ或"ℽ)`&`("逻辑ℽ和"ℽ运算符)ㄢ

在这些上下文中使用的值,该值尚未`布尔`将_隐式_强迫一个`布尔`使用的规则`布尔`本章前面所述的抽象操作ㄢ

让我们看一些例子: 

```js
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
	console.log( "yep" );		// yep
}

while (c) {
	console.log( "nope, never runs" );
}

c = d ? a : b;
c;					// "abc"

if ((a && d) ƜƜ c) {
	console.log( "yep" );		// yep
}
```

在所有这些上下文中,非ℴ`布尔`值_隐式强制_他们的`布尔`作出测试决定的等价物ㄢ

### 运营商`Ɯ Ɯ`和`&`

很可能你已经看过了ㄢ`Ɯ Ɯ`("逻辑ℽ或"ℽ)`&`("逻辑ℽ和"ℽ)运算符在您使用的大多数或所有其他语言中ㄢ所以很自然地假设它们在JavaScript中的工作与其他类似语言基本相同ㄢ

这里有一些鲜为人知却很重要的细微差别ㄢ

事实上,我认为这些运营商甚至不应该被称为"逻辑\_\_\_算子ℽ,那叫不完全描述他们做什么ㄢ如果我给他们一个更准确(如果更笨拙)的名字,我会叫他们"选择器操作符ℽ,或者更完全地说,"操作数选择器操作符ℽㄢ

为什么?因为它们实际上并没有导致_逻辑_价值(又名`布尔`)在JavaScript中,就像在其他语言中一样ㄢ

那又怎么样_做_结果是什么?它们导致两个操作数中的一个(只有一个)的值ㄢ换言之,**它们选择两个操作数中的一个值ㄢ**ㄢ

引用ES5规格从11.11节: 

> 价值产生于与或Ɯ Ɯ运营商不一定是布尔类型ㄢ生成的值总是两个操作数表达式中的一个值ㄢ

让我们举例说明: 

```js
var a = 42;
var b = "abc";
var c = null;

a ƜƜ b;		// 42
a && b;		// "abc"

c ƜƜ b;		// "abc"
c && b;		// null
```

**等等,什么!?**想想看ㄢ在像C和PHP这样的语言中,这些表达式导致`真正的`o`假`但在js(Python和Ruby,在这方面)!结果来自价值观本身ㄢ

两`Ɯ Ɯ`和`&`运营商执行`布尔`试验研究**第一个操作数**(`一`或`C`)ㄢ如果操作数还没有`布尔`(这不是,这里),正常的`布尔`强制发生,以便可以执行测试ㄢ

对于`Ɯ Ɯ`操作员,如果测试是`真正的`,的`Ɯ Ɯ`表达式的结果是_第一个操作数_(`一`或`C`)ㄢ如果测试是`假`,的`Ɯ Ɯ`表达式的结果是_第二个操作数_(`B`)ㄢ

相反,对于`&`操作员,如果测试是`真正的`,的`&`表达式的结果是_第二个操作数_(`B`)ㄢ如果测试是`假`,的`&`表达式的结果是_第一个操作数_(`一`或`C`)ㄢ

结果`Ɯ Ɯ`或`&`表达式总是一个操作数的底层值,**不**测试的(可能是强迫的)结果ㄢ在`中西医结合`,`C`是`无效的`,从而falsyㄢ但`&`表达式本身导致`无效的`(值在`C`不是被迫的`假`用于测试ㄢ

你看到现在这些操作符是如何作为操作数选择器的吗?

关于这些操作符的另一种思考方式: 

```js
a ƜƜ b;
// roughly equivalent to:
a ? a : b;

a && b;
// roughly equivalent to:
a ? b : a;
```

**注: **我叫`一个Ɯ Ɯ B`大致相当于`一个吗?答: B`因为结果是相同的,但有细微差别ㄢ在`一个吗?答: B`,如果`一`是一个更复杂的表达式(比如说可能有副作用的表达式,比如调用a)ㄢ`功能`等等,然后`一`表达可能是评价两次(如果第一次评估真实性)ㄢ相比之下,`一个Ɯ Ɯ B`,的`一`表达式只被求值一次,该值同时用于强制测试和结果值(如果合适)ㄢ同样的细微差别也适用于`甲与乙`和`一个吗?B: 一`表达.

这种行为的一个非常普遍和有用的用法,它有一个很好的机会,你可能会使用之前,并没有完全理解,是: 

```js
function foo(a,b) {
	a = a ƜƜ "hello";
	b = b ƜƜ "world";

	console.log( a + " " + b );
}

foo();					// "hello world"
foo( "yeah", "yeah!" );	// "yeah yeah!"
```

这个`a一个Ɯ Ɯ"你好ℽ`成语(有时称为JavaScript的版本的C #"null合并运算符ℽ)行为测试`一`如果它没有价值(或只是一个意外的falsy值),提供了一个备份的默认值(`"你好ℽ`)ㄢ

**小心**,虽然!

```js
foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

看到问题了吗?`"ℽ`作为第二个参数是一个falsy值(见`布尔`在本章的前面),所以`B = B Ɯ Ɯ"世界ℽ`测试失败,并且`"世界ℽ`默认值被替换,尽管意图可能是显式传递ㄢ`"ℽ`是分配给的值`B`ㄢ

这`Ɯ Ɯ`习语是非常普遍的,也是非常有用的,但是只有在这种情况下才能使用它ㄢ_所有的falsy值_应该跳过ㄢ否则,您将需要在测试中更加明确,并可能使用`?: `三元代替ㄢ

这_默认值分配_习语是如此普遍(有用)!即使那些公开强烈谴责JavaScript强制经常使用它自己的代码!

怎么样`&`?

还有一个成语,是一种不常用的手动撰写,但这是用JS minifiers频繁ㄢ这个`&`运营商的"选择ℽ的第二个操作数当且仅当第一个操作数测试一些,这种用法有时被称为"护商ℽ(参见"短路ℽ5章)--第一个表达测试的"守卫ℽ二表达: 

```js
function foo() {
	console.log( a );
}

var a = 42;

a && foo(); // 42
```

`foo()`只因为`一`测试真实性ㄢ如果测试失败,则`一个与foo()`表达式语句会默默地停止ℴℴ这就是所谓的"短路ℽℴℴ而且从不调用ㄢ`foo()`ㄢ

同样,写这种东西的人也几乎不常见ㄢ通常他们会这样做`如果(一){ foo();}`相反ㄢ但是,JS minifiers选择`一个与foo()`因为它短得多ㄢ所以,现在,如果你不得不破译这些代码,你就会知道它在做什么,为什么ㄢ

好的,所以`Ɯ Ɯ`和`&`只要你愿意,就有一些灵巧的技巧ㄢ_隐性的_胁迫混合ㄢ

**注: **两`A = B Ɯ Ɯ"东西ℽ`和`一个与b()`习语依赖于短路行为,我们在第5章中更详细地介绍了它ㄢ

事实上,这些操作符实际上并没有导致`真正的`和`假`现在可能会把你的头弄得一团糟ㄢ你可能想知道你是怎么做到的`如果`报表和`对于`循环一直在工作,如果它们包含了复合逻辑表达式,比如`一个与(B Ɯ Ɯ C)`ㄢ

不必担心,天空没有坠落ㄢ你的代码(可能)很好ㄢ只是你可能从来没有意识到之前有一个_隐性的_胁迫`布尔`去**之后**对化合物的表达进行了评价ㄢ

考虑: 

```js
var a = 42;
var b = null;
var c = "foo";

if (a && (b ƜƜ c)) {
	console.log( "yep" );
}
```

这段代码仍然像你一直认为的那样工作,除了一个微妙的额外细节ㄢ这个`一个与(B Ɯ Ɯ C)`表达_事实上_结果`"fooℽ`,不`真正的`ㄢ因此,该`如果`陈述_然后_部队`"fooℽ`价值强制`布尔`这当然是`真正的`ㄢ

看到了吗?没有理由惊慌ㄢ您的代码可能仍然是安全的ㄢ但现在你更了解它是怎么做的ㄢ

现在您也意识到这样的代码正在使用中ㄢ_隐性的_矫_明确的_: 

```js
if (!!a && (!!b ƜƜ !!c)) {
	console.log( "yep" );
}
```

祝你好运!ⅆ对不起,只是玩玩而已ㄢ

### 符号强制

到目前为止,几乎没有观察到的结果之间的差异ㄢ_明确的_和_隐性的_强制ℴℴ只有代码的可读性受到威胁ㄢ

但6符号介绍了进入强制制度,我们需要简要探讨ㄢ原因远远超出我们在本书中讨论的范围,_明确的_强迫一个`符号`一个`一串`is allowed, but_隐性的_相同的强制禁止,抛出一个错误ㄢ

考虑: 

```js
var s1 = Symbol( "cool" );
String( s1 );					// "Symbol(cool)"

var s2 = Symbol( "not cool" );
s2 + "";						// TypeError
```

`符号`价值观不能强迫`数`不管怎样,都会出错,但奇怪的是两者都可以ㄢ_明确地_和_隐式_强迫`布尔`(总是`真正的`)ㄢ

一致性总是更容易学习,也没有乐趣去处理,但我们只需要围绕新6小心`符号`价值观和我们如何强迫他们ㄢ

好消息是: 你可能需要强迫一个`符号`价值ㄢ他们通常使用的方式(见第3章)可能不会要求在正常的基础上强制ㄢ

## 松散等于等于严格

松等于`= =`运算符和严格相等是`= = =`算子ㄢ这两个操作符用于比较两个值为"相等ℽ,但是"松ℽ和"严格ℽ表示一个**非常重要**两者之间的行为差异,特别是他们如何决定"平等ℽㄢ

关于这两个运营商的一个非常普遍的误解是: `= =`检查相等的值和`= = =`检查值和类型是否相等ㄢ无数受人尊敬的JavaScript书籍和博客都这么说,但不幸的是它们都是ㄢ_错误的_ㄢ

正确的描述是: "`= =`允许在相等比较和`= = =`不允许强迫ㄢℽ

### 平等的表现

停下来想想第一个(不准确)解释和第二个(准确)解释之间的区别ㄢ

在第一种解释中,似乎很明显`= = =`是_做更多的工作_比`= =`因为它必须_也_检查类型ㄢ在第二种解释中,`= =`是一个_做更多的工作_因为如果类型不同,则必须遵循强制步骤ㄢ

不要像许多人那样陷入陷阱,认为这与性能有关,不过,好像`= =`会慢于`= = =`以任何相关的方式ㄢ虽然胁迫是可以测量的_一点点_处理时间,那是微秒(是的,这是一个二!万分之二)ㄢ

如果比较相同类型的两个值,`= =`和`= = =`使用相同的算法,除了引擎实现中的细微差别外,它们应该做同样的工作ㄢ

如果比较不同类型的两个值,那么性能不是重要的因素ㄢ你应该问自己的是: 当比较这两个值时,我是否需要强制?

如果你想要强迫,使用`= =`松散的相等,但如果您不想强制使用,请使用`= = =`严格的平等ㄢ

**注: **这里的含义是,两者都`= =`和`= = =`检查它们的操作数类型ㄢ不同之处在于,如果类型不匹配,它们将如何响应ㄢ

### 摘要平等

这个`= =`经营者的行为定义为"抽象的平等比较算法ℽ对ES5的规格什么的上市有一个全面而简单的算法,明确规定每一种可能的组合类型部分11.9.3,以及如何强制(如果需要)应该为每个组合发生ㄢ

**警告: **当(_隐性的_)强制是诬蔑为太复杂的缺陷是_有用的好的部分_正是这些"抽象平等ℽ的规则受到谴责ㄢ一般来说,他们说是过于复杂而不直观的开发商实际的学习和使用,并且他们比提高代码的可读性,更容易造成JS程序错误ㄢ我相信这是一个有缺陷的前提ℴℴ读者是有能力编写(阅读和理解)的开发人员ㄢ算法(又名代码)一整天ㄢ因此,下面简单地描述了"抽象的平等ℽㄢ但我恳求你也读ES5规格部分11.9.3ㄢ我想你会惊讶于它是多么的合理ㄢ

基本上,第一款(11.9.3.1)说,如果这两个值相比是同一类型的,他们是简单而自然地通过身份会比较ㄢ例如,`四十二`仅等于`四十二`,和`"ABCℽ`仅等于`"ABCℽ`ㄢ

对正常期望的一些微小的例外: 

-   `南`永远不等于自己(见第2章)ㄢ
-   `+ 0`和`- 0`彼此平等(见第2章)

第11.9.3.1最终提供的是`= =`松散相等比较`对象`S(包括`功能`S和`阵列`S)ㄢ只有两个这样的值_平等的_如果他们都提到_完全相同的值_ㄢ这里没有强迫ㄢ

**注: **这个`= = =`严格相等比较定义为1ㄢ`对象`价值观ㄢ这是一个鲜为人知的事实ㄢ**`= =`和`= = =`相同的行为**在两个例子中`对象`S正在被比较!

在11.9.3其余算法的规定,如果你使用`= =`通过比较不同类型的两个值,可以得到一个或两个值ㄢ_隐式_强迫ㄢ这种强制发生,使两个值最终以相同的类型结束,然后可以直接使用简单的值一致性来比较相等ㄢ

**注: **这个`!=`松散不平等操作是完全按照您的期望定义的,因为它实际上是`= =`操作比较是整体的,然后是结果的否定ㄢ同样的道理也适用于`!= =`严格不平等操作ㄢ

#### 比较:`一串`S`数`S

说明`= =`胁迫,让我们首先建立`一串`和`数`本章前面的例子: 

```js
var a = 42;
var b = "42";

a === b;	// false
a == b;		// true
```

正如我们所预料的,`a = b`失败,因为不允许强制,而且确实`四十二`和`"42ℽ`价值观不同ㄢ

然而,第二比较`a = b`使用松散相等,这意味着如果类型不同,则比较算法将执行ㄢ_隐性的_对一个或两个值的强制ㄢ

但究竟是什么样的胁迫发生在这里?做`一`价值`四十二`成为一个`一串`或者是`B`价值`"42ℽ`成为一个`数`?

在ES5规格ㄡ条款11.9.3.4-5说: 

> 4.  如果类型(x)是数字和类型(y)是字符串,
> 5.  返回结果的比较x = =数字(Y)ㄢ

**如果type(x)是String,type(y)是数字,**返回数字的比较结果(x)= = Yㄢ`警告: `规范使用`数`和`字符串`作为类型的正式名称,而这本书更喜欢`数`和`一串`对于原始类型ㄢ不要让资本化`数`在规格混淆你为

number()`原生功能ㄢ对于我们的目的来说,类型名的大写是不相关的ℴℴ它们基本上是相同的意思ㄢ`很明显,说明书上说的是`"42ℽ`值被强制为_数_为了比较ㄢ这个`怎样`这种胁迫以前已经被提到过了,特别是`第`摘要操作ㄢ在这种情况下,结果非常明显ㄢ

#### 四十二`值相等ㄢ`

相比之下: 任何东西_布尔_其中一个最大的陷阱与`隐性的`强制`= =`当您尝试直接比较值时,会出现松散的相等ㄢ`真正的`或

假

```js
var a = "42";
var b = true;

a == b;	// false
```

ㄢ`考虑: `等等,这里发生什么事了?!我们知道`"42ℽ`是一个真实性价值(见本章前面)ㄢ那么,为什么不是呢?`= =`松等于

真正的

?

> 6.  The reason is both simple and deceptively tricky. 很容易误解,很多js开发人员从来没有足够的关注去完全掌握它ㄢ
> 7.  让我们再次引用规范,条款11.9.3.6-7: 

如果类型(x)是布尔型,

```js
var x = true;
var y = "42";

x == y; // false
```

返回数字的比较结果(x)= = Yㄢ`如果Type(y)是布尔函数,`返回结果的比较x = =数字(Y)ㄢ`让我们把它打破ㄢ第一:`这个`类型(x)`的确是`布尔`所以它执行`第(x)`,胁迫`真正的`到`一`ㄢ现在,`1 ="42ℽ`评价ㄢ类型也不同,所以(本质上是递归的)我们重新征求意见,就像上面的算法,将迫使`"42ℽ`到`四十二`,和

1 = 42

```js
var x = "42";
var y = false;

x == y; // false
```

显然是`假`ㄢ`扭转它,我们仍然得到相同的结果: `这个`类型(y)`是`布尔`这一次,所以`ToNumber(Y)`产量`零`ㄢ`"42ℽ=0`递归成为

42 = 0**这当然是`假`ㄢ`换言之,`的价值`"42ℽ`既不**= =真

也没有

`= =假`ㄢ`起初,这个声明可能看起来很疯狂ㄢ一个价值如何能既不真实性也不falsy?` **但这就是问题所在!你问的问题完全错了ㄢ这不是你的错,真的吗?ㄢ你的大脑是骗你的ㄢ**"42ℽ`的确是真相,但` _"42ℽ=真的_不执行布尔测试/强制ㄢ`总之,不管你的大脑怎么说ㄢ`"42ℽ`是不是`被胁迫`布尔`(`真正的`但是,而不是`真正的`被强制为`一`,然后

"42ℽ`被强迫`四十二`ㄢ`不管我们喜不喜欢,`布尔`甚至没有参与进来,所以事实或falsiness的

"42ℽ_与ⅆ无关_= =`操作!`什么`是`相关的是了解如何`= =`比较算法的行为与所有不同类型的组合ㄢ因为它认为`布尔`两边的值`= =` _,一个_布尔

总是强迫一个`数`第一`ㄢ`如果你觉得这很奇怪,你并不孤单ㄢ我个人建议在任何情况下都不要使用ㄢ

= =真`或`= =假`ㄢ曾经ㄢ`但是记住,我只是在说`= =`在这里.`=真`和

= false

```js
var a = "42";

// bad (will fail!):
if (a == true) {
	// ..
}

// also bad (will fail!):
if (a === true) {
	// ..
}

// good enough (works implicitly):
if (a) {
	// ..
}

// better (works explicitly):
if (!!a) {
	// ..
}

// also great (works explicitly):
if (Boolean( a )) {
	// ..
}
```

不允许强制,所以他们从这个隐藏的安全`第`强制ㄢ`考虑: `如果你避免使用`= =真`或

#### = =假`(亦称松散等式)`布尔`S)在你的代码,你就不用担心这个事实/ falsiness心理问题ㄢ`比较:

无效的_S_未定义`S`另一个例子`隐性的`可以用`= =`宽松的平等之间的关系

> 2.  无效的
> 3.  和

`未定义`价值观ㄢ一次又一次`未定义`相比之下`= =`松散的平等,等同于(强迫胁迫)彼此(显然是他们自己),在整个语言中没有其他价值观ㄢ

这意味着什么?`无效的`和`未定义`如果您使用的话,可以被视为无法比较的目的ㄢ`= =`允许它们相互作用的松散相等运算符_隐性的_强制ㄢ

```js
var a = null;
var b;

a == b;		// true
a == null;	// true
b == null;	// true

a == false;	// false
b == false;	// false
a == "";	// false
b == "";	// false
a == 0;		// false
b == 0;		// false
```

胁迫之间`无效的`和`未定义`是安全的和可预测的,并且没有其他的值能在这样的检查中给出假阳性ㄢ我建议使用这种强制措施允许`无效的`和`未定义`不可区分,因此被视为相同的价值ㄢ

例如:

```js
var a = doSomething();

if (a == null) {
	// ..
}
```

这个`a = null`支票只准通过`dosomething()`返回`无效的`或`未定义`,并将无法与任何其他值,甚至其他falsy价值`零`,`假`,和`"ℽ`ㄢ

这个_明确的_检查的形式,它不允许任何强制,是(我认为)不必要的更难看(也许还有一点点不完整!): 

```js
var a = doSomething();

if (a === undefined ƜƜ a === null) {
	// ..
}
```

在我看来,形式`a = null`又是另一个例子_隐性的_强制提高代码可读性,但以可靠的安全方式实现ㄢ

#### 比较:`对象`非非ℴ`对象`S

如果一个`对象`/`功能`/`阵列`与简单标量原语进行比较ㄢ`一串`,`数`,或`布尔`),该条款11.9.3.8-9 ES5规格说: 

> 8.  如果类型(x)是字符串或数字,类型(y)是对象,
> 9.  返回结果的比较x = = toprimitive(Y)ㄢ

**如果type(x)是对象,类型(y)是字符串或数字,**返回的结果比较toprimitive(x)= = Yㄢ`注: `你可能会注意到这些条款只提到`字符串`和`数`,但不`布尔`ㄢ这是因为,正如之前引用条款11.9.3.6-7照顾强迫任何`布尔`提交给a的操作数

数

```js
var a = 42;
var b = [ 42 ];

a == b;	// true
```

第一.`考虑: `这个`[ 42 ]`价值的`toprimitive`调用了抽象操作(参见"抽象值操作ℽ一节),这导致`"42ℽ`价值ㄢ从那里,它只是`42 ="42ℽ`正如我们已经涵盖的那样`42 = 42`,所以`一`和

**B**被强制的平等ㄢ`提示: `所有的怪癖`toprimitive`我们在本章前面讨论的抽象操作(`tostring()`,`valueof()`请按照您的期望应用于此ㄢ如果您想定义一个复杂的数据结构,那么这将非常有用ㄢ

valueof()`方法,为相等比较目的提供简单值ㄢ`在3章中,我们覆盖的"拆箱,ℽ其中一个`对象`包装器围绕一个原始值(如从`新字符串("ABCℽ)`例如,)被解包,底层的原始值(`"ABCℽ`)返回ㄢ这种行为与`toprimitive`强制的

```js
var a = "abc";
var b = Object( a );	// same as `new String( a )`

a === b;				// false
a == b;					// true
```

`= =`算法:`a = b`是`真正的`因为`B`被胁迫(又名"拆箱,通过"打开)`toprimitive`它背后的`"ABCℽ`简单标量原始值,其值与

一`ㄢ`但是,有一些值在这种情况下并非如此,因为

```js
var a = null;
var b = Object( a );	// same as `Object()`
a == b;					// false

var c = undefined;
var d = Object( c );	// same as `Object()`
c == d;					// false

var e = NaN;
var f = Object( e );	// same as `new Number( e )`
e == f;					// false
```

= =`算法.考虑: `这个`无效的`和`未定义`值不能装箱ℴℴ它们没有对象包装器等价物ℴℴ所以`对象(null)`就像

`object()`在这两者中只产生一个普通对象ㄢ`南`可以盒装到它的`数`对象包装器等效,但当`= =`拆箱的原因,`南=南`比较失败的原因

### 南

永远不等于自己(见第2章)ㄢ_边缘情况_现在我们已经彻底检查了`隐性的`强制

= =

#### 宽松平等的作品(在合理的和令人惊讶的方式),让我们试着打坏,疯狂的案例,我们可以看到我们需要避免不被强迫的错误ㄢ

```js
Number.prototype.valueOf = function() {
	return 3;
};

new Number( 2 ) == 3;	// true
```

**首先,让我们研究如何修改内置的本机原型可以产生疯狂的结果: ** `任何其他值的数字都会ⅆ`警告: `2 = 3`不会掉进这个陷阱,因为两者都不会ㄢ`二`也没有`三`将调用内置的`valueof()数ㄢ原型ㄢ`方法,因为它们都已经是原始的ㄢ`数`值,可以直接比较ㄢ然而,`新号码(2)`必须通过`toprimitive`胁迫,从而调用

valueof()_ㄢ_邪恶,嗯?当然是ㄢ任何人都不应该做这样的事ㄢ你这个事实`可以`这种做法有时被用作对胁迫的批评吗?_= =_ㄢ但这是误导的挫折ㄢJavaScript不是_坏的_ **因为你可以做这样的事情,开发人员**坏的

如果他们这样做

```js
if (a == 2 && a == 3) {
	// ..
}
```

ㄢ不要陷入"我的编程语言应该保护我自己ℽ的谬论ㄢ`接下来,让我们考虑另一个狡猾的示例,它将前一示例中的恶带到另一个级别: `你可能认为这是不可能的,因为`一`永远不能等同于两者`二` _和_三`同时`ㄢ但是"同时ℽ是不准确的,因为第一个表达式_a=2_ `发生严`之前

a=3`ㄢ`那么,如果我们做`A. valueof()`每次调用时都有副作用,所以第一次返回时会有副作用ㄢ`二`第二次叫它回来ㄢ

```js
var i = 2;

Number.prototype.valueOf = function() {
	return i++;
};

var a = new Number( 42 );

if (a == 2 && a == 3) {
	console.log( "Yep, this happened." );
}
```

三

#### ?很容易: 

再说一遍,这些都是邪恶的把戏_隐性的_强制`= =`比较来自于falsy值表现令人惊讶的是当相互比较ㄢ

例如,我们在名单的角落都falsy值比较一下,看看哪些是合理的,这是麻烦: 

```js
"0" == null;			// false
"0" == undefined;		// false
"0" == false;			// true -- UH OH!
"0" == NaN;				// false
"0" == 0;				// true
"0" == "";				// false

false == null;			// false
false == undefined;		// false
false == NaN;			// false
false == 0;				// true -- UH OH!
false == "";			// true -- UH OH!
false == [];			// true -- UH OH!
false == {};			// false

"" == null;				// false
"" == undefined;		// false
"" == NaN;				// false
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
"" == {};				// false

0 == null;				// false
0 == undefined;			// false
0 == NaN;				// false
0 == [];				// true -- UH OH!
0 == {};				// false
```

在这24个比较表中,有17个比较合理和可预测ㄢ例如,我们知道`"ℽ`和`南`在所有合理的价值都没有,而且他们不强迫是宽松平等的,而`"0ℽ`和`零`是合理的,合理的_做_胁迫等于ㄢ

然而,七的比较都标有"哦,哦!ℽ因为误报,他们更可能会把你绊倒的陷阱ㄢ`"ℽ`和`零`绝对是完全不同的价值观,这是罕见的你想把他们视为合理的,所以他们的相互压制麻烦ㄢ注意这里没有任何假阴性ㄢ

#### 疯子

不过我们不必停在那里ㄢ我们可以继续寻找更麻烦的强制: 

```js
[] == ![];		// true
```

哦,这似乎是在一个更高层次的疯狂,权!?你的大脑可能欺骗你,你还是一个比较falsy值,所以`真正的`结果是令人惊讶的,因为我们_知道_一个价值不可同时还是和falsy!

但事实并非如此ㄢ让我们把它分解ㄢ关于这个我们知道些什么?`!`一元运算符?它明确地强迫一个`布尔`使用`布尔`规则(它也会翻转奇偶校验)ㄢ所以之前`[ =![ ]`甚至处理,实际上已经翻译成`[] = false`ㄢ我们已经在上面的列表中看到了这个表单ㄢ`false = [ [] ]`所以它的惊喜结果是_不是新的_我们ㄢ

其他街角的案子呢?

```js
2 == [2];		// true
"" == [null];	// true
```

正如我们早些时候所说的`第`讨论,右手边`[ 2 ]`和`[空]`价值观将通过`toprimitive`强制使它们更容易与简单原语相比较(`二`和`"ℽ`(分别)在左手边ㄢ自`valueof()`对于`阵列`值只是返回`阵列`本身,胁迫下的stringifying`阵列`ㄢ

`[ 2 ]`将成为`"2ℽ`那就是`第`强迫`二`对于第一比较中的右手边值ㄢ`[空]`直接成为`"ℽ`ㄢ

所以,`2 = 2`和`"ℽ"=ℽ`完全可以理解ㄢ

如果你的直觉是仍然不喜欢这些结果,你的挫折感并不是像你可能认为的那样ㄢ这实际上是对违约的控诉ㄢ`阵列`价值观`toprimitive`强迫一个行为`一串`价值ㄢ更可能的是,你只是希望`[ 2 ]ㄢtostring()`没有回报`"2ℽ`,或`[空]ㄢtostring()`没有回报`"ℽ`ㄢ

但究竟是什么_应该_这些`一串`强制转换的结果吗?我真的想不出其他合适的了ㄢ`一串`强制`[ 2 ]`比`"2ℽ`也许,除了`"[ 2 ]`但在其他情况下这可能很奇怪!

你可以正确地说明`字符串(NULL)`成为`"空ℽ`,然后`字符串([空])`也应该成为`"空ℽ`ㄢ这是一个合理的断言ㄢ所以,那才是真正的罪犯ㄢ

_隐性的_胁迫本身不是这里的邪恶ㄢ即使是一个_明确的_强制`[空]`一个`一串`结果`"ℽ`ㄢ不确定的是它是否明智ㄢ`阵列`价值观的内容stringify等效,到底这是怎么发生的ㄢ所以,你要对规则感到沮丧ㄢ`字符串([ⅆ])`因为那是疯狂的来源ㄢ也许应该没有字符串化所带来的威胁`阵列`真的吗?但是,就在语言的其他部分其他缺点很多ㄢ

另一个著名的引用问题: 

```js
0 == "\n";		// true
```

正如我们前面所讨论的,空的`"ℽ`,`"nℽ`(或`"ℽ`或任何其他空格组合)是被迫通过`第`结果是`零`ㄢ其他的什么`数`你期望的空白来要挟的价值吗?你是否感到烦恼?_明确的_ `数字("ℽ)`产量`零`?

真的是唯一合理的`数`空字符串或空白字符串可以强迫值是`南`ㄢ但那会_真正地_会更好吗?比较`"ℽ= =`当然会失败,但不清楚我们是否真的会失败ㄢ_固定的_任何潜在的担忧ㄢ

现实世界js程序失败的可能性是因为`0 == "\n"`非常罕见,这样的角案很容易避免ㄢ

类型转换**总是**在任何语言中都有死角,没有强迫的具体内容ㄢ这里的问题是猜测一组角的情况(也许是正确的)!但是,这并不是反对整体强制机制的一个突出论点ㄢ

底线: 几乎任何疯狂的胁迫之间_正常值_你可能会遇到(除了有意的狡猾)`valueof()`或`tostring()`黑客早)将归结为疑难杂症强制我们上述的七项短名单ㄢ

To contrast against these 24 likely suspects for coercion gotchas, consider another list like this:

```js
42 == "43";							// false
"foo" == 42;						// false
"true" == true;						// false

42 == "42";							// true
"foo" == [ "foo" ];					// true
```

在这些nonfalsy,noncorner例(和字面上有无限数量的比较我们可以P

#### 完整性检查

好吧,当我们深入研究的时候,我们肯定发现了一些疯狂的东西ㄢ_隐性的_强制ㄢ难怪大多数开发商声称强制是邪恶的,应该避免,对吗?!?

但是让我们后退一步,做一个健康检查ㄢ

通过大小比较,我们有_一个列表_七麻烦了强制,但我们有_另一个列表_的(至少17,但实际上是无限的)强制,完全清醒和解释ㄢ

如果你正在寻找一个教科书"把婴儿连同洗澡水一起倒掉,"这就是: 丢弃强迫整体(安全行为)和有用的无限大名单,因为名单真的只是七的陷阱ㄢ

更谨慎的反应是: "我如何使用无数?_好的部分_胁迫,但避免少数_坏的部分_?ℽ

让我们再看看_坏的_列表: 

```js
"0" == false;			// true -- UH OH!
false == 0;				// true -- UH OH!
false == "";			// true -- UH OH!
false == [];			// true -- UH OH!
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
0 == [];				// true -- UH OH!
```

清单上七项中的四项涉及`= =假`比较,我们前面说过,你应该**永远,永远**避免ㄢ这是一个很容易记住的规则ㄢ

现在名单下降到三个ㄢ

```js
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
0 == [];				// true -- UH OH!
```

这些是合理的强制你做在一个正常的JavaScript程序吗?他们在什么情况下真的会发生?

我不认为你真的会使用它ㄢ`= [ [] ]`在一个`布尔`在你的程序中测试,至少不知道你在做什么ㄢ你可能会这样做`="ℽ`或`= = 0`,像: 

```js
function doSomething(a) {
	if (a == "") {
		// ..
	}
}
```

如果你不小心叫有啊`做(0)`或`做([ ])`ㄢ另一个场景: 

```js
function doSomething(a,b) {
	if (a == b) {
		// ..
	}
}
```

同样,如果你做了类似的事情,这可能会崩溃ㄢ`("做ℽ,0)`或`做([ ],ℽ)`ㄢ

所以,尽管情况_可以_存在这些强制会咬你,你就要小心周围的人,他们可能不是超级常见的对您的代码库的整体ㄢ

#### 安全地使用隐性强制

我能给你的最重要的建议是: 检查你的程序和关于什么值可以出现在A的两边的原因ㄢ`= =`比较ㄢ为了有效避免这种比较的问题,以下是一些启发式规则: 

1.  如果比较的任何一方都可以`真正的`或`假`价值观,永远不要使用`= =`ㄢ
2.  如果比较的任何一方都可以`[ ]`,`"ℽ`,或`零`价值观,认真考虑不使用`= =`ㄢ

在这些场景中,使用`= = =`而不是`= =`为了避免不必要的胁迫ㄢ遵循这两个简单的规则,几乎所有的强制陷阱,可以合理地将有效地避免伤害你ㄢ

**在这些情况下,更明确/详细的话可以帮你避免很多麻烦ㄢ**

的问题`= =`vs.`= = =`是否真的被适当地框为: 是否允许强制比较?

有很多情况下,这种强制是有益的,让你更加简洁地表达一些比较逻辑(如`无效的`和`未定义`例如)ㄢ

在总体方案中,相对较少的情况下_隐性的_胁迫确实是危险的ㄢ但在那些地方,为了安全起见,一定要使用ㄢ`= = =`ㄢ

**提示: **另一个受到胁迫的地方_不_咬你是与`类型`算子ㄢ`类型`总是返回七个字符串中的一个(参见第1章),没有一个是空的ㄢ`"ℽ`字符串ㄢ因此,没有的情况下,检查一些值的类型要触犯_隐性的_强制ㄢ`类型= ="功能ℽ`100%是否安全可靠?`类型= = ="功能ℽ`ㄢ从字面上看,规范说算法在这种情况下是相同的ㄢ所以,不要盲目地使用`= = =`到处都是因为那是你的代码工具告诉你做的,或者(最糟糕的),因为你在某本书中被告知**不去想它**ㄢ您拥有代码的质量ㄢ

是_隐性的_胁迫邪恶和危险?在少数情况下,是的,但绝大多数情况下,没有ㄢ

做一个负责任ㄡ成熟的开发人员ㄢ学习如何使用强制的力量(两者都是)_明确的_和_隐性的_)安全有效ㄢ并且教你周围的人做同样的事情ㄢ

这是一种简便的表由Alex Dorey(@多雷在GitHub)设想的各种比较: 

<img src="fig1.png" width="600">

源: [https://github.com/dorey/javascript-equality-table](https://github.com/dorey/JavaScript-Equality-Table)

## 摘要关系比较

虽然这部分_隐性的_强迫通常很少受到关注,但重要的是要考虑发生了什么ㄢ`< B`比较(类似于我们刚刚检查过的`a == b`深入地)ㄢ

在第11.8.5 ES5的"抽象关系ℽ的比较算法基本上分为两部分: 做什么如果比较涉及`一串`值(下半部分)或其他(上半部分)ㄢ

**注: **该算法仅定义为`< B`ㄢ所以,`一> B`是处理`B<`ㄢ

算法首先调用`toprimitive`对两个值进行强制,如果两个调用的返回结果都不是`一串`然后,两个值都被强制`数`值的使用`第`运算规则,并进行数值比较ㄢ

例如:

```js
var a = [ 42 ];
var b = [ "43" ];

a < b;	// true
b < a;	// false
```

**注: **类似的告诫`- 0`和`南`应用在这里,因为他们在`= =`算法盘

但是,如果两个值都是`一串`对于`<`比较简单的字典(自然拼音)上进行特征比较: 

```js
var a = [ "42" ];
var b = [ "043" ];

a < b;	// false
```

`一`和`B`是_不_强迫`数`S,因为它们最终都是`一串`后`toprimitive`胁迫两人`阵列`所以,`"42ℽ`按字符比较`"043ℽ`从第一个字符开始`"4ℽ`和`"0ℽ`,分别ㄢ自`"0ℽ`在字典序_小于_比`"4ℽ`比较返回`假`ㄢ

同样的行为和推理也适用于: 

```js
var a = [ 4, 2 ];
var b = [ 0, 4, 3 ];

a < b;	// false
```

在这里,`一`成为`"4ℽ`和`B`成为`"0,4,3ℽ`,和那些字典比较与以前的片段ㄢ

怎么样: 

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// ??
```

`< B`是也`假`,因为`一`成为`[对象]`和`B`成为`[对象]`如此清楚`一`不是字典序小于`B`ㄢ

但奇怪的是: 

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// false
a == b;	// false
a > b;	// false

a <= b;	// true
a >= b;	// true
```

为什么`a == b`不`真正的`?它们是一样的ㄢ`一串`价值(`"[对象对象]`)看来它们应该相等,对吧?不.回想先前关于如何进行的讨论`= =`作品`对象`引用ㄢ

但那怎么会呢?`a = b`和`a = b`导致`真正的`,如果`< B` **和** `a = b` **和** `一> B`都是`假`?

因为规格说明`a = b`它实际上会评估`B<`首先,然后否定这个结果ㄢ自`B<`是_也_ `假`,结果`a = b`是`真正的`ㄢ

这很可能与你可能解释的相反ㄢ`< =`直到现在,这可能是字面上的: "小于_或_等于"JS更准确地考虑`< =`"不大于ℽ`!(a)`,js将其视为`!(b <)`)ㄢ此外,`a = b`首先解释为`b =`然后应用同样的推理ㄢ

不幸的是,没有"严格的关系比较ℽ,因为这是平等的ㄢ换句话说,没有办法阻止ㄢ_隐性的_用关系比较产生的强制`< B`除了确保`一`和`B`在进行比较之前,都是同类型的ㄢ

用我们早先的推理`= =`vs.`= = =`理智检查讨论ㄢ如果强制是有益的和相当安全的,例如`42 < < 43 >`比较,**使用它**ㄢ另一方面,如果您需要对关系比较安全,_明确强制_值在使用前先`<`(或其对应者)ㄢ

```js
var a = [ 42 ];
var b = "043";

a < b;						// false -- string comparison!
Number( a ) < Number( b );	// true -- number comparison!
```

## 回顾

在本章中,我们将注意力转向JavaScript类型转换是如何发生的,称为**强制**,其特征可以是_明确的_或_隐性的_ㄢ

胁迫会受到不良影响,但实际上它在很多情况下非常有用ㄢ负责任的js开发人员的一个重要任务是花时间去学习所有的胁迫的来龙去脉,以决定哪些部分有助于改进代码,哪些部分是他们真正应该避免的ㄢ

_明确的_强制是代码,很明显其意图是将值从一种类型转换为另一种类型ㄢ好处是通过减少混淆来提高代码的可读性和可维护性ㄢ

_隐性的_强制是作为其他操作的副作用"隐藏ℽ的强制,在这种情况下不会出现类型转换ㄢ虽然似乎是_隐性的_胁迫是相反的ㄢ_明确的_因此,这是糟糕的(事实上,很多人都这么认为!)实际上,_隐性的_强制也是提高代码可读性的方法ㄢ

尤其是_隐性的_胁迫必须有责任地ㄡ有意识地使用ㄢ知道你为什么要写你正在写的代码,以及它是如何工作的ㄢ努力编写别人容易学习和理解的代码ㄢ
