
# 你不知道JS: 类型和语法

# 第2章价值观

`阵列`S,`一串`S,和`数`s是任何程序的最基本的构建块,但是JavaScript有一些独特的特性,这些类型可能会让您感到高兴或困惑. 

让我们看看js中的几个内置值类型,并探索如何更充分地理解和正确利用它们的行为. 

## 阵列

与其他类型强制语言相比,JavaScript`阵列`s只是用于任何类型值的容器,从`一串`到`数`到`对象`甚至另一个`阵列`(这就是你如何得到多维的. `阵列`S). 

```js
var a = [ 1, "2", [3] ];

a.length;		// 3
a[0] === 1;		// true
a[2][0] === 3;	// true
```

你不需要presize你`阵列`S(参见第3章中的"数组"),您只需声明它们并添加相应的值即可: 

```js
var a = [ ];

a.length;	// 0

a[0] = 1;
a[1] = "2";
a[2] = [ 3 ];

a.length;	// 3
```

**警告: **使用`删除`在一个`阵列`值将从`阵列`但是,即使去掉最后一个元素,它也会**不**更新`长度`财产,所以要小心!我们将负责`删除`第5章更详细地说明运算符本身. 

小心创建"稀疏"`阵列`(离开或创建空/缺槽): 

```js
var a = [ ];

a[0] = 1;
// no `a[1]` slot set here
a[2] = [ 3 ];

a[1];		// undefined

a.length;	// 3
```

当它工作时,它会导致一些混乱的行为与你之间的"空白槽". 虽然插槽似乎有`未定义`在它的值中,它不会像槽显式设置一样. `[ 1 ] =未定义的`). 更多信息请参见第3章中的"数组". 

`阵列`s是数值索引的(正如你所期望的),但棘手的是它们也是可以拥有的对象. `一串`添加到它们的键/属性(但不计入`长度`的`阵列`): 

```js
var a = [ ];

a[0] = 1;
a["foobar"] = 2;

a.length;		// 1
a["foobar"];	// 2
a.foobar;		// 2
```

然而,一个问题需要注意的是,如果一个`一串`价值作为一个键可以强制转换为一个标准的10`数`然后,假设您希望将其用作`数`索引而不是`一串`关键!

```js
var a = [ ];

a["13"] = 42;

a.length; // 14
```

一般来说,这不是一个好主意. `一串`键/属性到`阵列`美国使用`对象`s用于保存键/属性中的值,并保存`阵列`严格数值索引值. 

### 阵列的喜欢

有些时候你需要转换一个`阵列`类似值(数值索引的值集合)为真`阵列`通常可以调用数组实用程序(如`IndexOf(..)`,`concat(..)`,`foreach(..)`反对价值的收集. 

例如,各种DOM查询操作返回不正确的DOM元素列表. `阵列`不过是`阵列`-像我们转换的目的一样. 另一个常见的例子是函数暴露`争论`(`阵列`类)对象(如6,弃用)访问参数列表. 

进行这种转换的一种非常常见的方法是借用`切片(..)`效用与价值的对立: 

```js
function foo() {
	var arr = Array.prototype.slice.call( arguments );
	arr.push( "bam" );
	console.log( arr );
}

foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如果`slice()`没有任何其他参数调用,因为它有效地在上面的代码段中,其参数的默认值具有复制的效果. `阵列`(或者,在这种情况下),`阵列`(像). 

截至6,还有一个内置的工具称为`数组(ⅆ)`可以做同样的任务: 

```js
...
var arr = Array.from( arguments );
...
```

**注: ** `数组(ⅆ)`有几个强大的功能,并将详细介绍在_6与超越_本系列的标题. 

## 串

这是一个很普遍的信念. `一串`基本上只是`阵列`字符集. 虽然在盖下的实施可以或不可以使用`阵列`s,重要的是要认识到JavaScript`一串`S真的不一样`阵列`字符集. 相似之处大多是肤浅的. 

例如,让我们考虑这两个值: 

```js
var a = "foo";
var b = ["f","o","o"];
```

弦有一个浅的相似之处. `阵列`S -`阵列`-比如,如上所述,它们都有一个`长度`产权,一`IndexOf(..)`方法(`阵列`版本仅作为ES5),和`concat(..)`方法: 

```js
a.length;							// 3
b.length;							// 3

a.indexOf( "o" );					// 1
b.indexOf( "o" );					// 1

var c = a.concat( "bar" );			// "foobar"
var d = b.concat( ["b","a","r"] );	// ["f","o","o","b","a","r"]

a === c;							// false
b === d;							// false

a;									// "foo"
b;									// ["f","o","o"]
```

所以,它们基本上都是"字符数组",对吗?**不完全**: 

```js
a[1] = "O";
b[1] = "O";

a; // "foo"
b; // ["f","O","o"]
```

JavaScript`一串`s是不可变的,而`阵列`s是相当可变的. 此外,该`[ 1 ]`字符位置访问表单并不总是有效的JavaScript. 旧版本的IE不允许这种语法(但是现在它们). 相反,该_对的_方法已`(1)a.charat`. 

不可改变的另一个结果`一串`S: 那不是吗?`一串`更改内容的方法可以就地修改,但必须创建并返回新的`一串`相比之下,许多改变的方法. `阵列`内容其实_做_就地修改. 

```js
c = a.toUpperCase();
a === c;	// false
a;			// "foo"
c;			// "FOO"

b.push( "!" );
b;			// ["f","O","o","!"]
```

此外,许多`阵列`处理时可能有帮助的方法`一串`S实际上并不是为他们提供的,但是我们可以"借用"非突变. `阵列`方法对我们`一串`: 

```js
a.join;			// undefined
a.map;			// undefined

var c = Array.prototype.join.call( a, "-" );
var d = Array.prototype.map.call( a, function(v){
	return v.toUpperCase() + ".";
} ).join( "" );

c;				// "f-o-o"
d;				// "F.O.O."
```

让我们再举一个例子: 扭转a`一串`(顺便提一下,一个常见的JavaScript面试琐事问题!). `阵列`有一个`reverse()`在赋值方法,但`一串`S不: 

```js
a.reverse;		// undefined

b.reverse();	// ["!","o","O","f"]
b;				// ["!","o","O","f"]
```

不幸的是,这种"借用"不起作用. `阵列`应用程序,因为`一串`s是不可变的,因此不能进行适当的修改: 

```js
Array.prototype.reverse.call( a );
// still returns a String object wrapper (see Chapter 3)
// for "foo" :(
```

另一个解决方法(又名Hack)是转换`一串`为一个`阵列`执行所需的操作,然后将其转换为`一串`. 

```js
var c = a
	// split `a` into an array of characters
	.split( "" )
	// reverse the array of characters
	.reverse()
	// join the array of characters back to a string
	.join( "" );

c; // "oof"
```

如果感觉到了UG_它的工作原理_对于简单的`一串`的,所以如果你需要什么东西quick-n-dirty,往往这样的方法来完成工作. 

**警告: **小心!这种方法**不工作**对于`一串`的复杂(Unicode)中的角色(星体符号,多字节字符,等). 您需要更为复杂的库实用程序,Unicode知道这些操作要准确地处理. 参照Mathias Bynens的工作主题: _esrever_(<https://github.com/mathiasbynens/esrever>). 

另一种方法是: 如果你更经常地在你的"字符串"上做任务,把它们当作基本的来对待. _字符数组_也许最好把它们实际储存起来. `阵列`而不是`一串`你可能会为自己节省很多麻烦. `一串`到`阵列`每一次. 你可以随时打电话给我`加入("")`上`阵列` _字符_每当你真的需要`一串`表示. 

## 数

JavaScript只有一个数字类型: `数`. 此类型包括"整数"值和小数小数. 我在引号里说"整数",因为长期以来一直在批评JS,说不存在真正的整数,就像其他语言一样. 这在将来的某个时候可能会改变,但就目前而言,我们只有`数`代表一切. 

因此,在js中,"整数"只是一个没有小数小数值的值. 这是,`四十二`等于"整数"`四十二`. 

像大多数现代语言,包括几乎所有的脚本语言一样,JavaScript的实现也是如此. `数`S是基于"IEEE 754"标准,通常称为"浮点",JavaScript具体使用标准的"双精度"格式(又名"64位二进制"). 

有很多关于如何二进制浮点数存储在内存中的细节的网络写作,以及这些选择的影响. 因为理解内存中的位模式并不是严格理解正确使用的必要条件. `数`在JS中,我们将把它作为一个练习给感兴趣的读者,如果您想进一步深入研究IEEE 754细节的话. 

### 数字的语法

数字面值通常10十进制文字JavaScript中的表达. 例如:

```js
var a = 42;
var b = 42.3;
```

十进制值的前导部分,如果`零`是可选的: 

```js
var a = 0.42;
var b = .42;
```

类似地,十进制值后面的小数部分(小数部分). `. `,如果`零`是可选的: 

```js
var a = 42.0;
var b = 42.;
```

**警告: ** `42. `这是非常不寻常的,如果你试图避免别人阅读你的代码时会产生混乱,这可能不是个好主意. 但是,它是有效的. 

默认情况下,大多数`数`将普通的小数输出,与落后的分数`零`删除. 所以: 

```js
var a = 42.300;
var b = 42.0;

a; // 42.3
b; // 42
```

非常大的或非常小的`数`默认情况下,s将以指数形式输出,与输出的输出相同. `toexponential()`方法,如: 

```js
var a = 5E10;
a;					// 50000000000
a.toExponential();	// "5e+10"

var b = a * a;
b;					// 2.5e+21

var c = 1 / a;
c;					// 2e-11
```

因为`数`值可以用`数`对象包装器(见第3章),`数`值可以访问内置的方法. `number.prototype`(见第3章). 例如,`固定(..)`方法允许指定要表示的值的小数小数位数: 

```js
var a = 42.59;

a.toFixed( 0 ); // "43"
a.toFixed( 1 ); // "42.6"
a.toFixed( 2 ); // "42.59"
a.toFixed( 3 ); // "42.590"
a.toFixed( 4 ); // "42.5900"
```

请注意,输出实际上是`一串`表示的`数`值是`零`-在右边垫如果你要求比价值更小数持有. 

`精密(..)`是相似的,但指定多少_有意义的数字_应该用来代表价值: 

```js
var a = 42.59;

a.toPrecision( 1 ); // "4e+1"
a.toPrecision( 2 ); // "43"
a.toPrecision( 3 ); // "42.6"
a.toPrecision( 4 ); // "42.59"
a.toPrecision( 5 ); // "42.590"
a.toPrecision( 6 ); // "42.5900"
```

您不必使用变量中的值来访问这些方法;您可以直接访问这些方法. `数`文字. 但是你必须小心`. `算子. 自`. `是一个有效的数字字符,它将首先被解释为`数`文字,如果可能的话,而不是被解释为一个属性访问器. 

```js
// invalid syntax:
42.toFixed( 3 );	// SyntaxError

// these are all valid:
(42).toFixed( 3 );	// "42.000"
0.42.toFixed( 3 );	// "0.420"
42..toFixed( 3 );	// "42.000"
```

`42固定资产(3). `是无效语法,因为`. `被吞噬的一部分`42. `文字(这是有效的-见上面!)所以没有`. `物业经营者目前,使`固定的. `访问. 

`42ㄡ固定资产(3)`因为第一个工作`. `是ⅆ的一部分`数`第二`. `是属性运算符吗?. 但它可能看起来很奇怪,事实上在JavaScript代码中很少看到类似的东西. 事实上,直接访问任何原始值的方法并不常见. 不寻常并不意味着_坏的_或_错误的_. 

**注: **有扩展内部的库. `number.prototype`(参见第3章)提供额外的操作`数`所以,在这些情况下,使用类似于`10ㄡmakeitrain()`要掀起一场10秒的钱雨动画,或者其他愚蠢的东西. 

这在技术上也是有效的(注意空间): 

```js
42 .toFixed(3); // "42.000"
```

然而,随着`数`文字具体,**这是特别令人困惑的编码风格. **除了让其他开发者(以及未来的自己)困惑之外,别无其他目的. 避免它. 

`数`s也可以用指数形式指定,在表示较大时是通用的. `数`s,例如: 

```js
var onethousand = 1E3;						// means 1 * 10^3
var onemilliononehundredthousand = 1.1E6;	// means 1.1 * 10^6
```

`数`点燃

这些格式在当前版本的JavaScript中工作: 

```js
0xf3; // hexadecimal for: 243
0Xf3; // ditto

0363; // octal for: 243
```

**注: **从6 +`严格的`的方式,`0363`八进制文字的格式不再被允许(见下面的新表单). 这个`0363`表格仍然允许在非ℴ`严格的`模式,但无论如何,您应该停止使用它,以便将来友好(并且应该使用). `严格的`模式现在!). 

截至6,以下的新形式,也是有效的: 

```js
0o363;		// octal for: 243
0O363;		// ditto

0b11110011;	// binary for: 243
0B11110011; // ditto
```

请给你的开发人员一个帮助: 不要使用`0o363`形式. `零`未来的资本`o`只是要求混淆. 始终使用小写谓词`0x`,`0b`,和`0o`. 

### 小的十进制值

使用二进制浮点数最有名的副作用(记住,这是真的)**全部的**使用IEEE 754的语言ℴℴ不是_只是_JavaScript是许多假设/假装的): 

```js
0.1 + 0.2 === 0.3; // false
```

从数学上来说,我们知道语句应该是`真正的`. 这是为什么`假`?

简单地说,表示`零点一`和`零点二`二进制浮点数不精确,所以当它们相加时,结果并不准确. `零点三`. 它是**真正地**关闭: `零点三零零零零零零零零零零零零零零零`但是如果你的比较失败,"关闭"是无关紧要的. 

**注: **JavaScript是否应该切换到另一个`数`对所有值都有精确表示的实现吗?有些人这样认为. 多年来出现了许多替代品. 他们都没有被接受,也许永远也不会被接受. 看起来很简单,只要挥挥手,说,"修复这个错误已经!"这并不那么容易. 如果是的话,那肯定是很久以前就改变过的. 

现在的问题是,如果有的话`数`S不能_可信的_确切地说,这是否意味着我们不能使用?`数`真的吗?**当然不是.**

有些应用程序需要更加小心,特别是在处理小数小数时. 也有很多(也许是最多的)?只处理整数(整数)的应用程序,而且只处理数以百万或万亿的数字. 这些应用程序一直都是,**绝对安全**在js中使用数字运算. 

如果我们_做_需要比较两个`数`的,像`0.1 + 0.2`到`零点三`知道简单的相等测试失败了吗?

最普遍接受的做法是使用一个很小的"舍入错误"值作为_容忍_比较. 这个极小值通常被称为"机器ε",这是常见的. `2 - 52`(`2.220446049250313e-16`)对于那种`数`JavaScript的S. 

截至6,`number.epsilon`这是预定义的公差值,因此你会想使用它,但你可以定义为pre-es6 polyfill: 

```js
if (!Number.EPSILON) {
	Number.EPSILON = Math.pow(2,-52);
}
```

我们可以用这个`number.epsilon`比较两`数`s为"相等"(在舍入误差范围内): 

```js
function numbersCloseEnoughToEqual(n1,n2) {
	return Math.abs( n1 - n2 ) < Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual( a, b );					// true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );	// false
```

可以表示的最大浮点值大致是`1.798e + 308`(真的,真的,真的非常大!)为您预定义`number.max_value`. 在小端,`number.min_value`大约是`5e-324`这不是负值,但实际上接近零!

### 安全的整数范围

因为如何`数`s表示,有一系列的"安全"值. `数`"整数",它明显小于`number.max_value`. 

能的最大整数的"安全"表示(即有一个保证请求的值实际上是表示明确)是`2 - 53 - 1`,这是`九千零七兆一千九百九十二亿五千四百七十四万零九百九十一`. 如果你将你的逗号,你会看到,这是刚刚超过9万亿. 那真是太大了`数`范围可达. 

这个值实际上是自动预定在6,为`number.max_safe_integer`. 毫无疑问,有一个最小值,`- 9007199254740991`,和它的定义为在6`number.min_safe_integer`. 

js程序处理大量数据的主要方式是处理数据库中的64位ID等. 64位数字不能准确地用`数`类型,所以必须存储在(并发送到/从)JavaScript使用`一串`表示. 

在如此大的ID上进行数字操作`数`值(除了比较)`一串`还好,还好吗?. 但如果你_做_需要在这些非常大的值上执行数学运算,现在您需要使用_大数_效用. 在未来版本的JavaScript中,大数可能获得官方支持. 

### 测试整数

如果要测试一个值是一个整数,你可以使用6指定`数. 霍耳(..)`: 

```js
Number.isInteger( 42 );		// true
Number.isInteger( 42.000 );	// true
Number.isInteger( 42.3 );	// false
```

以polyfill`数. 霍耳(..)`对于pre-es6: 

```js
if (!Number.isInteger) {
	Number.isInteger = function(num) {
		return typeof num == "number" && num % 1 == 0;
	};
}
```

测试值是否为_安全的整数_使用指定的,6`数. issafeinteger(..)`: 

```js
Number.isSafeInteger( Number.MAX_SAFE_INTEGER );	// true
Number.isSafeInteger( Math.pow( 2, 53 ) );			// false
Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );		// true
```

以polyfill`数. issafeinteger(..)`在pre-es6浏览器: 

```js
if (!Number.isSafeInteger) {
	Number.isSafeInteger = function(num) {
		return Number.isInteger( num ) &&
			Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
	};
}
```

### 32位(带符号)整数

在整数的范围可以高达大约9万亿安全(53位),还有一些数字运算(如按位运算符),只定义为32`数`s,所以"安全范围"`数`那样使用的S肯定要小得多. 

当时的范围是`数学. 战俘(- 2,31)`(`- 2147483648`,大约21亿)`数学. 战俘(2,31)`(`二十一亿四千七百四十八万三千六百四十七`, about +2.1 billion).

给力`数`价值`一`使用32位有符号整数值,使用`一个Ɯ 0`. 这是因为`Ɯ`位运算符只能用于32位整数的值(这意味着它可以只关注32位,其他位都将丢失). 那么,"or'ing"零本质上是一个没有OP位说. 

**注: **某些特殊值(我们将在下一节中介绍),例如`南`和`无穷`是不是"32位安全",这些价值观传递给一位运算符将通过抽象操作`toint32`(见第4章)并成为简单的`+ 0`对,位运算的目的价值. 

## 特殊值

有几种特殊的值分布在各种类型的_警觉的_js开发人员需要注意并正确使用. 

### 非价值价值

对于`未定义`类型,只有一个和唯一一个值: `未定义`. 对于`无效的`类型,只有一个和唯一一个值: `无效的`. 因此,对他们来说,标签既是它的类型,也是它的价值. 

两`未定义`和`无效的`通常被视为可互换的"空"值或"非"值. 其他开发人员喜欢用细微差别区分它们. 例如:

-   `无效的`是空值. 
-   `未定义`是缺少的值

或: 

-   `未定义`还没有值
-   `无效的`有了价值,不再有价值

不管您如何选择"定义"并使用这两个值,`无效的`是一个特殊的关键字,而不是一个标识符,因此你不能把它当作一个赋值变量!?). 然而,`未定义` _是_(不幸)标识符. 哦. 

### 未定义

在非ℴ`严格的`模式,它实际上是可能的(尽管非常不明智!)将值分配给全局提供的`未定义`标识符: 

```js
function foo() {
	undefined = 2; // really bad idea!
}

foo();
```

```js
function foo() {
	"use strict";
	undefined = 2; // TypeError!
}

foo();
```

在两个非ℴ`严格的`模式和`严格的`但是,您可以创建名称的本地变量. `未定义`. 但是,这是一个可怕的想法!

```js
function foo() {
	"use strict";
	var undefined = 2;
	console.log( undefined ); // 2
}

foo();
```

**朋友不让朋友凌驾`未定义`. **曾经. 

#### `无效`算子

而`未定义`是内置的标识符(除非修改-见上面!)内置`未定义`值,获得此值的另一种方法是`无效`算子. 

的表达`无效___`"空洞"输出任何值,因此表达式的结果总是`未定义`价值. 它不会修改现有的值,它只是确保没有从运算符表达式返回值. 

```js
var a = 42;

console.log( void a, a ); // undefined 42
```

按照惯例(主要是由C语言编程),代表`未定义`通过使用独立的值`无效`你会用`无效0`(尽管很清楚`空洞的真实`或任何其他`无效`表达式做同样的事情). 两者之间没有实际的区别. `无效0`,`无效1`,和`未定义`. 

但`无效`如果需要确保表达式没有结果值(即使它有副作用),则在其他一些情况下,运算符也可能是有用的. 

例如:

```js
function doSomething() {
	// note: `APP.ready` is provided by our application
	if (!APP.ready) {
		// try again later
		return void setTimeout( doSomething, 100 );
	}

	var result;

	// do some other stuff
	return result;
}

// were we able to do it right away?
if (doSomething()) {
	// handle next tasks right away
}
```

这里的`setTimeout(..)`函数返回一个数值(计时器间隔的唯一标识符,如果您想取消它),但我们希望`无效`这样我们的函数的返回值不会给出假阳性. `如果`声明. 

很多开发者喜欢做这些动作分开,工作也不使用`无效`算子: 

```js
if (!APP.ready) {
	// try again later
	setTimeout( doSomething, 100 );
	return;
}
```

一般来说,如果有一个值存在的地方(从某个表达式),你会发现它的值是有用的. `未定义`相反,使用`无效`算子. 这可能在你的程序中并不常见,但在极少数情况下,你确实需要它,它可能会非常有用. 

### 特殊的数字

这个`数`类型包含几个特殊值. 我们将详细地看看每一个细节. 

#### 不是数字,不是数字

没有两个操作数都执行的任何数学运算. `数`s(或可以被解释为规则的值)`数`s在基10或基16)将导致操作失败产生有效的. `数`在这种情况下,你会得到`南`价值. 

`南`字面上的意思是"不是"`数`"虽然这个标签/描述非常糟糕和误导,我们很快就会看到. 想想就更准确了. `南`至于"无效号码"ㄡ"失败号码"ㄡ甚至"坏数字",都不如认为它"不是数字". 

例如:

```js
var a = 2 / "foo";		// NaN

typeof a === "number";	// true
```

换句话说: "非数字类型的电话号码!"对于混淆的名称和语义万岁. 

`南`是一种"哨兵值"(另一个正常值,它被赋予一个特殊的含义),它代表了一种特殊的错误条件. `数`集. 错误的本质是: "我试图进行数学运算,但失败了,所以失败了. `数`结果相反. "

所以,如果你在某个变量中有一个值,并且想测试它是否是这个特殊的失败数字. `南`你可能认为你可以直接比较`南`本身,就像你可以用任何其他的价值一样`无效的`或`未定义`. 不.

```js
var a = 2 / "foo";

a == NaN;	// false
a === NaN;	// false
```

`南`是一个非常特殊的值,因为它永远不等于另一个值. `南`值(即,它从不等于它本身). 事实上,这是唯一的价值,不是自反的. `x=x`). 所以,`南!= =南`. 有点奇怪,是吧?

所以如何_做_我们测试它,如果我们不能相比`南`(因为这种比较总是失败)?

```js
var a = 2 / "foo";

isNaN( a ); // true
```

很容易,对吧?我们使用内置的全局实用程序调用`isnan(..)`它告诉我们值是不是`南`或不. 问题解决了!

不这么快. 

这个`isnan(..)`实用程序有致命缺陷. 看来它试图理解`南`"(不是一个数字)"过于随便ℴℴ它的工作基本上是: "测试传递的东西是否不是`数`或是一个`数`"但那不太准确. ". 

```js
var a = 2 / "foo";
var b = "foo";

a; // NaN
b; // "foo"

window.isNaN( a ); // true
window.isNaN( b ); // true -- ouch!
```

明确,`"foo"`是真的_不是一个`数`_但绝对不是`南`价值!这个bug从一开始就存在于JS中(超过19年). _哎哟_). 

截至6,最后的一个置换效用提供了: `数. isnan(..)`. 一个简单的polyfill它让你可以安全的检查`南`价值观_现在_即使在pre-es6浏览器: 

```js
if (!Number.isNaN) {
	Number.isNaN = function(n) {
		return (
			typeof n === "number" &&
			window.isNaN( n )
		);
	};
}

var a = 2 / "foo";
var b = "foo";

Number.isNaN( a ); // true
Number.isNaN( b ); // false -- phew!
```

实际上,我们可以实现一个`数. isnan(..)`polyfill更容易,利用特殊的事实`南`不等于自己. `南`是的_只有_在整个语言中,这是真的,其他的值总是. **等于它本身**. 

所以: 

```js
if (!Number.isNaN) {
	Number.isNaN = function(n) {
		return n !== n;
	};
}
```

很奇怪,是吧?但它有效!

`南`在许多真实的js程序中,S可能是有意或偶然的. 使用可靠的测试确实是个好主意,比如`数. isnan(..)`提供(或polyfilled),承认他们的正确. 

如果您目前正在使用`isnan(..)`在一个程序中,可悲的现实是你的程序. _有一个bug_即使你还没有被它咬过!

#### 无穷大

像C这样的传统编译语言的开发人员可能习惯于看到编译器错误或运行时异常,如"除以0"之类的操作: 

```js
var a = 1 / 0;
```

然而,在js中,这个操作是定义好的,结果是值. `无穷`(又名`number.positive_infinity`). 不出所料: 

```js
var a = 1 / 0;	// Infinity
var b = -1 / 0;	// -Infinity
```

正如你所看到的,`无穷`(又名`number.negative_infinity`结果是由零除以任一(但不是两者都有!)在分区操作数中是负的. 

js使用有限数值表示(我们前面提到的IEEE 754浮点),所以与纯数学相反,它似乎是. _是_即使是像加法或减法这样的操作也可能溢出,在这种情况下你会得到`无穷`或`无穷`. 

例如:

```js
var a = Number.MAX_VALUE;	// 1.7976931348623157e+308
a + a;						// Infinity
a + Math.pow( 2, 970 );		// Infinity
a + Math.pow( 2, 969 );		// 1.7976931348623157e+308
```

根据规范,如果像加法这样的运算结果值太大,无法表示,IEEE 754"圆到最近"模式指定结果应该是什么. 因此,从粗略的意义上讲,`number.max_value +数学. 战俘(2, 969)`接近`number.max_value`比`无穷`所以它"滚下",而`number.max_value +数学. 战俘(2, 970)`接近`无穷`所以它"围捕". 

如果你想得太多,那会让你头疼的. 别这样,认真的,停下来!

一旦你溢出到其中任何一个_无穷大_但是,没有回头路. 换言之,在诗意的意义上,你可以从有限到无限,而不是从无限的返回到有限的. 

问: "无穷除以无穷是什么?". 我们天真的大脑可能会说"1"或"无穷大",但事实并非如此. 数学上和JavaScript上,`无限无限`不是定义的操作. 在js中,这导致`南`. 

但什么是正有限的`数`除以`无穷`?那很容易!`零`. 那么负的有限呢?`数`除以`无穷`?继续阅读!

#### 零点

虽然它可能会混淆数学头脑的读者,JavaScript都有一个正常的零. `零`(否则称为正零)`+ 0`)_和_负零`- 0`. Before we explain why the`- 0`存在时,我们应该检查JS如何处理它,因为它可能非常混乱. 

除了字面上的指定`- 0`负零也是某些数学运算的结果. 例如:

```js
var a = 0 / -3; // -0
var b = 0 * -3; // -0
```

加减法不能产生负零. 

在开发人员控制台检查时,负零通常会显示出来. `- 0`虽然直到最近才出现这种情况,所以有些老的浏览器可能仍然会报告它. `零`. 

但是,如果你试图stringify负零价值,它总是会报道`"0"`,根据规格. 

```js
var a = 0 / -3;

// (some browser) consoles at least get it right
a;							// -0

// but the spec insists on lying to you!
a.toString();				// "0"
a + "";						// "0"
String( a );				// "0"

// strangely, even JSON gets in on the deception
JSON.stringify( a );		// "0"
```

有趣的是,反向操作(从`一串`到`数`不要撒谎: 

```js
+"-0";				// -0
Number( "-0" );		// -0
JSON.parse( "-0" );	// -0
```

**警告: **这个`(0)stringify JSON. `行为`"0"`当你观察到它与反向不一致时,就特别奇怪了: `解析("- 0")`报告`- 0`正如你所期望的. 

除了负零欺骗隐瞒其真实价值的字符串化所带来的,比较运算符也(故意)配置_躺_. 

```js
var a = 0;
var b = 0 / -3;

a == b;		// true
-0 == 0;	// true

a === b;	// true
-0 === 0;	// true

0 > -0;		// false
a > b;		// false
```

显然,如果你想区分一个`- 0`从一个`零`在你的代码中,你不能仅仅依靠开发者控制台输出的东西,所以你必须更聪明一点: 

```js
function isNegZero(n) {
	n = Number( n );
	return (n === 0) && (1 / n === -Infinity);
}

isNegZero( -0 );		// true
isNegZero( 0 / -3 );	// true
isNegZero( 0 );			// false
```

现在,除了学术琐事,我们为什么还需要负零呢?

在某些应用程序中,开发人员使用`数`表示另一条信息(如该运动的方向). 

在这些应用程序中,作为一个例子,如果一个变量到达零并且它失去了它的符号,那么在它到达零之前,你将失去它移动的方向的信息. 保留零的符号防止潜在的不想要的信息丢失. 

### 特殊的平等

正如我们在上面看到的,`南`价值和`- 0`在平等比较中,价值具有特殊的行为. `南`不等于它本身,所以你必须使用ES6的`数. isnan(..)`(或polyfill). 同样,`- 0`撒谎并假装它是平等的(甚至`= = =`严格平等ℴℴ参见第4章)`零`,所以你必须使用一些hackish`isnegzero(..)`我们建议以上实用程序. 

截至6,现在有一个新的工具,可以用来测试绝对平等两个值,没有任何的例外. 这就是所谓的`对象是(ⅆ)`: 

```js
var a = 2 / "foo";
var b = -3 * 0;

Object.is( a, NaN );	// true
Object.is( b, -0 );		// true

Object.is( b, 0 );		// false
```

这是一个相当简单的polyfill为`对象是(ⅆ)`对于pre-es6环境: 

```js
if (!Object.is) {
	Object.is = function(v1, v2) {
		// test for `-0`
		if (v1 === 0 && v2 === 0) {
			return 1 / v1 === 1 / v2;
		}
		// test for `NaN`
		if (v1 !== v1) {
			return v2 !== v2;
		}
		// everything else
		return v1 === v2;
	};
}
```

`对象是(ⅆ)`可能不应该用于`= =`或`= = =`众所周知_安全的_(见第4章"强制"),因为操作符可能更有效率,而且更地道/普通. `对象是(ⅆ)`主要是为了这些平等的特殊情况. 

## 价值与参考

在许多其他语言中,根据您使用的语法,值可以通过值复制或参考副本分配/传递. 

例如,在C++中如果你想传递`数`将变量变为函数并使该变量的值更新,可以声明函数参数`int和mynum`当你传递一个变量时`X`,`mynum`将一个**参考`X`**引用就像一种特殊的指针形式,在这里你可以获得指向另一个变量的指针(如_别名_). 如果不声明引用参数,则传入的值将为_总是_被复制,即使它是一个复杂的对象. 

在JavaScript中,没有指针,引用的工作方式有点不同. 不能从一个js变量引用到另一个变量. 那是不可能的. 

JS点中的引用在A(共享)**价值**因此,如果有10个不同的引用,它们都是对单个共享值的不同引用;**没有一个是相互参照/指针的. **

此外,在JavaScript中,没有语法提示控制值与引用赋值/传递. 相反,该_类型_的价值_唯一地_控制该值是否将由值复制或引用副本分配. 

让我们举例说明: 

```js
var a = 2;
var b = a; // `b` is always a copy of the value in `a`
b++;
a; // 2
b; // 3

var c = [1,2,3];
var d = c; // `d` is a reference to the shared `[1,2,3]` value
d.push( 4 );
c; // [1,2,3,4]
d; // [1,2,3,4]
```

简单值(也称标量原语)是_总是_按值复制分配/传递: `无效的`,`未定义`,`一串`,`数`,`布尔`,和6的`符号`. 

复合价值`对象`S(包括`阵列`s和所有盒装对象包装器ℴℴ见第3章)`功能`S -_总是_创建指派或通过的引用副本. 

In the above snippet, because`二`是标量原语,`一`保存该值的一个初始副本,并`B`另一个是分配_复制_价值的. 当改变`B`你绝不会改变价值观`一`. 

但**二者都`C`和`D`**是对相同的共享值的单独引用. `[1,2,3]`,这是一个复合值. 需要注意的是,两者都不重要. `C`也没有`D`更多"拥有"`[1,2,3]`值ℴℴ两者都是对等的对值的引用. 因此,当使用任一引用进行修改时(`推(4)`)实际共享`阵列`值本身,它只影响一个共享值,并且两个引用将引用新修改的值. `[1,2,3,4]`. 

由于引用指向值本身,而不是指向变量,所以不能使用一个引用来更改指向另一个引用的位置: 

```js
var a = [1,2,3];
var b = a;
a; // [1,2,3]
b; // [1,2,3]

// later
b = [4,5,6];
a; // [1,2,3]
b; // [4,5,6]
```

当我们完成任务时`B = [4,5,6 ]`我们完全没有影响. _哪里_ `一`仍然引用(`[1,2,3]`). 那样做,`B`必须是指向`一`而不是提及`阵列`-但js中没有这样的功能!

这种混淆最常见的方式是函数参数: 

```js
function foo(x) {
	x.push( 4 );
	x; // [1,2,3,4]

	// later
	x = [4,5,6];
	x.push( 7 );
	x; // [4,5,6,7]
}

var a = [1,2,3];

foo( a );

a; // [1,2,3,4]  not  [4,5,6,7]
```

当我们通过辩论时`一`它分配一个副本`一`参考`X`. `X`和`一`是指向同一个的单独引用吗?`[1,2,3]`价值. 现在,在函数内部,我们可以使用该引用来改变值本身. `推(4)`). 但当我们完成任务时`X = [4,5,6 ]`这绝不影响初始引用的位置. `一`指向-仍然指向(现在修改)`[1,2,3,4]`价值. 

没有办法使用`X`变更参考`一`指向. 我们只能修改两个共享值的内容. `一`和`X`指着. 

为了实现改变`一`有`㄰4ㄡ5ㄡ6ㄡ7 ]`值内容,不能创建新内容. `阵列`并分配-您必须修改现有的`阵列`价值: 

```js
function foo(x) {
	x.push( 4 );
	x; // [1,2,3,4]

	// later
	x.length = 0; // empty existing array in-place
	x.push( 4, 5, 6, 7 );
	x; // [4,5,6,7]
}

var a = [1,2,3];

foo( a );

a; // [4,5,6,7]  not  [1,2,3,4]
```

正如你所看到的,`x.length = 0`和`x.push(4ㄡ5ㄡ6ㄡ7)`were not creating a new`阵列`,但修改现有共享`阵列`. 所以当然,`一`引用新`㄰4ㄡ5ㄡ6ㄡ7 ]`内容. 

记住: 你不能直接C

有效地传递复合值(如`阵列`通过值复制,您需要手动复制它,以便传递的引用仍然不指向原始. 例如:

```js
foo( a.slice() );
```

`切片(..)`如果没有参数,默认情况下会生成一个全新的(浅的)副本. `阵列`. 因此,我们只引用复制的内容. `阵列`,从而`富(ⅆ)`不能影响内容`一`. 

相反,通过一个标量原始值的方式,可以看到它的值更新,有点像一个引用ℴℴ你必须用另一个复合值来包装这个值. `对象`,`阵列`等)_可以_以参考副本通过: 

```js
function foo(wrapper) {
	wrapper.a = 42;
}

var obj = {
	a: 2
};

foo( obj );

obj.a; // 42
```

在这里,`obj`用作标量原始属性的包装器. `一`. 当通过`富(ⅆ)`,副本`obj`引用传入并设置为`包装`参数.我们现在可以使用`包装`引用访问共享对象并更新其属性. 功能完成后,`一个目标. `将看到更新的值`四十二`. 

如果您想传递对标量原始值的引用,可能会出现这样的情况. `二`你可以把它的值框起来`数`对象包装器(见第3章). 

它_是_真实的参考文献副本`数`对象_将_传递给函数,但不幸的是,对共享对象的引用不会给您修改共享原始值的能力,如您所期望的那样: 

```js
function foo(x) {
	x = x + 1;
	x; // 3
}

var a = 2;
var b = new Number( a ); // or equivalently `Object(a)`

foo( b );
console.log( b ); // 2, not 3
```

问题是基本标量原始值是_不可变的_(同样的道理)`字符串`和`布尔`). 如果一个`数`对象持有标量原始值. `二`,准确`数`对象不能更改为持有另一个值;您只能创建一个全新的值. `数`具有不同值的对象. 

什么时候`X`在表达式中使用`x + 1`,基本标量原始值`二`进行取消装箱(提取)从`数`对象自动,所以行`x=1`很微妙的变化`X`从共同引用到`数`对象,只保留标量原始值. `三`由于加法运算`2 + 1`. 因此,`B`在外部仍然引用原始的未修改的/不可变的. `数`持有值的对象`二`. 

你_可以_在属性的顶部添加属性`数`对象(只是不更改其内部原始值),因此可以通过这些附加属性间接地交换信息. 

然而,这并不常见,大多数开发人员可能不认为这是一种好习惯. 

而不是使用包装器对象`数`这样,使用手动对象包装可能更好. `obj`在早期代码段中的方法. 这并不是说对于盒装对象包装器没有什么好的用途. `数`只是在大多数情况下,您可能更喜欢标量原始值形式. 

参考文献是相当强大的,但有时它们妨碍了你,有时你需要它们不存在的地方. 您对引用与值复制行为的唯一控制是值本身的类型,因此您必须间接地影响您选择使用的值类型的赋值/传递行为. 

## 回顾

在JavaScript,`阵列`s只是任意值类型的数值索引集合. `一串`s有点"`阵列`比如说,但是他们有不同的行为,如果你想把它们当作`阵列`JavaScript中的s数包括"整数"和浮点值. 

在原始类型中定义了一些特殊值. 

这个`无效的`类型只有一个值: `无效的`,同样地`未定义`类型有`未定义`价值. `未定义`基本上是任何变量或属性的默认值,如果没有其他值存在. 这个`无效`运算符允许您创建`未定义`任何其他值的值. 

`数`s包含几个特殊值,比如`南`(假定不是"数字",但更恰当地说是"无效数字");`+无限`和`无穷`;和`- 0`. 

简单标量基元(`一串`S,`数`通过值拷贝分配/传递,但复合值(`对象`s)通过参考副本分配/传递. 引用与其他语言中的引用/指针不同ℴℴ它们从不指向其他变量/引用,只在底层值中引用. 
