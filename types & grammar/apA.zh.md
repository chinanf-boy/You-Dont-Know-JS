
# 你不知道JS: 类型和语法

# 附录A: 混合环境JavaScript

除了我们在本书中充分探讨过的核心语言机制之外,在现实世界中运行JS代码的方式有几种不同的方式ㄢ如果JS是纯粹的内部执行引擎,它会完全可预测的基于无要求但JS几乎总是运行在托管环境中的黑白,使您的代码以一定程度的不可预测性ㄢ

例如,当你的代码与来自其他来源的代码一起运行,或者当你的代码运行在不同类型的js引擎(不仅仅是浏览器)时,有些事情可能会有不同的表现ㄢ

我们将简要地探讨其中的一些问题ㄢ

## Annex B(ECMAScript)

这是一个鲜为人知的事实: 语言的正式名称是ECMAScript(指ECMA标准体管理)ㄢ那么什么是"JavaScriptℽ呢?JavaScript的语言,共同的商号当然更适当,JavaScript的浏览器实现基本规格ㄢ

官方的ECMAScript标准包括"附录Bℽ,具体论述了偏离JS在浏览器兼容性的目的官方规格ㄢ

考虑这些偏差的正确方法是,如果您的代码在浏览器中运行,它们才是可靠的/有效的ㄢ如果你的代码总是在浏览器中运行,你就看不到任何明显的差异ㄢ如果不是(如果它可以运行在Node.js,犀牛,等等),或者你不确定,小心ㄢ

主要相容性差异: 

-   允许八进制数字文字,例如`0123`(小数`八十三`在非ℴ`严格模式`ㄢ
-   `窗户,逃生(ⅆ)`和`窗口ㄢunescape(..)`让你逃避或unescape字符串`%`带分隔符的十六进制转义序列ㄢ例如:`逃出窗户("?= 97%和bar = 3%")`生产`"% % % % 25% 3ffoo 3d97 26bar 3d3 % 25ℽ`ㄢ
-   `string.prototype.substr`很相似`string.prototype.substring`,但不是二参数为结局指标(noninclusive),第二个参数是`长度`(要包含的字符数)ㄢ

### Web脚本

Web ECMAScript规范(<http://javascript.spec.whatwg.org/>)包括官方ECMAScript规范和当前浏览器的JavaScript实现之间的差异ㄢ

换言之,这些项目是"需要ℽ的浏览器(相互兼容),但不是(截至编写时)在"附件Bℽ部分的正式规格: 

-   `<!ℴℴ`和`-->`有效的单行注释符ㄢ
-   `string.prototype`返回HTML格式化字符串的添加: `锚(ⅆ)`,`大(..)`,`眨眼(ⅆ)`,`粗体(..)`,`固定(ⅆ)`,`字体颜色(..)`,`字体大小(..)`,`斜体(..)`,`链接(ⅆ)`,`小(..)`,`罢工(ⅆ)`,和`子(ⅆ)`ㄢ**注: **这些在实践中很少使用,通常不支持其他内置的DOM API或用户定义的实用程序ㄢ
-   `正则表达式`扩展: `1美元的正则表达式ㄢ`..`9美元的正则表达式ㄢ`(匹配组)和`regexp.lastmatch`/`"$ &"regexp [ ]`(最近的比赛)ㄢ
-   `function.prototype`添加: `function.prototype.arguments`(别名内部`争论`对象)和`function.caller`(别名内部`arguments.caller`)ㄢ**注: ** `争论`因此,`arguments.caller`是过时的,所以你应该避免使用它们,如果可能的话ㄢ对于这些别名来说,这是加倍的ℴℴ不要使用它们!

**注: **其他一些次要的和很少使用的偏差不在我们的列表中ㄢ看到外部的"附录Bℽ和"Web脚本文件更详细的信息的需要ㄢ

一般来说,这些差异很少被使用,因此偏离规范是不重要的问题ㄢ**只是要小心**如果你依赖其中任何一个ㄢ

## 宿主对象

关于变量在JS中的行为的覆盖规则有例外,当涉及到自动定义的变量,或者以其他方式创建和提供由您的代码(浏览器等)的环境提供给JS的变量时,这些规则称为"宿主对象ℽ(包括两个内置的)ㄢ`对象`S和`功能`S)ㄢ

例如:

```js
var a = document.createElement( "div" );

typeof a;								// "object" -- as expected
Object.prototype.toString.call( a );	// "[object HTMLDivElement]"

a.tagName;								// "DIV"
```

`一`不仅仅是`对象`而是一个特殊的宿主对象,因为它是一个DOM元素ㄢ它有一个不同的内部`[阶级]`价值(`"htmldivelementℽ`并带有预定义的(通常是不可变的)属性ㄢ

另一个这样的怪癖已经覆盖,在"falsy对象ℽ部分4章: 一些物体可以存在但当强迫`布尔`他们会强迫(混淆)`假`而不是预期`真正的`ㄢ

与宿主对象有关的其他行为变化可以包括: 

-   不能正常使用`对象`内置插件如`tostring()`
-   没有被重写
-   具有某些预定义的只读属性
-   有不可能的方法`这`-修改其他对象
-   和更多的ⅆ

宿主对象是使JS代码与周围环境协同工作的关键ㄢ但重要的是要注意,当你与主机对象交互时,要小心假设它的行为,如T`对象`S.

您可能经常与之交互的宿主对象的一个显著例子是`慰问`对象及其各种功能(`记录(ⅆ)`,`错误(..)`等等)ㄢ这个`慰问`对象由_宿主环境_特别是为了与各种开发相关的输出任务,您的代码可以与它交互ㄢ

在浏览器,`慰问`挂钩到开发工具的控制台上显示,而在Node.js和其他服务器端JS环境,`慰问`一般连接到标准输出(`标准输出`)和标准错误(`标准错误`JavaScript环境系统流程的流ㄢ

## 全球随机变量

您可能知道在全局范围内声明变量(带或不带)`VaR`)不仅创建全局变量,而且创建镜像: `全球的`对象(`窗口`在浏览器中)ㄢ

但更不常见的知识是(由于传统的浏览器行为)创建DOM元素`身份证件`属性创建相同名称的全局变量ㄢ例如:

```html
<div id="foo"></div>
```

和: 

```js
if (typeof foo == "undefined") {
	foo = 42;		// will never run
}

console.log( foo );	// HTML element
```

您可能习惯于管理全局变量测试(使用`类型`或`..在窗口`检查)假设只有js代码创建了这样的变量,但正如您所看到的,托管HTML页面的内容也可以创建它们,如果您不小心的话,可以很容易地丢弃您的存在检查逻辑ㄢ

这也是为什么你应该尽可能避免使用全局变量的原因,如果必须的话,使用不可能冲突的唯一名称变量ㄢ但您还需要确保不要与HTML内容以及任何其他代码冲突ㄢ

## 本土原型

最广为人知和最经典的JavaScript代码之一_最佳实践_智慧是: **不要扩展本地原型**ㄢ

无论您想出什么方法或属性名称来添加到`array.prototype`这还不存在,如果它是一个有用的加法和精心设计,并适当命名,它是一个很好的机会ㄢ_能够_最终会被添加到规范中,在这种情况下,您的扩展现在处于冲突状态ㄢ

下面是一个真实的例子,它正好说明了这一点ㄢ

我在其他网站建立一个可嵌入的插件,我的插件依赖jQuery(尽管几乎任何框架会遭受这样的问题)ㄢ它几乎在每一个站点上都有效,但我们在一个完全崩溃的地方遇到了它ㄢ

经过近一个星期的分析/调试,我发现这个站点已经深深地埋在它的一个遗留文件中,代码看起来像这样: 

```js
// Netscape 4 doesn't have Array.push
Array.prototype.push = function(item) {
	this[this.length] = item;
};
```

除了疯狂的评论(谁再在乎网景4?!这看起来很合理,对吧?

问题是,`array.prototype.push`在Netscape 4纪元编码之后的某个时间添加到规范中,但添加的内容与此代码不兼容ㄢ标准`推(ⅆ)`允许同时推送多个项目ㄢ这个被攻击的人忽略了后续的项目ㄢ

基本上所有js框架都有依赖于`推(ⅆ)`多元素ㄢ在我的例子中,它是CSS选择器引擎的代码,它完全被破坏了ㄢ但可以想象的是,还有几十个地方容易受影响ㄢ

最初写这篇文章的开发者`推(ⅆ)`哈克有正确的本能称之为`推`但没有预见到推动多个元素ㄢ他们当然是善意的行动,但他们创造了一个地雷,直到将近10年后,当我无意中出现的时候,才发生了地雷ㄢ

有多个教训可以带走ㄢ

首先,不要扩展本地用户,除非您绝对确定代码是惟一在该环境中运行的代码ㄢ如果你不能说100%,那么扩展当地人是危险的ㄢ你必须权衡风险ㄢ

接下来,不要无条件地定义扩展(因为您可以意外地覆盖本地人)ㄢ在这个特殊的例子中,代码是这样说的: 

```js
if (!Array.prototype.push) {
	// Netscape 4 doesn't have Array.push
	Array.prototype.push = function(item) {
		this[this.length] = item;
	};
}
```

这个`如果`声明守卫只定义了这个入侵`push()`对于不存在的js环境ㄢ在我的情况下,这可能会很好ㄢ但即使这种方法也不是没有风险的: 

1.  如果网站的代码(因为一些疯狂的原因)!依赖于`推(ⅆ)`忽略了多个项目,这些代码早在几年前就被打破了ㄢ`推(ⅆ)`铺开ㄢ
2.  如果有其他的图书馆进来并在A`推(ⅆ)`在这`如果`卫兵,它以一种不相容的方式做了,那会在那个时候破坏现场ㄢ

这个亮点是一个有趣的问题,坦率地说,js开发人员没有得到足够的关注: **你应该依赖本地内置的行为吗?**如果您的代码在任何不是唯一代码存在的环境中运行?

严格的回答是**不**但那太不切实际了ㄢ您的代码通常不能重新定义自己所依赖的所有内置行为的私有不可触摸版本ㄢ即使你_能够_那太浪费了ㄢ

那么,你应该对内置行为和遵从性测试进行测试吗?

```js
// don't trust Array.prototype.push
(function(){
	if (Array.prototype.push) {
		var a = [];
		a.push(1,2);
		if (a[0] === 1 && a[1] === 2) {
			// tests passed, safe to use!
			return;
		}
	}

	throw Error(
		"Array#push() is missing/broken!"
	);
})();
```

从理论上讲,这听起来似乎是可行的,但为每一种内置方法设计测试也是相当不切实际的ㄢ

那么,我们该怎么办呢?我们应该_信任但要核查_(特性和遵从性测试)**一切**?我们是否应该假定存在是合规性的,让破裂(由其他人引起)会冒泡?

没有好答案ㄢ唯一可以观察到的事实是,扩展原生原型是这些东西咬你的唯一方法ㄢ

如果你不这样做,在你的应用程序中没有其他人做,你是安全的ㄢ否则,你至少应该建立一点怀疑主义ㄡ悲观主义和对可能破碎的期望ㄢ

对在所有已知环境中运行的代码进行完全的单元/回归测试是较早解决这些问题的一种方法,但它实际上并不能保护您免受这些冲突的影响ㄢ

### 垫片/ polyfills

通常说,扩展本地的惟一安全的地方是在旧的(非规范兼容的)环境中,因为这不太可能改变ℴℴ新的浏览器具有新的规范特性,取代了旧的浏览器,而不是修改它们ㄢ

如果你能预见未来,并且清楚地知道未来的标准会是什么样子,比如`array.prototype.foobar`这将是完全安全的,使您自己的兼容版本的,现在使用,对不对?

```js
if (!Array.prototype.foobar) {
	// silly, silly
	Array.prototype.foobar = function() {
		this.push( "foo", "bar" );
	};
}
```

如果已经有规格说明了`array.prototype.foobar`,和指定的行为等同于这个逻辑,你很安全的定义这样一个片段,在这种情况下,它通常被称为"polyfillℽ(或"垫片ℽ)ㄢ

这样的代码**非常**有助于在代码库中包含"补丁ℽ旧的浏览器环境,而不是更新到最新的规范ㄢ使用polyfills是所有支持的环境中创建一个伟大的方式,预测编码ㄢ

**提示: **ES5垫片(<https://github.com/es-shims/es5-shim>)是一个综合的垫片/ polyfills收集带来的项目到ES5的基线,同样,垫片(ES6<https://github.com/es-shims/es6-shim>)提供了新的API增加为6垫片ㄢ而API可以保留/ polyfilled,新语法一般不能ㄢ桥的句法分,你会想要使用一个像Traceur那样es6-to-es5 transpiler([https://github.com/google/traceur-compiler/wiki/getting-started](https://github.com/google/traceur-compiler/wiki/Getting-Started))ㄢ

如果有可能的未来的标准,而大多数的讨论都会是什么,它将如何运作,创造面向未来的领先时间polyfill符合标准被称为"prollyfillℽ(可能是填写)ㄢ

真正抓的是如果有新的标准行为不能(完全)polyfilled / prollyfilledㄢ

有争论的社区如果一般情况下部分polyfill是可接受的(记录不能polyfilled零件),或者如果一个polyfill应该单纯不能100%符合规格避免

至少很多开发商接受一些共同的部分polyfills(例如`对象创建(..)`)因为没有覆盖的部件不是他们打算使用的部件ㄢ

一些开发人员认为`如果`围绕一个polyfill /垫片保护应该包括某种形式的一致性测试,取代现有的方法要么是缺席或失败测试ㄢ这一层额外的符合性测试是用来区分"垫片ℽ(达标测试)从"polyfillℽ(存在性检查)ㄢ

唯一的绝对优势是没有绝对的东西ㄢ_正确的_答案在这里ㄢ扩展本地人,即使在旧环境中"安全ℽ地工作,也不是100%安全的ㄢ在其他人在场的情况下,依靠(可能扩展)当地人也是如此ㄢ

要么总是谨慎行事,防御代码,还有许多关于风险的明显文件ㄢ

## `<脚本>`S

大多数浏览过浏览器的网站/应用程序都有一个以上的文件,其中包含了它们的代码ㄢ`<`页面中的元素分别加载这些文件,甚至还有一些内联代码ㄢ`<脚本><脚本>`元素也ㄢ

但是,这些单独的文件/代码段是否构成单独的程序,或者它们是一个js程序?

也许(令人惊讶的)现实是,他们在大多数情况下更像是独立的JS程序,但不是所有的方面ㄢ

一件事他们_分享_是单`全球的`对象(`窗口`在浏览器中,这意味着多个文件可以将它们的代码附加到共享的名称空间,并且它们都可以相互作用ㄢ

所以,如果`脚本`元素定义全局函数ㄢ`foo()`当一秒钟`脚本`稍后运行,它可以访问和调用`foo()`就好像它已经定义了函数本身ㄢ

但全局变量范围_吊装_(见_范围和关闭_这个系列的标题不会出现在这些边界上,所以下面的代码不起作用(因为`foo()`声明尚未声明,不管它们是否(如图所示)内联ㄢ`<脚本><脚本>`元素或外部加载`<`文件夹:

```html
<script>foo();</script>

<script>
  function foo() { .. }
</script>
```

但其中任何一个_将_去工作: 

```html
<script>
  foo();
  function foo() { .. }
</script>
```

或: 

```html
<script>
  function foo() { .. }
</script>

<script>foo();</script>
```

另外,如果在`纸条`元素(内联或外部),作为单独的独立js程序,它将失败并停止,但任何后续`脚本`s将运行(仍与共享`全球的`)畅通ㄢ

您可以创建`脚本`元素从代码中动态地注入到页面的DOM中,它们中的代码基本上表现为在单独的文件中正常加载: 

```js
var greeting = "Hello World";

var el = document.createElement( "script" );

el.text = "function foo(){ alert( greeting );\
 } setTimeout( foo, 1000 );";

document.body.appendChild( el );
```

**注: **当然,如果您尝试上面的代码段,但设置`el.src`对某些文件URL而不是设置`el.text`对于代码内容,您将动态创建一个外部加载ㄢ`<`元ㄢ

内联代码块中的代码与外部文件中相同的代码之间的一个区别是内联代码块中的字符序列ㄢ`<脚本>`不能一起出现,因为(不管它出现在哪里),它将被解释为代码块的结束ㄢ所以,小心代码: 

```html
<script>
  var code = "<script>alert( 'Hello World' )</script>";
</script>
```

它看起来无害,但`<脚本>`出现在`一串`文字将异常终止脚本块,导致错误ㄢ最常见的解决方案是: 

```js
"</sc" + "ript>";
```

另外,要注意的是,代码外部文件将被解释在字符集(UTF-8,iso-8859-8,等等)的文件送达(或违约),但在一个内嵌相同的代码`脚本`HTML页面中的元素将由页面的字符集(或其默认)解释ㄢ

**警告: **这个`字符集`属性不能在内联脚本元素中工作ㄢ

另一个过时的实践与内嵌`脚本`元素包括HTML样式或X(HT)ML风格的内联代码注释,如: 

```html
<script>
<!--
alert( "Hello" );
//-->
</script>

<script>
<!--//--><![CDATA[//><!--
alert( "World" );
//--><!]]>
</script>
```

这两个都是完全不需要的,所以如果你仍然这样做,停止它!

**注: **两`<!ℴℴ`和`-->`(HTML风格的注释)实际上是指定为有效的单行注释符(`var = 2;<!ℴℴ有效的评论`和`>另一个有效的行注释`)在JavaScript中(见"Web ECMAScriptℽ部分早),纯粹是因为这古老的技术ㄢ但千万不要使用它们ㄢ

## 保留字

的ES5规范定义了一套"保留字ℽ在第7.6.1,不能作为独立的变量名ㄢ从技术上讲,有四类: "关键字ℽ,"未来保留字ℽ,`无效的`文字和`真正的`/`假`布尔常量ㄢ

关键词是显而易见的吗?`功能`和`转换`ㄢ未来的保留词包括`枚举`尽管他们中的许多人(`班`,`延伸`,等)都是目前实际使用的6;还有其他严格的模式只保留字一样`接口`ㄢ

"art4thesould计算器用户"创造性工作的所有这些保留字变成一个有趣的小诗([HTTP: / /计算器ㄢCOM /问题/ 26255 /保留关键字在JavaScript # 12114140 / 12114140](http://stackoverflow.com/questions/26255/reserved-keywords-in-javascript/12114140#12114140)): 

> 让这个长长的包裹漂浮起来,
>
> 转到私人类,如果短ㄢ
>
> -   在调试器的情况下进行保护,

**继续易失界面ㄢ**是超同步投,`扩展最终出口抛出ㄢ`尝试导入双枚举?`伪布尔抽象函数,`实现类型的瞬断!

默认是静态的,

切换本地新ㄢ

```js
var import = "42";
```

否则,删除空公共var

```js
var obj = { import: "42" };
console.log( obj.import );
```

作为常量ㄡ真ㄡchar的返回

## ⅆ最后捕获字节ㄢ

注: 

这首诗包括保留字(沙三段

```js
function addAll() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		sum += arguments[i];
	}
	return sum;
}

var nums = [];
for (var i=1; i < 100000; i++) {
	nums.push(i);
}

addAll( 2, 4, 6 );				// 12
addAll.apply( null, nums );		// should be: 499950000
```

字节`,`长的

,等等),不再保留作为ES5ㄢ

-   之前ES5的保留字,也不能在对象文本属性名称或键,但限制不再存在ㄢ
-   所以,这是不允许的: 
-   但这是允许的: 
-   您应该意识到一些旧的浏览器版本(主要是ie)在应用这些规则时并不完全一致,所以在对象属性名位置使用保留字仍然会引起问题ㄢ仔细测试所有支持的浏览器环境ㄢ
-   实现的限制
-   JavaScript规范不会对函数的参数数目或字符串文字的长度设置任意限制,但仍然存在这些限制,因为在不同引擎中有实现细节ㄢ
-   例如:

在一些js引擎中,你会得到正确的

## 四亿九千九百九十五万

的答案,但在其他(如Safari 6ㄢx),你会得到错误: "rangeerror: 最大调用堆栈大小超过ㄢℽ

已知存在的其他限制的例子: 

字符串文字中允许的最大字符数(不只是字符串值)
