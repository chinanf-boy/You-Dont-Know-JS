
# 你不知道JS：类型和语法

# 第3章土著人

在第1章和第2章中，我们多次提到各种内置的，通常称为“本地人”的。`字符串`和`数`。现在让我们详细地检查一下。

这是最常用的土著人的名单：

-   `string()`
-   `number()`
-   `boolean()`
-   `array()`
-   `object()`
-   `function()`
-   `regexp()`
-   `（）`
-   `error()`
-   `symbol()`——增加了6！

正如你所看到的，这些本地人实际上是内置函数。

如果你来到JS从语言如java，JavaScript`string()`看起来像`字符串（..）`用于创建字符串值的构造函数。所以，你很快就会发现你可以做类似的事情：

```js
var s = new String( "Hello World!" );

console.log( s.toString() ); // "Hello World!"
```

它_是_的确，这些本地人都可以作为本地构造函数使用。但是正在构建的东西可能与你想象的不同。

```js
var a = new String( "abc" );

typeof a; // "object" ... not "String"

a instanceof String; // true

Object.prototype.toString.call( a ); // "[object String]"
```

价值创造的构造形式的结果（`新字符串（“ABC”）`）是原语周围的对象包装器（`“ABC”`）值。

更重要的是，`类型`显示这些对象不是它们自己的特殊。_类型_但更恰当地说，它们是`对象`型。

可以进一步观察这个对象包装器：

```js
console.log( a );
```

这句话取决于浏览器的输出，作为开发者控制台可以自由选择他们觉得合适的序列化为开发者检查的对象。

**注：**在撰写本文的时候，最新的Chrome打印了如下内容：`字符串{ 0：“A”，“B”，1：2：“C”，长度：3，primitivevalue ] [ [ ]：“ABC”}`。但旧版本的Chrome以前只打印这个：`字符串{ 0：“A”，1：“B”，2：“C”}`。最新的Firefox当前打印`字符串[“A”、“B”、“C”）`但用于印刷`“ABC”`斜体，并点击打开检查对象。当然，这些结果会受到快速的变化，而你的经验可能会有所不同。

重点是，`新字符串（“ABC”）`创建字符串包装器对象`“ABC”`不仅仅是原始的`“ABC”`价值本身。

## 内部`[阶级]`

价值观，`类型`“对象”`（如数组）还附加有内部标记。`\[阶级]`属性（将此更多地看作内部）`班_化而不是从传统的面向类的编码相关的类）。不能直接访问此属性，但一般可以通过借用默认值间接显示。_对象的ToString（..）。原型。`对值进行调用的方法。例如:`因此，对于这个例子中的数组，内部

```js
Object.prototype.toString.call( [1,2,3] );			// "[object Array]"

Object.prototype.toString.call( /regex-literal/i );	// "[object RegExp]"
```

\[阶级]`值`“阵列”`对于正则表达式，它是`“正则表达式”`。在大多数情况下，这个内部`\[阶级]`值对应于与值相关的内置本地构造函数（见下文），但情况并非总是如此。`原始值如何？第一,

无效的`和`未定义`：`你会注意到没有

```js
Object.prototype.toString.call( null );			// "[object Null]"
Object.prototype.toString.call( undefined );	// "[object Undefined]"
```

null()`或`undefined()`本地构造函数，但尽管如此`“空”`和`“未定义”`是内部`\[阶级]`值暴露。`但是对于其他简单的原语

一串`，`数`，和`布尔`另一种行为实际上是踢进来的，通常称为“拳击”（下看“拳击包装”一节）：`在这个片段中，每个简单的原语都由各自的对象包装器自动装箱，这就是为什么。

```js
Object.prototype.toString.call( "abc" );	// "[object String]"
Object.prototype.toString.call( 42 );		// "[object Number]"
Object.prototype.toString.call( true );		// "[object Boolean]"
```

“字符串”`，`“数”`，和`“布尔”`显示为各自的内部`\[阶级]`价值观。`注：

**的行为**tostring()`和`\[阶级]`说明在这里有了一些改变，从ES5到6，但我们盖的那些细节`6与超越_本系列的标题。_拳击包装

## 这些对象包装器起着非常重要的作用。原始值没有属性或方法，所以访问

。长度`或`tostring()。`在值周围需要一个对象包装器。谢天谢地，js会自动的`箱_（即包装）满足这种访问的原始值。_因此，如果您将定期访问字符串值上的这些属性/方法，比如

```js
var a = "abc";

a.length; // 3
a.toUpperCase(); // "ABC"
```

我的&lt;&lt; a.length`状况`对于`例如循环，从一开始就拥有值的对象形式似乎是有意义的，因此js引擎不需要隐式地为它创建它。`但结果证明这不是个好主意。浏览器很久以前的性能优化了常见的情况

。长度`这意味着你的程序会`其实走得慢一点_如果你试图“preoptimize”直接用对象的形式（不是对优化的路径）。_一般来说，基本上没有理由直接使用对象表单。在必要的情况下，最好让隐式发生。换句话说，不要做类似的事情。

新字符串（“ABC”）`，`新号码（42）`，总是喜欢使用文字的原始值。`“ABC”`和`四十二`。`对象包装的陷阱

### 有一些问题与直接使用对象包装器，你应该知道如果你

做_选择使用它们。_例如，考虑

布尔`包装的价值：`问题是，您已经在

```js
var a = new Boolean( false );

if (!a) {
	console.log( "Oops" ); // never runs
}
```

假`值，但对象本身的“真实性”（见4章），所以使用对象的行为相反的使用`值，但对象本身的“真实性”（见4章），所以使用对象的行为相反的使用基础`假`值本身，这与一般期望完全相反。

如果您想手动包装一个原始值，您可以使用`对象（…）`功能（无`新的`关键词）：

```js
var a = "abc";
var b = new String( a );
var c = Object( a );

typeof a; // "string"
typeof b; // "object"
typeof c; // "object"

b instanceof String; // true
c instanceof String; // true

Object.prototype.toString.call( b ); // "[object String]"
Object.prototype.toString.call( c ); // "[object String]"
```

再次，直接使用盒装对象包装器（如`B`和`C`通常会被劝阻，但可能会有一些罕见的情况，你会遇到有用的地方。

## 拆箱

如果您有一个对象包装器，并且希望获得底层原始值，则可以使用`valueof()`方法：

```js
var a = new String( "abc" );
var b = new Number( 42 );
var c = new Boolean( true );

a.valueOf(); // "abc"
b.valueOf(); // 42
c.valueOf(); // true
```

拆箱也可以发生隐式，使用时的包装对象价值的一种方式，需要原始值。这一过程（胁迫）将在第4章中更详细地介绍，但简要介绍：

```js
var a = new String( "abc" );
var b = a + ""; // `b` has the unboxed primitive value "abc"

typeof a; // "object"
typeof b; // "string"
```

## 土著的构造函数

对于`阵列`，`对象`，`功能`，和正则表达式的值，它几乎普遍喜欢你用文字的形式创造价值，但文字的形式创建对象的构造函数的形式不一样（即没有nonwrapped值）。

正如我们上面看到的与其他人，这些构造函数的形式一般应避免，除非你真的知道你需要他们，因为他们介绍的例外和陷阱，你可能真的不_希望_对付。

### `数组（..）`

```js
var a = new Array( 1, 2, 3 );
a; // [1, 2, 3]

var b = [1, 2, 3];
b; // [1, 2, 3]
```

**注：**这个`数组（..）`构造函数不需要`新的`前面的关键字。如果省略它，它将表现得好像您已经使用它了。所以`阵列（1,2,3）`结局是一样的`新的阵列（1,2,3）`。

这个`阵列`构造函数有一个特殊的形式，如果只有一个`数`参数传递，而不是提供该值作为_内容_数组的长度，这是作为一个“presize阵列”（嗯，有点）。

这是个可怕的想法。首先，你可以无意中绊倒这种形式，因为很容易忘记。

但更重要的是，有没有这样的东西作为实际填孔处理数组。相反，您创建的是一个空数组，但是设置`长度`数组的属性为指定的数值。

在槽中没有显式值的数组，但有一个`长度`属性_暗示_插槽存在，在JS中是一种奇怪的奇异类型的数据结构，有一些非常奇怪和令人迷惑的行为。有能力创造这样一种价值纯粹来源于旧的，过时的，历史的功能（“类似数组的对象”之类的`争论`对象）。

**注：**一个至少有一个“空槽”的数组通常被称为“稀疏数组”。

这是另一个例子，浏览器开发人员控制台在它们代表这样一个对象时如何变化，这引起了更多的混乱。

例如:

```js
var a = new Array( 3 );

a.length; // 3
a;
```

序列化的`一`在Chrome是（在编写时）：`[未定义的x 3 ]`。**这真的很不幸。**它意味着有三个。`未定义`这个数组的槽中的值，实际上插槽不存在（所谓的“空槽”——也是一个坏名字！）。

为了找出差异，试试这个：

```js
var a = new Array( 3 );
var b = [ undefined, undefined, undefined ];
var c = [];
c.length = 3;

a;
b;
c;
```

**注：**正如你所看到的`C`在这个例子中，数组中的空槽可以在创建数组之后发生。改变`长度`超出实际定义的槽值的数组，则隐式引入空槽。事实上，你甚至可以打电话`删除B [ 1 ]`在上面的代码片段中，它将在中间引入一个空槽。`B`。

对于`B`（在Chrome中，目前），你会发现`[未定义的，未定义的，未定义的]`作为序列化，而不是`[未定义的x 3 ]`对于`一`和`C`。困惑？Yeah, so is everyone else.

更糟糕的是，在编写报告时，Firefox报告`[，]`对于`一`和`C`。你明白为什么会这么混乱吗？仔细看。三个逗号意味着四个插槽，而不是我们预期的三个插槽。

**什么!？**火狐加了一个额外的`，`他们在序列化的结束因为ES5，尾随逗号列表（数组的值，属性列表，等）是允许的（因此下降，忽略）。所以如果你键入一个`[，]`将值放入程序或控制台中，实际上可以得到类似的底层值。`[，]`（即，有三个空槽的数组）。这样的选择，而困惑，如果阅读开发者控制台，是防守而不是副本正贴行为准确。

如果你现在摇着头或转动眼睛，你并不孤单！耸了耸肩。

不幸的是，情况变得更糟。不仅仅是混淆控制台输出，`一`和`B`从上面的代码片段实际上在某些情况下表现相同。**但在其他方面有所不同**：

```js
a.join( "-" ); // "--"
b.join( "-" ); // "--"

a.map(function(v,i){ return i; }); // [ undefined x 3 ]
b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

**啊。**

这个`a.map（..）`呼叫_失败_因为插槽实际上不存在，所以`地图（…）`无需迭代。`加入（…）`以不同的方式工作。基本上，我们可以认为它是这样实现的：

```js
function fakeJoin(arr,connector) {
	var str = "";
	for (var i = 0; i < arr.length; i++) {
		if (i > 0) {
			str += connector;
		}
		if (arr[i] !== undefined) {
			str += arr[i];
		}
	}
	return str;
}

var a = new Array( 3 );
fakeJoin( a, "-" ); // "--"
```

正如你所看到的，`加入（…）`的作品，只是_假设_插槽存在并循环到`长度`价值。无论什么`地图（…）`在内部，它（显然）没有作出这样的假设，所以来自奇异的“EMP”的结果。

所以，如果你想_事实上_创建一个实际数组`未定义`值（不只是“空槽”），你怎么能做到（除了手动）？

```js
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]
```

困惑？是啊.下面大致讲一下它是如何工作的。

`应用（…）`对所有函数都可用的实用程序，它调用它所使用的函数，但以特殊的方式调用。

第一个参数是`这`对象绑定（包含在_对象原型_这个系列的标题），我们不关心这里，所以我们把它设置为`无效的`。第二个参数应该是数组（或什么）。_喜欢_数组——又名“数组类似对象”）。这个“数组”的内容被“扩展”为对所涉函数的参数。

所以，`数组。应用（..）`呼唤`数组（..）`函数和展开值（`{长度：3 }`对象值）作为参数。

里面的`应用（…）`我们可以想象有另一个`对于`循环（有点像`加入（…）`从上面）`零`到但不包括，`长度`（`三`在我们的情况下）。

对于每个索引，它从对象中检索该键。如果数组对象参数被命名`ARR`内部的`应用（…）`函数，将有效地访问属性。`ARR [ 0 ]`，`ARR [ 1 ]`，和`ARR [ 2 ]`。当然，这些属性都不存在于`{长度：3 }`对象值，因此所有这些属性访问中的三个都将返回值。`未定义`。

换句话说，它结束了呼叫。`数组（..）`基本上是这样的：`数组（未定义的、未定义的、未定义的）`这就是我们最终填充一个数组的原因。`未定义`值，而不仅仅是那些（疯狂的）空槽。

而`数组。应用（NULL，{长度：3 }）`是创建数组填充的一种奇怪而冗长的方式。`未定义`值，它的**极大地**比你所得到的footgun'ish更好、更可靠`数组（3）`空槽。

底线：**在任何情况下都不要**如果您有意创建和使用这些外来的空插槽数组。不要这样做。他们是疯子。

### `对象（…）`，`函数（…）`，和`正则表达式（..）`

这个`对象（…）`/`函数（…）`/`正则表达式（..）`构造函数一般都是可选的（除非特别调用，通常应该避免）：

```js
var c = new Object();
c.foo = "bar";
c; // { foo: "bar" }

var d = { foo: "bar" };
d; // { foo: "bar" }

var e = new Function( "a", "return a * 2;" );
var f = function(a) { return a * 2; };
function g(a) { return a * 2; }

var h = new RegExp( "^a*b+", "g" );
var i = /^a*b+/g;
```

几乎没有理由使用`新的object()`构造函数形式，特别是因为它强制您一次一次地添加属性，而不是一次以对象字面形式添加属性。

这个`功能`构造函数只在极少数情况下有用，在这种情况下您需要动态定义函数的参数和/或它的函数体。**不要随便对待`函数（…）`作为另一种形式`eval（..）`。**您几乎不需要以这种方式动态定义一个函数。

以文字形式定义的正则表达式（`/ *`）优先，不只是为了便于语法但出于性能原因，JS引擎缓存之前预编译和执行代码。与我们迄今为止看到的其他构造函数形式不同，`正则表达式（..）`有一些合理的实用性：动态定义正则表达式的模式。

```js
var name = "Kyle";
var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

var matches = someText.match( namePattern );
```

这种情况经常发生在js程序中，所以您需要使用`新的正则表达式（“模式”、“旗帜”）`形式。

### `日期（..）`和`错误（..）`

这个`日期（..）`和`错误（..）`本地构造函数比其他本地构造函数有用得多，因为两者都没有文字形式。

要创建日期对象值，必须使用`新的（）`。这个`日期（..）`构造函数接受可选参数来指定要使用的日期/时间，但如果省略，则假定当前日期/时间。

到目前为止，构建日期对象的最常见的原因是获得当前的时间戳值（自1970年1月1日起有符号整数毫秒）。您可以通过调用`gettime()`在日期对象实例上。

但一个更简单的办法是打电话给定义为ES5静态辅助功能：`now()日期。`。和polyfill，pre-es5是很容易的：

```js
if (!Date.now) {
	Date.now = function(){
		return (new Date()).getTime();
	};
}
```

**注：**如果你打电话`（）`没有`新的`，您将得到当时的日期/时间的字符串表示形式。这种表示的确切形式并没有在语言规范中指定，尽管浏览器倾向于在一些相近的东西上达成一致：`“7月18日2014 00:31:02 gmt-0500（CDT）”`。

这个`错误（..）`构造函数（非常类似）`array()`上面）的行为与`新的`关键字现在或省略。

您希望创建错误对象的主要原因是，它将当前的执行堆栈上下文捕获到对象中（在大多数js引擎中作为只读显示）。`叠。`属性一次构建）。这个堆栈上下文包括函数调用堆栈和创建错误对象的行号，这使得错误的调试变得容易得多。

您通常会使用这样一个错误对象`扔`算子：

```js
function foo(x) {
	if (!x) {
		throw new Error( "x wasn't provided" );
	}
	// ..
}
```

错误对象实例通常至少有一个`消息`属性，有时还有其他属性（您应该将其视为只读），比如`类型`。不过，除了检查上述`堆栈`物业，通常最好是打电话。`tostring()`上

**提示：**技术上，除了一般`错误（..）`本地，还有其他一些特定的错误类型：`EvalError（..）`，`RangeError（..）`，`ReferenceError（..）`，`SyntaxError（..）`，`TypeError（..）`，和`URIError（..）`。但是手动使用这些特定错误的本地人是非常罕见的。如果您的程序实际上遭受了异常（如引用未声明的变量并获得一个`引用错误`错误）。

### `符号（..）`

新的6，额外的原始值类型已被添加，被称为“符号”。符号是特殊的“唯一”（没有严格的保证！）可以用作对象属性的值，不必担心碰撞。他们的设计主要是为特殊的内置行为ES6构造，但你也可以定义自己的符号。

符号可以用作属性名，但不能从程序中查看或访问符号的实际值，也不能从开发人员控制台访问。如果在开发人员控制台中评估一个符号，那么显示的是什么样子`符号（符号，创建）`例如。

有6几个预定义的符号，如静态属性的访问`符号`函数对象，比如`symbol.create`，`symbol.iterator`等来使用它们，做一些类似的事情：

```js
obj[Symbol.iterator] = function(){ /*..*/ };
```

若要定义自己的自定义符号，请使用`符号（..）`本土。这个`符号（..）`本地“构造函数”是唯一的，您不能使用它。`新的`有了它，这样做会抛出一个错误。

```js
var mysym = Symbol( "my own symbol" );
mysym;				// Symbol(my own symbol)
mysym.toString();	// "Symbol(my own symbol)"
typeof mysym; 		// "symbol"

var a = { };
a[mysym] = "foobar";

Object.getOwnPropertySymbols( a );
// [ Symbol(my own symbol) ]
```

符号实际上不是私有的。`对象。getownpropertysymbols（..）`对对象进行反射并公开显示符号），将它们用于私有或特殊属性很可能是它们的主要用例。对于大多数开发人员来说，他们可以用`_`下划线前缀，几乎总是由常规信号来表示：“嘿，这是一个私人/特殊/内部属性，所以不要碰它！”

**注：**符号`S`不_对象_它们是简单的标量基元。`本土原型`每个内置的本地构造函数都有自己的构造函数。

### 原型。

对象——`array.prototype`，`string.prototype`，等。`这些对象包含特定对象子类型特有的行为。`例如，所有字符串对象，并通过扩展（通过装箱）

一串

原语，可以访问默认行为作为定义在`string.prototype`对象。`注：`By documentation convention,

**string.prototype.xyz**缩短`字符串# XYZ`对所有其他人也是如此。`原型。`S.`字符串# indexOf（..）`：找到在另一个字符串的字符串的位置

-   `字符串# charAt（..）`：在字符串中的位置访问字符。
-   `#字符串substr（..）`，
-   `#子字符串（..）`，和`字符串#片（..）`：将字符串的一部分提取为一个新字符串`# touppercase()字符串`和
-   `# tolowercase()字符串`创建一个新字符串，转换为大写或小写`# trim()字符串`：创建一个新字符串，没有任何尾随或前导空白
-   `没有方法修改字符串。`在的地方

。修改（如案例转换或修剪）从现有值创建新值。_凭借原型委托（见_对象原型

在本系列中的标题），任何字符串值都可以访问这些方法：_其他构造函数原型包含适合于其类型的行为，如_#固定数量（..）

```js
var a = " abc ";

a.indexOf( "c" ); // 3
a.toUpperCase(); // " ABC "
a.trim(); // "abc"
```

（stringifying一些固定数量的小数位数），`阵列# concat（..）`（合并数组）。所有函数都可以访问`应用（…）`，`打电话（…）`，和`绑定（…）`因为`function.prototype`定义。`但是，一些本地原型不是`只是

普通的对象：_一个特别糟糕的想法，您甚至可以修改这些本地原型（不只是添加您可能熟悉的属性）：_正如你所看到的，

```js
typeof Function.prototype;			// "function"
Function.prototype();				// it's an empty function!

RegExp.prototype.toString();		// "/(?:)/" -- empty regex
"abc".match( RegExp.prototype );	// [""]
```

function.prototype

```js
Array.isArray( Array.prototype );	// true
Array.prototype.push( 1, 2, 3 );	// 3
Array.prototype;					// [1,2,3]

// don't leave it that way, though, or expect weirdness!
// reset the `Array.prototype` to empty
Array.prototype.length = 0;
```

是函数，`regexp.prototype`是正则表达式，并且`array.prototype`是数组。有趣又酷，是吧？`原型为默认值`function.prototype

#### 空函数，

`regexp.prototype`作为一个“空”（例如，非正则表达式匹配），和`array.prototype`作为一个空数组，如果变量没有适当类型的值，就让它们都是很好的“默认”值来赋值给变量。`例如:`注：

截至6，我们不需要使用

```js
function isThisCool(vals,fn,rx) {
	vals = vals || Array.prototype;
	fn = fn || Function.prototype;
	rx = rx || RegExp.prototype;

	return rx.test(
		vals.map( fn ).join( "" )
	);
}

isThisCool();		// true

isThisCool(
	["a","b","c"],
	function(v){ return v.toUpperCase(); },
	/D/
);					// false
```

**瓦尔斯=瓦尔斯| | ..**默认值语法技巧（参见第4章），因为缺省值可以通过函数声明中的本机语法设置为参数（参见第5章）。`这种方法的一个次要好处是`原型。

s已经创建并内置，从而创建`只有一次`。相比之下，使用_\[ ]_，`function() { }`，和`/（？：）/`这些缺省值的值（可能取决于引擎实现）将重新创建这些值（并可能在以后收集垃圾）。`每次打电话`属于_isthiscool（..）_。那可能是内存/ CPU浪费。`另外，要小心不要使用。`array.prototype

作为默认值`随后将进行修改。`。在这个例子中，**瓦尔斯**。在这个例子中，`瓦尔斯`是只读的，但是如果您要更改`瓦尔斯`实际上你会被修改`array.prototype`本身，这将导致前面提到的陷阱！

**注：**虽然我们指出了这些原生原型和一些有用的东西，但要谨慎地依赖它们，并且更谨慎地以任何方式修改它们。见附录A“原生原型”作更多讨论。

## 回顾

JavaScript提供了围绕原始值的对象包装器，称为本地用户。`字符串`，`数`，`布尔`等等）。这些对象包装器赋予值以访问适合每个对象子类型的行为（`# trim()字符串`和`阵列# concat（..）`）。

如果有一个简单的标量原始值，比如`“ABC”`and you access its`长度`财产或一些`string.prototype`方法，js自动地将“值”封装在其相应的对象包装器中，从而实现属性/方法的访问。
