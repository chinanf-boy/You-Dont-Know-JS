
# 你不知道JS: 类型和语法

# 第3章土著人

在第1章和第2章中,我们多次提到各种内置的,通常称为"本地人ℽ的ㄢ`字符串`和`数`ㄢ现在让我们详细地检查一下ㄢ

这是最常用的土著人的名单: 

-   `string()`
-   `number()`
-   `boolean()`
-   `array()`
-   `object()`
-   `function()`
-   `regexp()`
-   `()`
-   `error()`
-   `symbol()`ℴℴ增加了6!

正如你所看到的,这些本地人实际上是内置函数ㄢ

如果你来到JS从语言如java,JavaScript`string()`看起来像`字符串(..)`用于创建字符串值的构造函数ㄢ所以,你很快就会发现你可以做类似的事情: 

```js
var s = new String( "Hello World!" );

console.log( s.toString() ); // "Hello World!"
```

它_是_的确,这些本地人都可以作为本地构造函数使用ㄢ但是正在构建的东西可能与你想象的不同ㄢ

```js
var a = new String( "abc" );

typeof a; // "object" ... not "String"

a instanceof String; // true

Object.prototype.toString.call( a ); // "[object String]"
```

价值创造的构造形式的结果(`新字符串("ABCℽ)`)是原语周围的对象包装器(`"ABCℽ`)值ㄢ

更重要的是,`类型`显示这些对象不是它们自己的特殊ㄢ_类型_但更恰当地说,它们是`对象`型ㄢ

可以进一步观察这个对象包装器: 

```js
console.log( a );
```

这句话取决于浏览器的输出,作为开发者控制台可以自由选择他们觉得合适的序列化为开发者检查的对象ㄢ

**注: **在撰写本文的时候,最新的Chrome打印了如下内容: `字符串{ 0: "Aℽ,"Bℽ,1: 2: "Cℽ,长度: 3,primitivevalue ] [ [ ]: "ABCℽ}`ㄢ但旧版本的Chrome以前只打印这个: `字符串{ 0: "Aℽ,1: "Bℽ,2: "Cℽ}`ㄢ最新的Firefox当前打印`字符串["Aℽㄡ"Bℽㄡ"Cℽ)`但用于印刷`"ABCℽ`斜体,并点击打开检查对象ㄢ当然,这些结果会受到快速的变化,而你的经验可能会有所不同ㄢ

重点是,`新字符串("ABCℽ)`创建字符串包装器对象`"ABCℽ`不仅仅是原始的`"ABCℽ`价值本身ㄢ

## 内部`[阶级]`

价值观,`类型` `"对象ℽ`(如数组)还附加有内部标记ㄢ`[阶级]`属性(将此更多地看作内部)_班_化而不是从传统的面向类的编码相关的类)ㄢ不能直接访问此属性,但一般可以通过借用默认值间接显示ㄢ`对象的ToString(..)ㄢ原型ㄢ`对值进行调用的方法ㄢ例如:

```js
Object.prototype.toString.call( [1,2,3] );			// "[object Array]"

Object.prototype.toString.call( /regex-literal/i );	// "[object RegExp]"
```

因此,对于这个例子中的数组,内部`[阶级]`值`"阵列ℽ`对于正则表达式,它是`"正则表达式ℽ`ㄢ在大多数情况下,这个内部`[阶级]`值对应于与值相关的内置本地构造函数(见下文),但情况并非总是如此ㄢ

原始值如何?第一,`无效的`和`未定义`: 

```js
Object.prototype.toString.call( null );			// "[object Null]"
Object.prototype.toString.call( undefined );	// "[object Undefined]"
```

你会注意到没有`null()`或`undefined()`本地构造函数,但尽管如此`"空ℽ`和`"未定义ℽ`是内部`[阶级]`值暴露ㄢ

但是对于其他简单的原语`一串`,`数`,和`布尔`另一种行为实际上是踢进来的,通常称为"拳击ℽ(下看"拳击包装ℽ一节): 

```js
Object.prototype.toString.call( "abc" );	// "[object String]"
Object.prototype.toString.call( 42 );		// "[object Number]"
Object.prototype.toString.call( true );		// "[object Boolean]"
```

在这个片段中,每个简单的原语都由各自的对象包装器自动装箱,这就是为什么ㄢ`"字符串ℽ`,`"数ℽ`,和`"布尔ℽ`显示为各自的内部`[阶级]`价值观ㄢ

**注: **的行为`tostring()`和`[阶级]`说明在这里有了一些改变,从ES5到6,但我们盖的那些细节_6与超越_本系列的标题ㄢ

## 拳击包装

这些对象包装器起着非常重要的作用ㄢ原始值没有属性或方法,所以访问`ㄢ长度`或`tostring()ㄢ`在值周围需要一个对象包装器ㄢ谢天谢地,js会自动的_箱_(即包装)满足这种访问的原始值ㄢ

```js
var a = "abc";

a.length; // 3
a.toUpperCase(); // "ABC"
```

因此,如果您将定期访问字符串值上的这些属性/方法,比如`我的<< a.length`状况`对于`例如循环,从一开始就拥有值的对象形式似乎是有意义的,因此js引擎不需要隐式地为它创建它ㄢ

但结果证明这不是个好主意ㄢ浏览器很久以前的性能优化了常见的情况`ㄢ长度`这意味着你的程序会_其实走得慢一点_如果你试图"preoptimizeℽ直接用对象的形式(不是对优化的路径)ㄢ

一般来说,基本上没有理由直接使用对象表单ㄢ在必要的情况下,最好让隐式发生ㄢ换句话说,不要做类似的事情ㄢ`新字符串("ABCℽ)`,`新号码(42)`,总是喜欢使用文字的原始值ㄢ`"ABCℽ`和`四十二`ㄢ

### 对象包装的陷阱

有一些问题与直接使用对象包装器,你应该知道如果你_做_选择使用它们ㄢ

例如,考虑`布尔`包装的价值: 

```js
var a = new Boolean( false );

if (!a) {
	console.log( "Oops" ); // never runs
}
```

问题是,您已经在`假`值,但对象本身的"真实性ℽ(见4章),所以使用对象的行为相反的利用联合国`假`值本身,这与一般期望完全相反ㄢ

如果您想手动包装一个原始值,您可以使用`对象(ⅆ)`功能(无`新的`关键词): 

```js
var a = "abc";
var b = new String( a );
var c = Object( a );

typeof a; // "string"
typeof b; // "object"
typeof c; // "object"

b instanceof String; // true
c instanceof String; // true

Object.prototype.toString.call( b ); // "[object String]"
Object.prototype.toString.call( c ); // "[object String]"
```

再次,直接使用盒装对象包装器(如`B`和`C`通常会被劝阻,但可能会有一些罕见的情况,你会遇到有用的地方ㄢ

## 拆箱

如果您有一个对象包装器,并且希望获得底层原始值,则可以使用`valueof()`方法: 

```js
var a = new String( "abc" );
var b = new Number( 42 );
var c = new Boolean( true );

a.valueOf(); // "abc"
b.valueOf(); // 42
c.valueOf(); // true
```

拆箱也可以发生隐式,使用时的包装对象价值的一种方式,需要原始值ㄢ这一过程(胁迫)将在第4章中更详细地介绍,但简要介绍: 

```js
var a = new String( "abc" );
var b = a + ""; // `b` has the unboxed primitive value "abc"

typeof a; // "object"
typeof b; // "string"
```

## 土著的构造函数

对于`阵列`,`对象`,`功能`,和正则表达式的值,它几乎普遍喜欢你用文字的形式创造价值,但文字的形式创建对象的构造函数的形式不一样(即没有nonwrapped值)ㄢ

正如我们上面看到的与其他人,这些构造函数的形式一般应避免,除非你真的知道你需要他们,因为他们介绍的例外和陷阱,你可能真的不_希望_对付ㄢ

### `数组(..)`

```js
var a = new Array( 1, 2, 3 );
a; // [1, 2, 3]

var b = [1, 2, 3];
b; // [1, 2, 3]
```

**注: **这个`数组(..)`构造函数不需要`新的`前面的关键字ㄢ如果省略它,它将表现得好像您已经使用它了ㄢ所以`阵列(1,2,3)`结局是一样的`新的阵列(1,2,3)`ㄢ

这个`阵列`构造函数有一个特殊的形式,如果只有一个`数`参数传递,而不是提供该值作为_内容_数组的长度,这是作为一个"presize阵列ℽ(嗯,有点)ㄢ

这是个可怕的想法ㄢ首先,你可以无意中绊倒这种形式,因为很容易忘记ㄢ

但更重要的是,有没有这样的东西作为实际填孔处理数组ㄢ相反,您创建的是一个空数组,但是设置`长度`数组的属性为指定的数值ㄢ

在槽中没有显式值的数组,但有一个`长度`属性_暗示_插槽存在,在JS中是一种奇怪的奇异类型的数据结构,有一些非常奇怪和令人迷惑的行为ㄢ有能力创造这样一种价值纯粹来源于旧的,过时的,历史的功能("类似数组的对象ℽ之类的`争论`对象)ㄢ

**注: **一个至少有一个"空槽ℽ的数组通常被称为"稀疏数组ℽㄢ

这是另一个例子,浏览器开发人员控制台在它们代表这样一个对象时如何变化,这引起了更多的混乱ㄢ

例如:

```js
var a = new Array( 3 );

a.length; // 3
a;
```

序列化的`一`在Chrome是(在编写时): `[未定义的x 3 ]`ㄢ**这真的很不幸ㄢ**它意味着有三个ㄢ`未定义`这个数组的槽中的值,实际上插槽不存在(所谓的"空槽ℽℴℴ也是一个坏名字!)ㄢ

为了找出差异,试试这个: 

```js
var a = new Array( 3 );
var b = [ undefined, undefined, undefined ];
var c = [];
c.length = 3;

a;
b;
c;
```

**注: **正如你所看到的`C`在这个例子中,数组中的空槽可以在创建数组之后发生ㄢ改变`长度`超出实际定义的槽值的数组,则隐式引入空槽ㄢ事实上,你甚至可以打电话`删除B [ 1 ]`在上面的代码片段中,它将在中间引入一个空槽ㄢ`B`ㄢ

对于`B`(在Chrome中,目前),你会发现`[未定义的,未定义的,未定义的]`作为序列化,而不是`[未定义的x 3 ]`对于`一`和`C`ㄢ困惑?是的,其他人也一样ㄢ

更糟糕的是,在编写报告时,Firefox报告`[,]`对于`一`和`C`ㄢ你明白为什么会这么混乱吗?仔细看ㄢ三个逗号意味着四个插槽,而不是我们预期的三个插槽ㄢ

**什么!?**火狐加了一个额外的`,`他们在序列化的结束因为ES5,尾随逗号列表(数组的值,属性列表,等)是允许的(因此下降,忽略)ㄢ所以如果你键入一个`[,]`将值放入程序或控制台中,实际上可以得到类似的底层值ㄢ`[,]`(即,有三个空槽的数组)ㄢ这样的选择,而困惑,如果阅读开发者控制台,是防守而不是副本正贴行为准确ㄢ

如果你现在摇着头或转动眼睛,你并不孤单!耸了耸肩ㄢ

不幸的是,情况变得更糟ㄢ不仅仅是混淆控制台输出,`一`和`B`从上面的代码片段实际上在某些情况下表现相同ㄢ**但在其他方面有所不同**: 

```js
a.join( "-" ); // "--"
b.join( "-" ); // "--"

a.map(function(v,i){ return i; }); // [ undefined x 3 ]
b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

**啊ㄢ**

这个`a.map(..)`呼叫_失败_因为插槽实际上不存在,所以`地图(ⅆ)`无需迭代ㄢ`加入(ⅆ)`以不同的方式工作ㄢ基本上,我们可以认为它是这样实现的: 

```js
function fakeJoin(arr,connector) {
	var str = "";
	for (var i = 0; i < arr.length; i++) {
		if (i > 0) {
			str += connector;
		}
		if (arr[i] !== undefined) {
			str += arr[i];
		}
	}
	return str;
}

var a = new Array( 3 );
fakeJoin( a, "-" ); // "--"
```

正如你所看到的,`加入(ⅆ)`的作品,只是_假设_插槽存在并循环到`长度`价值ㄢ无论什么`地图(ⅆ)`在内部,它(显然)不做这样的假设,所以奇怪的"空槽ℽ数组的结果是意外的,并且可能导致失败ㄢ

所以,如果你想_事实上_创建一个实际数组`undefi`值(不只是"空槽ℽ),你怎么能做到(除了手动)?

```js
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]
```

困惑?是啊.下面大致讲一下它是如何工作的ㄢ

`apply(..)`对所有函数都可用的实用程序,它调用它所使用的函数,但以特殊的方式调用ㄢ

第一个参数是`这`对象绑定(包含在_对象原型_这个系列的标题),我们不关心这里,所以我们把它设置为`无效的`ㄢ第二个参数应该是数组(或什么)ㄢ_喜欢_数组ℴℴ又名"数组类似对象ℽ)ㄢ这个"数组ℽ的内容被"扩展ℽ为对所涉函数的参数ㄢ

所以,`数组ㄢ应用(..)`呼唤`数组(..)`函数和展开值(`{长度: 3 }`对象值)作为参数ㄢ

里面的`应用(ⅆ)`我们可以想象有另一个`对于`循环(有点像`加入(ⅆ)`从上面)`零`到但不包括,`长度`(`三`在我们的情况下)ㄢ

对于每个索引,它从对象中检索该键ㄢ如果数组对象参数被命名`ARR`内部的`apply(..)`函数,将有效地访问属性ㄢ`ARR [ 0 ]`,`ARR [ 1 ]`,和`ARR [ 2 ]`ㄢ当然,这些属性都不存在于`{长度: 3 }`对象值,因此所有这些属性访问中的三个都将返回值ㄢ`未定义`ㄢ

换句话说,它结束了呼叫ㄢ`数组(..)`基本上是这样的: `数组(未定义的ㄡ未定义的ㄡ未定义的)`这就是我们最终填充一个数组的原因ㄢ`未定义`值,而不仅仅是那些(疯狂的)空槽ㄢ

而`数组ㄢ应用(NULL,{长度: 3 })`是创建数组填充的一种奇怪而冗长的方式ㄢ`未定义`值,它的**极大地**比你所得到的footgun'ish更好ㄡ更可靠`数组(3)`空槽ㄢ

底线: **在任何情况下都不要**如果您有意创建和使用这些外来的空插槽数组ㄢ不要这样做ㄢ他们是疯子ㄢ

### `对象(ⅆ)`,`函数(ⅆ)`,和`正则表达式(..)`

这个`对象(ⅆ)`/`函数(ⅆ)`/`正则表达式(..)`构造函数一般都是可选的(除非特别调用,通常应该避免): 

```js
var c = new Object();
c.foo = "bar";
c; // { foo: "bar" }

var d = { foo: "bar" };
d; // { foo: "bar" }

var e = new Function( "a", "return a * 2;" );
var f = function(a) { return a * 2; };
function g(a) { return a * 2; }

var h = new RegExp( "^a*b+", "g" );
var i = /^a*b+/g;
```

几乎没有理由使用`新的object()`构造函数形式,特别是因为它强制您一次一次地添加属性,而不是一次以对象字面形式添加属性ㄢ

这个`功能`构造函数只在极少数情况下有用,在这种情况下您需要动态定义函数的参数和/或它的函数体ㄢ**不要随便对待`函数(ⅆ)`作为另一种形式`eval(..)`ㄢ**您几乎不需要以这种方式动态定义一个函数ㄢ

以文字形式定义的正则表达式(`/ *`)优先,不只是为了便于语法但出于性能原因,JS引擎缓存之前预编译和执行代码ㄢ与我们迄今为止看到的其他构造函数形式不同,`正则表达式(..)`有一些合理的实用性: 动态定义正则表达式的模式ㄢ

```js
var name = "Kyle";
var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

var matches = someText.match( namePattern );
```

这种情况经常发生在js程序中,所以您需要使用`新的正则表达式("模式ℽㄡ"旗帜ℽ)`形式ㄢ

### `日期(..)`和`错误(..)`

这个`日期(..)`和`错误(..)`本地构造函数比其他本地构造函数有用得多,因为两者都没有文字形式ㄢ

要创建日期对象值,必须使用`新的()`ㄢ这个`日期(..)`构造函数接受可选参数来指定要使用的日期/时间,但如果省略,则假定当前日期/时间ㄢ

到目前为止,构建日期对象的最常见的原因是获得当前的时间戳值(自1970年1月1日起有符号整数毫秒)ㄢ您可以通过调用`gettime()`在日期对象实例上ㄢ

但一个更简单的办法是打电话给定义为ES5静态辅助功能: `now()日期ㄢ`ㄢ和polyfill,pre-es5是很容易的: 

```js
if (!Date.now) {
	Date.now = function(){
		return (new Date()).getTime();
	};
}
```

**注: **如果你打电话`()`没有`新的`,您将得到当时的日期/时间的字符串表示形式ㄢ这种表示的确切形式并没有在语言规范中指定,尽管浏览器倾向于在一些相近的东西上达成一致: `"7月18日2014 00:31:02 gmt-0500(CDT)ℽ`ㄢ

这个`错误(..)`构造函数(非常类似)`array()`上面)的行为与`新的`关键字现在或省略ㄢ

您希望创建错误对象的主要原因是,它将当前的执行堆栈上下文捕获到对象中(在大多数js引擎中作为只读显示)ㄢ`叠ㄢ`属性一次构建)ㄢ这个堆栈上下文包括函数调用堆栈和创建错误对象的行号,这使得错误的调试变得容易得多ㄢ

您通常会使用这样一个错误对象`扔`算子: 

```js
function foo(x) {
	if (!x) {
		throw new Error( "x wasn't provided" );
	}
	// ..
}
```

错误对象实例通常至少有一个`消息`属性,有时还有其他属性(您应该将其视为只读),比如`类型`ㄢ不过,除了检查上述`堆栈`物业,通常最好是打电话ㄢ`tostring()`关于错误对象(通过强制显式或隐式地)

**提示: **技术上,除了一般`错误(..)`本地,还有其他一些特定的错误类型: `EvalError(..)`,`RangeError(..)`,`ReferenceError(..)`,`SyntaxError(..)`,`TypeError(..)`,和`URIError(..)`ㄢ但是手动使用这些特定错误的本地人是非常罕见的ㄢ如果您的程序实际上遭受了异常(如引用未声明的变量并获得一个`引用错误`错误)ㄢ

### `符号(..)`

新的6,额外的原始值类型已被添加,被称为"符号ℽㄢ符号是特殊的"唯一ℽ(没有严格的保证!)可以用作对象属性的值,不必担心碰撞ㄢ他们的设计主要是为特殊的内置行为ES6构造,但你也可以定义自己的符号ㄢ

符号可以用作属性名,但不能从程序中查看或访问符号的实际值,也不能从开发人员控制台访问ㄢ如果在开发人员控制台中评估一个符号,那么显示的是什么样子`符号(符号,创建)`例如ㄢ

有6几个预定义的符号,如静态属性的访问`符号`函数对象,比如`symbol.create`,`symbol.iterator`等来使用它们,做一些类似的事情: 

```js
obj[Symbol.iterator] = function(){ /*..*/ };
```

若要定义自己的自定义符号,请使用`符号(..)`本土ㄢ这个`符号(..)`本地"构造函数ℽ是唯一的,您不能使用它ㄢ`新的`有了它,这样做会抛出一个错误ㄢ

```js
var mysym = Symbol( "my own symbol" );
mysym;				// Symbol(my own symbol)
mysym.toString();	// "Symbol(my own symbol)"
typeof mysym; 		// "symbol"

var a = { };
a[mysym] = "foobar";

Object.getOwnPropertySymbols( a );
// [ Symbol(my own symbol) ]
```

符号实际上不是私有的ㄢ`对象ㄢgetownpropertysymbols(..)`对对象进行反射并公开显示符号),将它们用于私有或特殊属性很可能是它们的主要用例ㄢ对于大多数开发人员来说,他们可以用`_`下划线前缀,几乎总是由常规信号来表示: "嘿,这是一个私人/特殊/内部属性,所以不要碰它!ℽ

**注: ** `符号`S_不_ `对象`它们是简单的标量基元ㄢ

### 本土原型

每个内置的本地构造函数都有自己的构造函数ㄢ`原型ㄢ`对象ℴℴ`array.prototype`,`string.prototype`,等ㄢ

这些对象包含特定对象子类型特有的行为ㄢ

例如,所有字符串对象,并通过扩展(通过装箱)`一串`原语,可以访问默认行为作为定义在`string.prototype`对象ㄢ

**注: **通过文件惯例,`string.prototype.xyz`缩短`字符串# XYZ`对所有其他人也是如此ㄢ`原型ㄢ`S.

-   `字符串# indexOf(..)`: 找到在另一个字符串的字符串的位置
-   `字符串# charAt(..)`: 在字符串中的位置访问字符ㄢ
-   `#字符串substr(..)`,`#子字符串(..)`,和`字符串#片(..)`: 将字符串的一部分提取为一个新字符串
-   `# touppercase()字符串`和`# tolowercase()字符串`创建一个新字符串,转换为大写或小写
-   `# trim()字符串`: 创建一个新字符串,没有任何尾随或前导空白

没有方法修改字符串ㄢ_在的地方_ㄢ修改(如案例转换或修剪)从现有值创建新值ㄢ

凭借原型委托(见_对象原型_在本系列中的标题),任何字符串值都可以访问这些方法: 

```js
var a = " abc ";

a.indexOf( "c" ); // 3
a.toUpperCase(); // " ABC "
a.trim(); // "abc"
```

其他构造函数原型包含适合于其类型的行为,如`#固定数量(..)`(stringifying一些固定数量的小数位数),`阵列# concat(..)`(合并数组)ㄢ所有函数都可以访问`apply(..)`,`打电话(ⅆ)`,和`绑定(ⅆ)`因为`function.prototype`定义ㄢ

但是,一些本地原型不是_只是_普通的对象: 

```js
typeof Function.prototype;			// "function"
Function.prototype();				// it's an empty function!

RegExp.prototype.toString();		// "/(?:)/" -- empty regex
"abc".match( RegExp.prototype );	// [""]
```

一个特别糟糕的想法,您甚至可以修改这些本地原型(不只是添加您可能熟悉的属性): 

```js
Array.isArray( Array.prototype );	// true
Array.prototype.push( 1, 2, 3 );	// 3
Array.prototype;					// [1,2,3]

// don't leave it that way, though, or expect weirdness!
// reset the `Array.prototype` to empty
Array.prototype.length = 0;
```

正如你所看到的,`function.prototype`是函数,`regexp.prototype`是正则表达式,并且`array.prototype`是数组ㄢ有趣又酷,是吧?

#### 原型为默认值

`function.prototype`空函数,`regexp.prototype`作为一个"空ℽ(例如,非正则表达式匹配),和`array.prototype`作为一个空数组,如果变量没有适当类型的值,就让它们都是很好的"默认ℽ值来赋值给变量ㄢ

例如:

```js
function isThisCool(vals,fn,rx) {
	vals = vals ƜƜ Array.prototype;
	fn = fn ƜƜ Function.prototype;
	rx = rx ƜƜ RegExp.prototype;

	return rx.test(
		vals.map( fn ).join( "" )
	);
}

isThisCool();		// true

isThisCool(
	["a","b","c"],
	function(v){ return v.toUpperCase(); },
	/D/
);					// false
```

**注: **截至6,我们不需要使用`瓦尔斯=瓦尔斯Ɯ Ɯ ..`默认值语法技巧(参见第4章),因为缺省值可以通过函数声明中的本机语法设置为参数(参见第5章)ㄢ

这种方法的一个次要好处是`原型ㄢ`s已经创建并内置,从而创建_只有一次_ㄢ相比之下,使用`[ ]`,`function() { }`,和`/(?: )/`这些缺省值的值(可能取决于引擎实现)将重新创建这些值(并可能在以后收集垃圾)ㄢ_每次打电话_属于`isthiscool(..)`ㄢ那可能是内存/ CPU浪费ㄢ

另外,要小心不要使用ㄢ`array.prototype`作为默认值**随后将进行修改ㄢ**ㄢ在这个例子中,`瓦尔斯`是你`瓦尔斯`实际上你会被修改`array.prototype`本身,这将导致前面提到的陷阱!

**注: **虽然我们指出了这些原生原型和一些有用的东西,但要谨慎地依赖它们,并且更谨慎地以任何方式修改它们ㄢ见附录A"原生原型ℽ作更多讨论ㄢ

## 回顾

JavaScript提供了围绕原始值的对象包装器,称为本地用户ㄢ`字符串`,`数`,`布尔`等等)ㄢ这些对象包装器赋予值以访问适合每个对象子类型的行为(`# trim()字符串`和`阵列# concat(..)`)ㄢ

如果有一个简单的标量原始值,比如`"ABCℽ`你可以访问它`长度`财产或一些`string.prototype`方法,js自动地将"值ℽ封装在其相应的对象包装器中,从而实现属性/方法的访问ㄢ
