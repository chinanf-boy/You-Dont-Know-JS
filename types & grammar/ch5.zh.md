
# 你不知道JS: 类型和语法

# 第5章语法

我们要讨论的最后一个主要主题是JavaScript语言语法是如何工作的(也就是语法). 你可能认为你知道如何编写js,但是语言语法的各个部分有很多细微的差别,导致了混淆和误解,所以我们想深入了解这些部分,并澄清一些事情. 

**注: **"语法"这个词对读者来说可能比"句法"这个词稍不熟悉,在许多方面,它们是相似的术语,描述_规则_语言是如何运作的. 这里有细微的差别,但对于我们在这里的讨论大多无关紧要. JavaScript语法是一种结构化的方法来描述语法(操作符ㄡ关键字等)如何组合成格式良好的有效程序. 换句话说,不用语法讨论语法会遗漏很多重要的细节. 因此,我们在本章中的重点是最准确地描述为_语法_尽管语言的原始语法是开发人员直接与之交互的. 

## 语句和表达式

对于开发人员来说,假设"语句"和"表达式"是大致相等的,这是很常见的. 但在这里我们需要区分两者,因为js程序中有一些非常重要的区别. 

为了区分这一点,让我们借用一些你更熟悉的术语: 英语. 

"句子"是表达思想的一个完整的词的构成. 它由一个或多个短语组成,每个短语都可以连接标点符号或连词("和"ㄡ"或"). 短语本身可以由较小的短语组成. 有些短语是不完整的,不能自己完成很多事情,而其他短语可以独立完成. 这些规则统称为_语法_英语的. 

JavaScript语法也是如此. 语句是句子,表达式是短语,运算符是连词/标点符号. 

js中的每个表达式都可以被评估为单个ㄡ特定的值结果. 例如:

```js
var a = 3 * 6;
var b = a;
b;
```

在这个片段中,`3 * 6`是表达式(计算为值). `十八`). 但`一`第二行也是一个表达式,如`B`在第三行. 这个`一`和`B`表达式同时对存储在这些变量中的值进行评估,这也恰好是`十八`. 

此外,三行中的每一行都是包含表达式的语句. `var = 3 * 6`和`var`被称为"声明语句",因为它们各自声明一个变量(并且可选地为它赋值). 这个`a=3×6`和`B =一个`作业(减去`VaR`s)被称为赋值表达式. 

第三行包含表达式. `B`但它本身也是一个声明(虽然不是非常有趣的一个!)这通常被称为"表达式语句". 

### 语句完成值

几乎所有已知的语句都有完成值(即使这个值只是`未定义`). 

你怎么能看到语句的完成值呢?

最明显的答案是将语句输入到浏览器的开发控制台中,因为当执行它时,控制台默认报告它执行的最新语句的完成值. 

让我们考虑一下`var`. 该声明的完成值是多少?

这个`B =一个`赋值表达式的结果是赋值的结果(`十八`以上),但`VaR`语句本身导致`未定义`. 为什么?因为`VaR`报表定义这样的规格. 如果你把`var a=42;`在你的控制台,你会看到`未定义`发回报告而不是`四十二`. 

**注: **从技术上讲,它比那要复杂一些. 在ES5的规格,12.2节"变量声明,"`变量说明`算法实际上_做_返回一个值(a)`一串`包含声明变量的名称ℴℴ奇怪,是吗?!但是,这个值基本上是被吞噬的(除了`对..`循环)`variablestatement`强制空的算法(又名`未定义`完成值. 

事实上,如果你已经做了很多的代码在您的控制台试验(或JavaScript环境REPL --读/评估/打印/环工具),你可能已经看到了`未定义`报道过许多不同的说法后,也许从来没有意识到为什么或那是什么. 简单地说,控制台只是报告语句的完成值. 

但是控制台为完成值打印的不是我们程序中可以使用的东西. 那么我们怎样才能捕获完成值呢?

这是一个复杂得多的任务. 在我们解释_怎样_让我们来探索_为什么_你会想那样做的. 

我们需要考虑其他类型的语句完成值. 例如,任何常规的`{ ..}`块具有其最后包含的语句/表达式的完成值的完成值. 

考虑: 

```js
var b;

if (true) {
	b = 4 + 38;
}
```

如果你打到你的控制台/复制,你可能会看到`四十二`报道称,自`四十二`是的`如果`块,其上一个赋值表达式语句的完成值`b = 4 + 38`. 

换句话说,块的完成值类似于_隐性收益_块中最后一个语句值. 

**注: **这是概念上的熟悉的语言就像CoffeeScript,具有隐式`返回`值`功能`s与函数中最后一个语句值相同. 

但是有一个明显的问题. 这种代码不起作用: 

```js
var a, b;

a = if (true) {
	b = 4 + 38;
};
```

我们无法捕获语句的完成值,并以任何简单的语法/语法方式将其赋值给另一个变量(至少目前还没有). . 

那么,我们能做什么呢?

**警告**为了演示目的,不要在真正的代码中执行以下操作!

我们可以使用饱受诟病`eval(..)`(有时发音为"邪恶")函数来捕获这个完成值. 

```js
var a, b;

a = eval( "if (true) { b = 4 + 38; }" );

a;	// 42
```

yeeeaaahhhh. 真是难看极了. 但它有效!它说明了语句完成值是一个真正的东西,它不仅可以在我们的控制台中捕获,而且可以在我们的程序中捕获. 

有一个叫"建议ES7做表达. "这里是它如何工作: 

```js
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a;	// 42
```

这个`做{ ..}`表达式执行一个块(包含一个或多个语句),块内的最后语句完成值变成完成值. _属于_这个`做`表达式,然后可以分配给`一`如图所示. 

一般的想法是能够把语句当作表达式ℴℴ它们可以出现在其他语句中ℴℴ而不需要将它们封装在内联函数表达式中,并执行显式. `的回报. `. 

目前,语句完成值不只是琐事. 但随着JS的发展,它们可能会发挥更大的作用. `做{ ..}`表达式将减少使用类似的东西的诱惑. `eval(..)`. 

**警告: **重复我以前的告诫: 避免`eval(..)`. 严重. 看到_范围和关闭_本系列的标题作更多解释. 

### 表达式的副作用

大多数表情没有副作用. 例如:

```js
var a = 2;
var b = a + 3;
```

的表达`+ 3`没有_它本身_有副作用,比如变化`一`. 它有一个结果,那就是`五`结果分配给`B`在声明`b = 3`. 

表达式(可能的)副作用最常见的例子是函数调用表达式: 

```js
function foo() {
	a = a + 1;
}

var a = 1;
foo();		// result: `undefined`, side effect: changed `a`
```

不过,还有其他一些有影响的表达方式. 例如:

```js
var a = 42;
var b = a++;
```

的表达`+ +`有两种不同的行为. _弗斯特_,它返回当前值`一`,这是`四十二`(然后分配给`B`). 但_下一个_它改变了`一`本身,它由一个递增. 

```js
var a = 42;
var b = a++;

a;	// 43
b;	// 42
```

许多开发人员会错误地相信`B`有价值`四十三`就像`一`做.但混乱来自于没有充分考虑_什么时候_的副作用`+ +`算子. 

这个`+ +`增量运算符和`ℴℴ`减量运算符是一元运算符(见4章),它可以用在任何一个后缀("之后")的位置或前缀("前")的位置. 

```js
var a = 42;

a++;	// 42
a;		// 43

++a;	// 44
a;		// 44
```

什么时候`+ +`用作前缀位置`+ +`,其副作用(递增`一`)发生_之前_该值是从表达式返回的,而不是_之后_与`+ +`. 

**注: **你会觉得`++`是法律句法吗?如果你试一下,你会得到一个`引用错误`错误,但为什么?因为边影响算子**需要变量引用**把他们的副作用瞄准. 对于`++`,的`+ +`首先对部分进行求值(因为运算符优先级(见下文))返回`一` _之前_增量. 但它试图评估`+ + 42`如果你尝试的话也一样`引用错误`错误,因为`+ +`不能直接对某个值产生副作用. `四十二`. 

有时错误地认为可以封装_之后_副作用`+ +`把它包装成`()`双像: 

```js
var a = 42;
var b = (a++);

a;	// 43
b;	// 42
```

不幸的是,`()`本身不定义要评估的新包装表达式. _之后_这个_后副作用_的`+ +`表达,正如我们本来希望的那样. 事实上,即使它确实,`+ +`返回`四十二`第一,除非你有了另一种表达方式,重新评估`一`后副作用`+ +`你不会得到`四十三`从那个表达式,所以`B`将不会被分配`四十三`. 

不过,有一个选择: `,`语句系列逗号运算符. 这个操作符允许您将多个独立表达式语句串成一个语句: 

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

**注: **这个`(..)`围绕`++,a`这里需要. 原因是运算符优先级,我们将在本章后面介绍. 

的表达`++,a`意味着第二个`一`语句表达式得到评估_之后_这个_后的副作用_的第一`+ +`语句表达式,表示返回`四十三`赋值到`B`. 

另一个侧面影响操作符的例子是`删除`. 正如我们在第2章中所展示的,`删除`用于从属性中移除属性. `对象`或从一个插槽`阵列`. 但是它通常被称为独立语句: 

```js
var obj = {
	a: 42
};

obj.a;			// 42
delete obj.a;	// true
obj.a;			// undefined
```

结果值`删除`算子`真正的`如果请求的操作是有效的/允许的,或者`假`否则. 但是操作符的副作用是它删除了属性(或数组槽). 

**注: **我们说的有效/允许是什么意思?不存在的属性或存在的ㄡ可配置的属性(参见第3章)_对象原型_本系列的标题)将返回`真正的`从`删除`算子. 否则,结果将是`假`或错误. 

一方面影响运营商最后一个例子,它会立刻明显和不明显的,是`=`赋值操作符. 

考虑: 

```js
var a;

a = 42;		// 42
a;			// 42
```

看起来可能不像`=`在里面`= 42`表达式的副作用运算符. 但是,如果我们检查结果值`= 42`语句,它是刚才赋值的值. `四十二`)因此赋值相同的值到`一`本质上是副作用. 

**提示: **关于副作用的推理同样适用于复合赋值操作符. `+ =`,`- =`例如,例如,`a = B+ = 2`首先处理为`B+=2`(这是`b=B+ 2`)和结果_那个_ `=`分配然后分配给`一`. 

赋值表达式(或语句)导致赋值的这种行为主要用于链式赋值,例如: 

```js
var a, b, c;

a = b = c = 42;
```

在这里,`C = 42`评价`四十二`(与分配的副作用有关)`四十二`到`C`),然后`B = 42`评价`四十二`(与分配的副作用有关)`四十二`到`B`,最后`= 42`被赋值(带有分配的副作用. `四十二`到`一`). 

**警告: **开发人员使用链赋值时犯的一个常见错误是`var a = b = 42`. 虽然这看起来是一样的,但不是. 如果那句话没有发生,也会有一个单独的. `VaR B`(范围内某个地方)正式声明`B`,然后`var a = b = 42`不会宣布`B`直接. 根据`严格的`模式,即抛出错误或创建意外的全局(参见_范围和关闭_本系列的标题). 

需要考虑的另一个方案: 

```js
function vowels(str) {
	var matches;

	if (str) {
		// pull out all the vowels
		matches = str.match( /[aeiou]/g );

		if (matches) {
			return matches;
		}
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

这是可行的,许多开发者更喜欢这样. 但是,使用一个习语,我们利用了赋值副效应,我们可以通过将两者结合起来简化. `如果`语句合一: 

```js
function vowels(str) {
	var matches;

	// pull out all the vowels
	if (str && (matches = str.match( /[aeiou]/g ))) {
		return matches;
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

**注: **这个`(..)`围绕`比赛= str.match ..`是必需的. 原因是运算符优先级,我们将在本章后面的"运算符优先"部分中讨论. 

我喜欢这个较短的风格,因为我认为它使我们更加清楚地认识到这两个条件实际上是相关而不是单独的. 但正如JS中的大多数文体选择一样,纯粹是一种观点. _更好的_. 

### 关联规则

JavaScript语法规则中有相当多的地方,相同的语法意味着不同的东西,取决于它在哪里使用. 这种事情在孤立的情况下会引起相当大的混乱. 

我们不会详尽列出所有这样的例子,只是调用一些常见的例子. 

#### `{ ..}`大括号

有两个主要的地方(随着JS的发展而来的更多!)那一双`{ ..}`花括号将显示在您的代码中. 让我们看看它们中的每一个. 

##### 对象字面量

首先,作为`对象`字面意义的:

```js
// assume there's a `bar()` function defined

var a = {
	foo: bar()
};
```

我们怎么知道这是一个`对象`文字?因为`{ ..}`配对是一个被分配到的值. `一`. 

**注: **这个`一`引用"左值"(又名左值)因为它是赋值的目标. 这个`{ ..}`对一个"R"(又名右值)由于它的使用_只是_作为一个值(在本例中作为赋值的源). 

##### 标签

如果我们去掉`var a =`上面的片段的一部分?

```js
// assume there's a `bar()` function defined

{
	foo: bar()
}
```

许多开发人员假定`{ ..}`配对只是一个独立的`对象`字面上没有分配到任何地方. 但事实上完全不同. 

在这里,`{ ..}`只是一个普通的代码块. 它在JavaScript中不是很流行(在其他语言中更是如此)!有独立的`{ ..}`块一样,但它是完全有效的JS语法. 它可以特别有帮助时,结合`让`块作用域声明(见_范围和关闭_本系列中的标题). 

这个`{ ..}`这里的代码块在功能上相当于连接到某个语句的代码块,如`对于`/`虽然`环,`如果`有条件的,等等. 

但是如果它是一个正常的代码块,那么奇怪的是什么?`福: bar()`语法,这是合法的吗?

这是因为JavaScript中有一个鲜为人知的(而且,坦率地说,气馁的)特性称为"标记语句". `Foo`是语句的标签. `bar()`(省略了它的尾部)`;`ℴℴ看到"自动分号"在本章的后面). 但是有标记的陈述有什么意义呢?

如果javascript有`goto`声明,你在理论上可以说`转到foo`并在代码中执行跳转到该位置. `goto`s通常被认为是糟糕的编码习惯用法,因为它们使代码更难理解(又名"意大利面条代码"),所以它是一个_很好的东西_JavaScript没有通用代码`goto`. 

然而,JS_做_支持有限的ㄡ特殊的形式`goto`: L`持续`和`打破`语句可以选择性地接受指定的标签,在这种情况下,程序流"跳跃"类似于`goto`. 考虑: 

```js
// `foo` labeled-loop
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		// whenever the loops meet, continue outer loop
		if (j == i) {
			// jump to the next iteration of
			// the `foo` labeled-loop
			continue foo;
		}

		// skip odd multiples
		if ((j * i) % 2 == 1) {
			// normal (non-labeled) `continue` of inner loop
			continue;
		}

		console.log( i, j );
	}
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

**注: ** `继续Foo`并不意味着"转到"标记的位置继续",而是"继续循环,在下一次迭代中被标记为'富ℹ. _真正地_任意一个`goto`. 

正如你所看到的,我们跳过了奇数个倍数. `3 1`迭代,但标记循环跳转也跳过迭代. `1 1`和`2 2`. 

也许标记跳转的一种更有用的形式是`打破__`从内部循环中,你要跳出外循环. 无标记`打破`同样的逻辑有时也很难写: 

```js
// `foo` labeled-loop
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		if ((i * j) >= 3) {
			console.log( "stopping!", i, j );
			// break out of the `foo` labeled loop
			break foo;
		}

		console.log( i, j );
	}
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// stopping! 1 3
```

**注: ** `打破Foo`并不意味着"转到"标记的位置继续,而是"跳出循环/块",标记为"富"并继续. _之后_"不完全是`goto`按照传统意义,嗯?

nonlabeled`打破`替代上述可能需要涉及一个或多个功能,共享范围变量访问等,它很可能会比标签更混乱. `打破`所以在这里使用一个标签`打破`也许是更好的选择. 

标签可以应用于非循环块,但仅适用于`打破`可以引用这样的非循环标签. 你可以做个标记`打破___`任何标签的区块,但你不能`继续___`非循环标签,也不能做非标记. `打破`走出街区. 

```js
function foo() {
	// `bar` labeled-block
	bar: {
		console.log( "Hello" );
		break bar;
		console.log( "never runs" );
	}
	console.log( "World" );
}

foo();
// Hello
// World
```

标有循环/块是非常罕见的,往往皱眉头. 如果可能的话,最好避免它们;例如使用函数调用而不是循环跳转. 但是可能有一些有限的情况下可能有用. 如果你要使用标记跳转,一定要用大量的注释来记录你正在做的事情!

很常见的一个信念是JSON是js的一个适当子集,所以是一个JSON字符串(比如`{"A": 42 }`注意JSON所要求的属性名称周围的引号!)被认为是一个有效的JavaScript程序. **不是真的!**试着把`{"A": 42 }`进入你的js控制台,你会得到一个错误. 

这是因为语句标签不能引用引号,所以`"一个"`不是有效的标签,因此`: `不能马上就来. 

因此,JSON确实是js语法的一个子集,但JSON本身不是有效的js语法. 

沿着这条线的一个非常常见的误解是,如果要将js文件加载到`<`只包含JSON内容的标记(比如从API调用),数据将被读为有效的JavaScript,但只是程序无法访问. JSON-P(包皮的JSON数据的函数调用中,实践像`富({): 42 }`)通常是通过发送的值的一个程序的功能解决这一难. 

**不是真的!**完全有效的JSON值`{"A": 42 }`实际上,它会抛出一个JS错误,因为它将被解释为带有无效标签的语句块. 但`富({): 42 }`是有效js因为它在里面,`{"A": 42 }`是一个`对象`文字值传递到`富(ⅆ)`. 所以,适当地说,**为有效的js语法JSON-P使JSON!**

##### 阻碍

另一个经常被引用的JS问题(与强制ℴℴ见4章)是: 

```js
[] + {}; // "[object Object]"
{} + []; // 0
```

这似乎意味着`+`运算符根据第一个操作数是否为`[ ]`或`{ }`. 但这实际上与它无关!

在第一行,`{ }`出现在`+`运算符表达式,因此被解释为实际值(空值). `对象`). 第4章解释了`[ ]`是被迫的`""`因此,`{ }`被强迫为`一串`价值观: `"[对象对象]`. 

但在第二行,`{ }`被解释为独立的`{ }`空块(什么也不做). 块不需要分号终止它们,所以这里的人不是问题,缺乏. 最后,`+ [ ]`是一个表达式_明确胁迫_(见第4章)`[ ]`一个`数`,这是`零`价值. 

##### 对象解构

从6,另一个,你会看到的地方`{ ..}`对出现"解构的任务"(见_6与超越_关于更多信息的这个系列的标题),特别是`对象`解构. 考虑: 

```js
function getData() {
	// ..
	return {
		a: 42,
		b: "foo"
	};
}

var { a, b } = getData();

console.log( a, b ); // 42 "foo"
```

正如你所说的,`{`是一种6解构的任务,这大约相当于: 

```js
var res = getData();
var a = res.a;
var b = res.b;
```

**注: ** `{ A,B }`其实是6解构速记`{ A,B: B }`所以两种方法都能起作用,但期望更短. `{ A,B }`将成为首选形式. 

解构与对象`{ ..}`成对也可以用于命名函数参数,对于相同类型的隐式对象属性赋值,它是糖: 

```js
function foo({ a, b, c }) {
	// no need for:
	// var a = obj.a, b = obj.b, c = obj.c
	console.log( a, b, c );
}

foo( {
	c: [1,2,3],
	a: 42,
	b: "foo"
} );	// 42 "foo" [1, 2, 3]
```

所以,我们使用的上下文`{ ..}`配对完全决定了它们的意思,这说明了语法和语法的区别. 理解这些细微差别对于避免JS引擎意外的解释是非常重要的. 

#### `否则如果`可选模块

人们普遍认为JavaScript有一个`否则如果`从句,因为你可以: 

```js
if (a) {
	// ..
}
else if (b) {
	// ..
}
else {
	// ..
}
```

但是有一个隐藏的`否则如果`. 但`如果`和`其他的`语句可以省略`{ }`如果只包含一个语句,则围绕它们的附加块. 毫无疑问,你以前见过很多次: 

```js
if (a) doSomething( a );
```

许多JS风格的指南将坚持你总是使用`{ }`围绕一个语句块,比如: 

```js
if (a) { doSomething( a ); }
```

然而,完全相同的语法规则适用于`其他的`子句,所以`否则如果`你可能总是编码的形式是_事实上_解析: 

```js
if (a) {
	// ..
}
else {
	if (b) {
		// ..
	}
	else {
		// ..
	}
}
```

这个`如果(b){ⅆ{其他{}`是一个单一的语句,如下`其他的`所以你可以把周围的环境`{ }`在或不. 换句话说,当你使用`否则如果`你在技术上打破了普通风格的指导原则,只是定义你的`其他的`一个单一的`如果`声明. 

当然,`否则如果`习语非常常见,导致缩进的程度降低,所以很有吸引力. 不管你做什么,只要明确地说出你自己的风格指南/规则,不要想当然. `否则如果`直接语法规则. 

## 运算符的优先级

正如我们在第4章所述,JavaScript的版本`&`和`Ɯ Ɯ`有趣的是,它们选择并返回一个操作数,而不仅仅是`真正的`或`假`. 如果只有两个操作数和一个操作符,那么很容易推理. 

```js
var a = 42;
var b = "foo";

a && b;	// "foo"
a ƜƜ b;	// 42
```

但是如果有两个操作符,还有三个操作数呢?

```js
var a = 42;
var b = "foo";
var c = [1,2,3];

a && b ƜƜ c; // ???
a ƜƜ b && c; // ???
```

为了理解这些表达式的结果,我们需要了解在表达式中有多个表达式时,哪些规则支配运算符如何处理. 

这些规则称为"运算符优先级". 

我敢打赌大多数读者都觉得他们对操作员的优先权有很强的把握. 但正如我们在这本书系列中所涵盖的一切,我们将对这一理解进行深入的研究,希望看到它到底有多真实,并希望在这一过程中学到一些新东西. 

回想上面的例子: 

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

但是如果我们去掉`()`?

```js
var a = 42, b;
b = a++, a;

a;	// 43
b;	// 42
```

等待!为什么会改变分配给`B`?

因为`,`运算符的优先级比`=`算子. 所以,`b ++,a`被解释为`(b = ++),a`. 因为(正如我们前面所解释的)`+ +`有_后的副作用_赋值值为`B`是价值`四十二`之前`+ +`变化`一`. 

这仅仅是需要理解运算符优先级的一个简单问题. 如果你打算使用`,`作为语句序列运算符,知道它的优先级最低是很重要的. 每一个接线员都比他更紧. `,`将. 

现在,请回忆上面的例子: 

```js
if (str && (matches = str.match( /[aeiou]/g ))) {
	// ..
}
```

我们说的`()`围绕作业是必需的,但是为什么呢?因为`&`具有更高的优先权`=`所以没有`()`为了强制绑定,表达式将被视为`(STR和火柴)= str.match ..`. 但这将是一个错误,因为`(STR与匹配)`不是一个变量,而是一个值(在这种情况下)`未定义`),所以它不能是一个`=`分配!

好吧,你可能认为你把算符优先权放在下面了. 

让我们转到一个更复杂的例子(我们将在本章的接下来的几节中进行)_真正地_测试你的理解: 

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b ƜƜ c ? c ƜƜ b ? a : c && b : a;

d;		// ??
```

好吧,恶魔,我承认. 没有人会像那样写一串表达式,对吧?_可能_不是,但是我们要用它来检查围绕多个操作符链接的各种问题,_是_很普通的任务. 

以上结果是`四十二`. 但这并不像我们如何能找到答案一样有趣,而不只是把它插入js程序中,让JavaScript把它整理出来. 

让我们挖进去. 

第一个问题ℴℴ你可能没想到要问ℴℴ第一部分是这样的吗?`一个与B Ɯ Ɯ C`)像`(A和B)Ɯ Ɯ C`或者像`一个与(B Ɯ Ɯ C)`?你肯定吗?你能说服自己事实上是不同的吗?

```js
(false && true) ƜƜ true;	// true
false && (true ƜƜ true);	// false
```

所以,有证据证明他们是不同的. 但是,怎么会呢?`虚假与真实的Ɯ Ɯ真实`的行为?答案: 

```js
false && true ƜƜ true;		// true
(false && true) ƜƜ true;	// true
```

所以我们有了答案. 这个`&`首先对运算符进行求值,然后`Ɯ Ɯ`运算符求值为第二. 

但这仅仅是因为左到右的处理吗?让我们颠倒算符的顺序: 

```js
true ƜƜ false && false;		// true

(true ƜƜ false) && false;	// false -- nope
true ƜƜ (false && false);	// true -- winner, winner!
```

现在我们已经证明了这一点. `&`先评估然后`Ɯ Ɯ`在这种情况下,它实际上与一般期望的左到右处理相反. 

那么是什么导致了这种行为呢?**运算符的优先级**. 

每种语言都定义自己的运算符优先级列表. 这是令人沮丧的,虽然,JS开发者已经读过JS的名单,这是多么罕见. 

如果你知道得很清楚,上面的例子一点也不会把你绊倒,因为你已经知道了. `&`比先例更`Ɯ Ɯ`. 但我敢打赌,相当多的读者必须考虑一下. 

**注: **不幸的是,js规范在一个方便的单个位置上并没有真正的操作符优先级列表. 你必须分析并理解所有的语法规则. 因此,我们将尝试以更方便的格式来列出更通用和有用的比特. 对于一个复杂的[https://developer.mozilla.org/en-us/docs/web/javascript/reference/operators/operator_precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)). 

### 短路

在第4章中,我们在一个侧面提到了操作符的"短路"性质. `&`和`Ɯ Ɯ`. 现在让我们更详细地回顾一下. 

两`&`和`Ɯ Ɯ`操作符,右边的操作数将**不进行评估**如果左操作数足够确定操作的结果. 因此,名称"短路"(如果可能的话,它将采取早期捷径). 

例如,`甲与乙`,`B`不评估是否`一`是falsy,因为这个结果`&`操作数已经确定了,所以麻烦检查是没有意义的. `B`. 同样,与`一个Ɯ Ɯ B`,如果`一`真相是,操作数的结果是已经确定的,所以没有必要检查`B`. 

这种短路可能非常有用,而且很常用: 

```js
function doSomething(opts) {
	if (opts && opts.cool) {
		// ..
	}
}
```

这个`选择`部分的`选择与opts.cool`测试就像一个警卫,因为如果`选择`不(或不`对象`,表达式`opts.cool`会出错. 这个`选择`测试失败加短路意味着`opts.cool`甚至不会被评估,因此不会出错!

同样,您也可以使用`Ɯ Ɯ`短路: 

```js
function doSomething(opts) {
	if (opts.cache ƜƜ primeCache()) {
		// ..
	}
}
```

这里,我们正在检查`opts.cache`首先,如果它存在,我们不调用`primecache()`功能,从而避免潜在的不必要的工作. 

### 紧密结合

但是让我们把注意力转移到前面的复杂语句例子中,所有的链操作符,特别是`?: `三元算子部件. 做`?: `运算符的优先级比`&`和`Ɯ Ɯ`运营商?

```js
a && b ƜƜ c ? c ƜƜ b ? a : c && b : a
```

这样更像这样吗?: 

```js
a && b ƜƜ (c ? c ƜƜ (b ? a : c) && b : a)
```

或者这个?

```js
(a && b ƜƜ c) ? (c ƜƜ b) ? a : (c && b) : a
```

答案是第二个. 但是为什么呢?

因为`&`比先例更`Ɯ Ɯ`,和`Ɯ Ɯ`比先例更`?: `. 

那么,表达式`(A和B Ɯ Ɯ C)`评价_第一_之前`?: `它参与. 另一种常见的解释是`&`和`Ɯ Ɯ`"绑得更紧"比`?: `. 如果相反的是真的,那么`C?C.`会更紧密地结合,它会像第一选择一样表现出来. `一个与B Ɯ Ɯ(C?C. )`. 

### 结合性

因此,该`&`和`Ɯ Ɯ`运算符首先绑定,然后`?: `算子. 但是相同优先级的多个操作符呢?他们总是从左到右还是从左到右?

一般来说,操作符要么是左联想,要么是右联想,指的是**分组发生在左边或右边. **. 

需要注意的是,关联性是很重要的_不_相同的事情,从左到右或从左到右的处理. 

但是为什么处理是左对右还是左对有关系呢?因为表达式可能有副作用,比如函数调用: 

```js
var a = foo() && bar();
```

在这里,`foo()`先评估,然后评估. `bar()`取决于结果`foo()`表达. 这肯定会导致不同的程序行为,而不是`bar()`被称为前`foo()`. 

但这种行为是_只是_从左到右的处理(JavaScript中的默认行为!)ℴℴ它无关的相关性`&`. 在这个例子中,因为只有一个`&`因此,没有相关的分组,结合甚至不发挥作用. 

但是用一个表达式`健康与健康`,分组_将_发生隐式,这意味着要么`甲与乙`或`理学学士`将首先评估. 

技术上,`健康与健康`will be handled as`(A和B)和C`,因为`&`是左联想的(所以是`Ɯ Ɯ`顺便说一下). 然而,正确的联想替代`和(b和C)`同样表现明显. 对于相同的值,相同的表达式按相同的顺序进行计算. 

**注: **如果假设`&`是正确的关联,它将被处理,就像你手动使用一样. `()`创建分组如下`和(b和C)`. 但这仍**并不意味着**那个`C`将被处理之前`B`. 右结合性呢**不**意思是从右到左的评价,意思是从左到右. **分组**. 无论哪种方式,无论分组/相关性,评价严格的订货会`一`,然后`B`,然后`C`(左至右). 

所以那并不重要. `&`和`Ɯ Ɯ`在我们讨论它们的定义时,它们是左联想的,而不是精确的. 

但情况并非总是如此. 一些运营商将非常不同左结合性与正确性的行为. 

考虑`?: `("三元"或"条件")运算符: 

```js
a ? b : c ? d : e;
```

`?: `是正确的关联,那么哪个分组代表它将如何被处理?

-   `一个吗?乙: (c?)D: E)`
-   `(一个?丙: C)?D: E`

答案是`一个吗?乙: (c?)D: E)`. 不像`&`和`Ɯ Ɯ`以上,右结合性这里的实际问题,为`(一个?丙: C)?D: E` _将_对某些人采取不同的行为(但不是全部)!价值组合. 

一个这样的例子: 

```js
true ? false : true ? true : true;		// false

true ? false : (true ? true : true);	// false
(true ? false : true) ? true : true;	// true
```

更微妙的差异潜藏在其他的价值组合中,即使最终结果是一样的. 考虑: 

```js
true ? false : true ? true : false;		// false

true ? false : (true ? true : false);	// false
(true ? false : true) ? true : false;	// false
```

从这种情况来看,相同的最终结果意味着分组是没有实际意义的. 然而:

```js
var a = true, b = false, c = true, d = true, e = false;

a ? b : (c ? d : e); // false, evaluates only `a` and `b`
(a ? b : c) ? d : e; // false, evaluates `a`, `b` AND `e`
```

所以,我们已经清楚地证明了这一点. `?: `是正确的关联,它实际上与操作符如何操作有关,如果链接自己的话. 

另一个例子是右结合(分组)`=`算子. 回忆本章前面提到的链式赋值示例: 

```js
var a, b, c;

a = b = c = 42;
```

我们早些时候断言`a = b = c=42`首先通过评估`C = 42`分配,然后`B = ..`,最后`a ..`. 为什么?因右结合性,这实际上是把这样的说法: `a =(b =(c=42))`. 

还记得我们在本章前面的运行复杂赋值表达式示例吗?

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b ƜƜ c ? c ƜƜ b ? a : c && b : a;

d;		// 42
```

武装我们的优先级和结合性的知识,我们现在应该能够打破代码的分组这样的行为: 

```js
((a && b) ƜƜ c) ? ((c ƜƜ b) ? a : (c && b)) : a
```

或者,如果它更容易理解,就把它缩进: 

```js
(
  (a && b)
    ƜƜ
  c
)
  ?
(
  (c ƜƜ b)
    ?
  a
    :
  (c && b)
)
  :
a
```

让我们现在就解决它: 

1.  `(A和B)`是`"foo"`. 
2.  `"foo"Ɯ Ɯ C`是`"foo"`. 
3.  对于第一`?`测试,`"foo"`是真相. 
4.  `(C Ɯ Ɯ B)`是`"foo"`. 
5.  第二`?`测试,`"foo"`是真相. 
6.  `一`是`四十二`. 

就这样,我们完了!答案是`四十二`正如我们早些时候看到的. 那其实并不难,是吗?

### 消歧

你现在应该有一个更好的把握(运算符优先级和结合性)感觉舒服多了理解代码的多个连锁经营者的行为. 

但一个重要的问题是: 我们都应该写代码的理解和完全依靠算符优先/结合所有的规则?我们应该只使用`()`当需要强制处理不同的绑定/顺序时,手动分组吗?

或者,另一方面,我们是否应该认识到,即使这样的规则?_事实上是_可以学习的,有足够的陷阱需要忽略自动优先/关联性?如果是这样,我们应该这样使用吗?`()`手动分组和删除所有依赖于这些自动行为?

这场辩论非常主观,而且与第4章中的辩论相当对称. _隐性的_强制. 大多数开发人员对这两种争论都有同样的感觉: 要么接受行为,要么期待代码,要么放弃这两种行为,要么坚持手工/显性的习语. 

当然,我不能在这里回答读者的问题,而不是第4章. 但我已经向你介绍了利弊,并希望鼓励足够深入的理解,你可以作出知情而不是炒作驱动的决定. 

在我看来,有一个重要的中间地带. 我们应该把两算符优先/关联性_和_ `()`在我们的程序中手动分组ℴℴ我在第4章中同样讨论了健康/安全的使用方法. _隐性的_胁迫,但肯定不完全赞同它. 

例如,`如果(A和B和C)ⅆ`对我来说完全没问题,我也不会. `如果((A和B)和C)ⅆ`只是显式调用的关联,因为我觉得它过于冗长. 

另一方面,如果我需要链接两个`?: `条件运算符在一起,我当然会使用. `()`手动分组,使它绝对清楚我的预期逻辑是什么. 

因此,我在这里的建议类似于第4章: **使用运算符的优先级/相关性,导致更短和更干净的代码,但使用`()`手动分组的地方,它有助于创造清晰和减少混乱. **

## 自动分号

ASI(自动分号插入)是当JavaScript假定`;`在你的js程序中的某些地方,即使你没有放在那里. 

为什么会这样做?因为如果你忽略一个要求`;`你的程序会失败. 不太宽容. ASI允许JS对某些地方容忍. `;`通常被认为是不必要的. 

注意,我只会在一个换行符的存在起作用是很重要的(又名换行). 分号是不是插在中间的一条线. 

基本上,如果JS解析器解析一个解析器错误发生的行(一个丢失的期望)`;`而且它可以合理地插入一个,它确实如此. 什么是合理的插入?如果只有空格和/或意见之间的一些声明,行的换行/换行. 

考虑: 

```js
var a = 42, b
c;
```

JS应该治疗吗?`C`作为下一行的一部分`VaR`声明?当然,如果`,`在任何地方(甚至另一条线)之间`B`和`C`. 但由于没有一个,js假设有一个隐含的`;`(在换行)后`B`. 因此,`C;`作为独立表达式语句保留. 

同样: 

```js
var a = 42, b = "foo";

a
b	// "foo"
```

这仍然是一个没有错误的有效程序,因为表达式语句也接受了ASI. 

有些地方,ASI是有用的,比如说: 

```js
var a = 42;

do {
	// ..
} while (a)	// <-- ; expected here!
a;
```

语法需要一个`;`之后`而做..`循环,但不是`虽然`或`对于`环. 但是大多数开发人员都不记得了!所以,我做的步骤和插入一个. 

正如我们在本章前面所述,语句块不需要`;`终止,所以ASI是不必要的: 

```js
var a = 42;

while (a) {
	// ..
} // <-- no ; expected here
a;
```

另一个主要的情况是ASI踢的是`打破`,`持续`,`返回`,和(6)`产量`关键词: 

```js
function foo(a) {
	if (!a) return
	a *= 2;
	// ..
}
```

这个`返回`声明没有在换行的`a=2`表达式,如ASI假设`;`终止`返回`声明. 当然,`返回`声明_可以_容易跨越多行,只是当没有后`返回`但换行/换行. 

```js
function foo(a) {
	return (
		a * 2 + 3 / 12
	);
}
```

相同的推理适用于`打破`,`持续`,和`产量`. 

### 误差校正

争论最激烈的人之一_宗教战争_在JS社区中(除了制表符和空格)是否完全依赖于ASI. 

大多数,但不是所有的,分号是可选的,但两`;`在`为(ⅆ)..`循环头是必需的. 

在这场辩论的有利方面,许多开发人员认为ASI是一种有用的机制,它可以通过省略除了严格要求以外的所有内容来编写更简洁(更漂亮)的代码. `;`S(很少). 人们常说ASI制造了很多. `;`是可选的,所以写的程序正确. _没有他们_与编写正确的程序没有什么不同. _他们_. 

在争论的另一面,许多其他开发者会断言有_太多的_的地方,可意外的陷阱,尤其是新的,经验不足的开发商,在那里意外`;`魔法插入改变了意义. 同样,一些开发商会认为,如果他们省略分号,这是彻头彻尾的错误,他们希望他们的工具(棉短绒等)在JS引擎抓住它_纠正_封面下的错误. 

让我来分享我的观点. 对规范的严格解读意味着ASI是一个"纠错"例程. 你可能会问,这是什么样的错误?具体地说,一个**分析器错误**. 换句话说,为了使解析器失败更少,ASI允许它更宽容. 

但是容忍什么呢?在我看来,唯一的办法是**分析器错误**如果这是发生了一个不正确/错误程序解析. 所以,当ASI是严格纠正分析器错误,可以得到这样的错误的唯一方法就是如果有第一个程序制作错误--省略分号,语法规则要求. 

所以,直率地说,当我听到有人说他们想省略"可选的分号,"我的大脑会声称"我要写的程序,我可以打破大多数解析器仍然会工作. "

我发现这是一个可笑的位置,以及保存击键和拥有更多"漂亮代码"的论点充其量是弱的. 

此外,我不同意这与空间与标签的争论是相同的,那是纯粹的化妆,但我相信这是一个基本的问题,写代码遵守语法需求和依赖语法例外的代码,只是勉强通过. 

看它的另一种方式是依靠ASI主要考虑换行是重要的"空白". 其他语言如Python有真正的重大空白. 但这真的是适当的把JavaScript有显著的新行,因为它代表今天吗?

我的花: **使用分号的地方,你知道他们是"需要"和限制你的假设ASI到最小. **

但别相信我的话. 在2012回,JavaScript Brendan Eich说(创造者<http://brendaneich.com/2012/04/the-infernal-semicolon/>)以下: 

> 这个故事的寓意: ASI(正式地说)是一个语法错误纠正程序. 如果你开始编码,如果它是一个具有普遍意义的新规则,你会有麻烦的. 

## ..

我希望我有换行符在JS早在这十天,在1995年5月更明显. _.._如果给JS显著换行不要使用ASI. `错误`JavaScript不仅有不同的功能`亚型`错误(`TypeError`,

引用错误`,`语法错误

但是,语法也定义了在编译时要执行的某些错误,与运行时发生的所有其他错误相比较. `特别是,长期以来有许多特定的情况应被捕捉和报告为"早期错误"(在编译过程中). 任何垂直语法错误都是早期错误,`a,

**),而且语法定义的东西,但还是语法有效无效. **因为你的代码执行尚未开始,这些错误是不可捕与

试试. 赶上

```js
var a = /+foo/;		// Error!
```

它们只会对程序的解析/编译失败. `提示: `规范中没有关于浏览器(和开发工具)应该如何报告错误的要求. 因此,在下面的错误示例中,您可以看到浏览器之间的差异,报告错误的特定子类型或包含的错误消息文本. 

```js
var a;
42 = a;		// Error!
```

一个简单的例子是正则表达式中的语法. 还有用js语法这没有错,但无效的正则表达式将抛出一个早期的错误: `赋值的目标必须是一个标识符(或6解构表达产生一个或多个标识符),所以一般的价值`四十二`那个位置是非法的,可以马上报告: `ES5的

```js
function foo(a,b,a) { }					// just fine

function bar(a,b,a) { "use strict"; }	// Error!
```

严格的`模式`模式早期错误是具有相同名称的多个属性的对象文字: 

```js
(function(){
	"use strict";

	var a = {
		b: 42,
		b: 43
	};			// Error!
})();
```

**注: **从语义上讲,这样的错误不是技术上的. _语法_但更多的错误_语法_错误--上面的片断语法有效. 但既然没有`grammarerror`类型,一些浏览器使用`语法错误`相反. 

### 过早使用变量

6定义(坦白困惑的命名)的新概念称为TDZ("时间死区"). 

TDZ是指地方在代码中的变量引用还不能做,因为它还没有达到其所需的初始化. 

这个最明显的例子是6`让`块作用域: 

```js
{
	a = 2;		// ReferenceError!
	let a;
}
```

分配`= 2`访问`一`(这确实是块变量的范围`{ ..}`块)在初始化之前`让一个`声明,所以它在叶片`一`并抛出一个错误. 

有趣的是,虽然`类型`对未声明的变量是安全例外(见1章),没有这样的安全例外了TDZ参考: 

```js
{
	typeof a;	// undefined
	typeof b;	// ReferenceError! (TDZ)
	let b;
}
```

## 函数的参数

另一个例子可以看到ES6 TDZ违反默认参数值(见_6与超越_本系列的标题): 

```js
var b = 3;

function foo( a = 42, b = a + b + 5 ) {
	// ..
}
```

这个`B`在分配参考会发生在叶片的参数`B`(不要拉到外面`B`引用),因此它将抛出一个错误. 然而,这`一`在分配好的时间以来,已经为参数的TDZ`一`. 

当使用ES6的默认参数值,默认值是如果你省略参数的参数,或者你通过`未定义`它的价值: 

```js
function foo( a = 42, b = a + 1 ) {
	console.log( a, b );
}

foo();					// 42 43
foo( undefined );		// 42 43
foo( 5 );				// 5 6
foo( void 0, 7 );		// 42 7
foo( null );			// null 1
```

**注: ** `无效的`被强迫为`零`中的价值`+ 1`表达. 更多信息见第4章. 

从6默认参数值的角度来看,有省略参数和传递之间无差异`未定义`价值. 然而,在某些情况下有一种检测差异的方法: 

```js
function foo( a = 42, b = a + 1 ) {
	console.log(
		arguments.length, a, b,
		arguments[0], arguments[1]
	);
}

foo();					// 0 42 43 undefined undefined
foo( 10 );				// 1 10 11 10 undefined
foo( 10, undefined );	// 2 10 11 10 undefined
foo( 10, null );		// 2 10 null 10 null
```

即使默认参数值应用于`一`和`B`参数,如果在这些槽中没有参数传递,则`争论`数组将不具有条目. 

反之,如果你通过了`未定义`参数显式,将在`争论`用于该参数的数组,但将是`未定义`并且不一定是相同的槽上应用于命名参数的默认值. 

而6默认参数值可以产生分歧`争论`阵列槽和相应的命名参数,同样也可以发生在微妙的方式脱节在ES5: 

```js
function foo(a) {
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 42 (linked)
foo();		// undefined (not linked)
```

如果您传递了一个参数,则`争论`插槽和命名参数链接始终具有相同的值. 如果省略参数,则不会出现此类连接. 

但在`严格的`模式,该链接不存在,无论: 

```js
function foo(a) {
	"use strict";
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 2 (not linked)
foo();		// undefined (not linked)
```

依赖任何这样的链接几乎是一个坏主意,实际上连接本身是一个泄露的抽象,它暴露了引擎的底层实现细节,而不是一个设计正确的特性. 

使用的`争论`阵列已过时(尤其是赞成ES6`ⅆ`其余参数ℴℴ参见_6与超越_这一系列的标题),但这并不意味着这一切都是糟糕的. 

前6,`争论`是将所有传递的参数数组传递给其他函数的唯一方法,结果非常有用. 还可以将命名参数与`争论`只要你遵循一个简单的规则,就可以安全地排列: **永远不要引用命名参数. _和_其相应的`争论`同时开槽. **如果您避免这种不良做法,您将永远不会暴露泄漏链接行为. 

```js
function foo(a) {
	console.log( a + arguments[1] ); // safe!
}

foo( 10, 32 );	// 42
```

## `最后尝试..`

你可能很熟悉`试试. 赶上`块的作品. 但你有没有停下来考虑一下`最后`可以搭配的从句吗?事实上,你知道吗?`尝试`只需要`抓住`或`最后`,如果需要,两者都可以存在. 

中的代码`最后`条款_总是_运行(不管什么),它总是运行后的`尝试`(和`抓住`如果存在)在其他代码运行之前完成. 从某种意义上说,您可以考虑`最后`子句在回调函数中,该函数总是被调用,而不管其他块的行为如何. 

那么如果有一个`返回`表内`尝试`条款?它显然会返回一个值,对吗?但是,接收该值的调用代码在运行之前还是之后运行`最后`?

```js
function foo() {
	try {
		return 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "never runs" );
}

console.log( foo() );
// Hello
// 42
```

这个`返回42`立即运行,它从`foo()`呼叫. 此动作完成`尝试`条款和`最后`子句紧接着运行. 只有那时`foo()`函数完成,以便将其完成值返回给`控制台(ⅆ)`语句使用. 

完全相同的行为是真实的`扔`里面`尝试`: 

```js
 function foo() {
	try {
		throw 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "never runs" );
}

console.log( foo() );
// Hello
// Uncaught Exception: 42
```

现在,如果在一个异常中抛出异常(意外或有意)`最后`子句,它将覆盖作为该函数的主要完成. 如果以前`返回`在`尝试`布洛克为福定了一个完成值. 

```js
function foo() {
	try {
		return 42;
	}
	finally {
		throw "Oops!";
	}

	console.log( "never runs" );
}

console.log( foo() );
// Uncaught Exception: Oops!
```

其他的非线性控制语句也不奇怪. `持续`和`打破`表现出类似的行为`返回`和`扔`: 

```js
for (var i=0; i<10; i++) {
	try {
		continue;
	}
	finally {
		console.log( i );
	}
}
// 0 1 2 3 4 5 6 7 8 9
```

这个`控制台(日志)`语句在循环迭代的结束处运行,这是由`持续`声明. 然而,它仍然运行之前`我+ +`迭代更新语句,这就是打印值的原因. `0的9. `而不是`1的10. `. 

**注: **6添加`产量`语句,在生成器中(参见_异步和性能_这个系列的标题)在某种程度上可以看作是中间的`返回`声明. 然而,不像`返回`,一个`产量`直到发电机恢复,才能完成,这意味着`尝试{ ..产量. }`尚未完成. 所以,一个附加的`最后`子句将不在其后运行. `产量`和它一样`返回`. 

一`返回`在一个`最后`具有重写前一项的特殊能力. `返回`从`尝试`或`抓住`子句,但仅当`返回`显式调用: 

```js
function foo() {
	try {
		return 42;
	}
	finally {
		// no `return ..` here, so no override
	}
}

function bar() {
	try {
		return 42;
	}
	finally {
		// override previous `return 42`
		return;
	}
}

function baz() {
	try {
		return 42;
	}
	finally {
		// override previous `return 42`
		return "Hello";
	}
}

foo();	// 42
bar();	// undefined
baz();	// "Hello"
```

通常,省略`返回`在函数中是一样的`返回;`甚至`返回未定义;`但在里面`最后`阻止遗漏`返回`不象一个压倒一切的人`返回未定义`它只是让以前的`返回`站. 

事实上,如果我们联合起来,我们真的可以疯狂起来. `最后`标记`打破`(本章前面讨论): 

```js
function foo() {
	bar: {
		try {
			return 42;
		}
		finally {
			// break out of `bar` labeled block
			break bar;
		}
	}

	console.log( "Crazy" );

	return "Hello";
}

console.log( foo() );
// Crazy
// Hello
```

但ⅆ不要这样做. 严重. 使用`最后`+标记`打破`有效取消`返回`尽最大努力创建最混乱的代码. 我敢打赌,没有多少评论能挽回这段代码. 

## `转换`

让我们简单地探究一下`转换`语句,是一种用于`如果ⅆ如果ⅆ`声明链. 

```js
switch (a) {
	case 2:
		// do something
		break;
	case 42:
		// do another thing
		break;
	default:
		// fallback to here
}
```

如你所见,它评估`一`然后,将结果值与每个值匹配. `案例`表达式(只是这里的简单值表达式). 如果找到匹配,执行将在匹配中开始. `案例`,要么一直走到A`打破`遇到或直到结束`转换`找到块. 

你也许不会感到惊讶,但有几个怪癖. `转换`你可能以前没注意过. 

首先,匹配发生在`一`表达每一`案例`表达式与`= = =`算法(见第4章). 经常的`转换`ES与绝对值一起使用. `案例`如上所述,所以严格的匹配是适当的. 

然而,您可能希望允许强制相等(又名`= =`,见第4章),这样做,你需要排序"黑客"的`转换`有点说法: 

```js
var a = "42";

switch (true) {
	case a == 10:
		console.log( "10 or '10'" );
		break;
	case a == 42:
		console.log( "42 or '42'" );
		break;
	default:
		// never gets here
}
// 42 or '42'
```

This works because the`案例`子句可以有任何表达式(不仅仅是简单值),这意味着它将严格匹配表达式的结果到测试表达式中. `真正的`). 自`a=42`结果`真正的`在这里,火柴是做的. 

尽管`= =`,的`转换`匹配本身仍然很严格,在`真正的`和`真正的`在这里.如果`案例`表达导致的东西是一些但不严格`真正的`(见第4章)行不通. 如果你使用一个"逻辑操作符",它会咬你. `Ɯ Ɯ`或`&`在你的表情里: 

```js
var a = "hello world";
var b = 10;

switch (true) {
	case (a ƜƜ b == 10):
		// never gets here
		break;
	default:
		console.log( "Oops" );
}
// Oops
```

由于`(一Ɯ Ɯ B = = 10)`是`"你好,世界"`而不是`真正的`严格匹配失败. 在这种情况下,修复方法是强制表达式显式为`真正的`或`假`,如`案例!!(一Ɯ Ɯ B = = 10): `(见第4章). 

最后,该`违约`子句是可选的,它不一定要到最后(尽管这是强约定). 即使在`违约`子句,同样的规则适用于遇到`打破`或不: 

```js
var a = 10;

switch (a) {
	case 1:
	case 2:
		// never gets here
	default:
		console.log( "default" );
	case 3:
		console.log( "3" );
		break;
	case 4:
		console.log( "4" );
}
// default
// 3
```

**注: **如前所述关于标记`打破`S的`打破`在一个`案例`子句也可以标记. 

此代码段处理的方式是它通过所有`案例`子句匹配第一,找不到匹配,然后返回到`违约`clause and starts executing. 既然没有`打破`在那里,它继续在已经跳过的地方执行. `案例3`块,在停止之前,它击中`打破`. 

虽然这种逻辑在JavaScript中显然是可能的,但它几乎不可能产生合理或可理解的代码. 如果你发现自己想要创建这样的循环逻辑流,你要非常怀疑,如果你真的这样做,一定要包含大量的代码注释来解释你要做什么!

## 回顾

JavaScript语法有很多细微之处,我们作为开发人员应该花比我们通常更关注的时间. 一点点努力对巩固你更深层次的语言知识有很大的帮助. 

语句和表达式在英语中有类似物ℴℴ语句就像句子一样,表达式就像短语. 表达式可以是纯的/自包含的,或者它们可能有副作用. 

JavaScript语法在纯语法之上分层语义使用规则(又名上下文). 例如,`{ }`在程序中不同位置使用的对可以表示语句块,`对象`文字,(6)解构的任务,或(6)命名的功能观点

JavaScript的经营者都有明确的规则(哪些优先绑定之前,其他)和相关性(多个运算符表达式是隐式分组). 一旦你学会了这些规则,它是由你来决定是否优先/关联性_太含蓄_为了他们自己的好,或者如果他们能帮助编写更短,更清晰的代码. 

ASI(自动分号插入)是一种内置于js引擎中的解析器错误纠正机制,它允许在某些情况下插入一个假设. `;`在需要的地方,省略了,_和_其中插入修复解析器错误. 在激烈的辩论,这种行为是否意味着最`;`是可选的(可以省略为更干净的代码),或者是否意味着省略它们会使JS引擎仅仅为您清理错误. 

JavaScript有几种类型的错误,但它不知道它有错误的两种分类: "早"(编译器抛出,钓不到的)和"运行时"(`试试. 赶上`able). 所有语法错误都是明显的早期错误,在运行前停止程序,但也有其他错误. 

函数参数与它们正式声明的命名参数有一个有趣的关系. 具体而言,该`争论`阵列有一批漏的抽象行为的陷阱如果你不小心. 避免`争论`如果可以的话,但是如果你必须使用它,一定要避免使用位置槽. `争论`同时使用同一参数的命名参数. 

这个`最后`附加条款`尝试`(或`试试. 赶上`)在执行处理顺序方面提供了一些非常有趣的怪癖. 其中一些怪癖可能是有用的,但可能会造成许多混乱,特别是如果与标记块相结合的话. 一如既往,使用`最后`使代码更清楚ㄡ更清晰,而不是更聪明或更混乱. 

这个`转换`提供一些很好的速记`如果ⅆ如果ⅆ`语句,但要小心对其行为的许多常见的简化假设. 如果你不小心的话,有几个怪癖会让你绊倒,但也有一些巧妙的隐藏伎俩. `转换`有袖子了!
