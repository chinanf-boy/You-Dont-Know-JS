
# 你不知道JS：类型和语法

# 第1章：类型

大多数开发人员会说动态语言（如js）没有。_类型_。让我们看看es5.1规范（<http://www.ecma-international.org/ecma-262/5.1/>）不得不谈这个话题：

> 此规范中的算法操作值，每个值都有关联类型。可能的值类型正好是本子句中定义的值类型。类型进一步分为ECMAScript语言类型和规格型号。
>
> ECMAScript语言类型对应，利用脚本语言ECMAScript程序直接操作的值。ECMAScript语言类型是不确定的，空的，布尔，字符串，数字，和对象。

现在，如果您是强类型（静态类型）语言的爱好者，您可能会反对使用“类型”这个词，在这些语言中，“类型”表示一大堆。_更多_比它在JS里做的要多。

有些人说js不应该自称有“类型”，而应该称为“标签”或“子类型”。

呸！我们将使用这个粗略的定义（与规范的措辞相同的定义）：a_类型_是一个固有的、内置的特性集，它唯一地标识一个特定值的行为，并将其与其他值区别开来，这两个属性都是引擎。**and to the developer**。

换句话说，如果引擎和开发人员都重视价值。`四十二`（数字）与他们对待价值不同。`“42”`（字符串），然后这两个值有不同_类型_——`数`和`一串`，分别。当你使用`四十二`，你是_未来_做数学之类的数字。但当你使用`“42”`，你是_未来_做string'ish，像输出到页面，等等。**这两个值有不同的类型。**

这决不是一个完美的定义。但这对讨论来说已经足够了。它与JS描述自己的方式是一致的。

# 任何其他名称的类型…

除了学术定义上的分歧，为什么JavaScript也有关系呢？_类型_或不？

对每个问题有正确的理解_类型_它的内在行为对于理解如何正确和准确地将值转换为不同类型是绝对必要的（参见第4章）。几乎所有编写过的JS程序都需要以某种形式或形式处理值强制，所以重要的是你要有责任感和信心。

如果你有`数`价值`四十二`但你想把它当成一个`一串`如拔出`“2”`作为位置上的人物`一`显然，你必须首先转换（强制）这个值。`数`到`一串`。

这似乎够简单了。

但是这种胁迫有很多不同的方式发生。其中一些方法是明确的，易于推理，而且可靠。但是如果你不小心，胁迫会以非常奇怪和令人惊讶的方式发生。

强迫混淆可能是JavaScript开发人员最深刻的挫折之一。它经常被批评为是这样的。_危险的_被认为是语言设计中的一个缺陷，被回避和避免。

通过对JavaScript类型的全面了解，我们的目的是说明为什么强制的_坏名声_主要是言过其实的，有点名不副实，翻转你的视角，看到胁迫的能力和有效性。但首先，我们必须更好地把握价值观和类型。

## 内置类型

JavaScript定义了七种内置类型：

-   `无效的`
-   `未定义`
-   `布尔`
-   `数`
-   `一串`
-   `对象`
-   `符号`——增加了6！

**注：**所有这些类型除外`对象`被称为“原语”。

这个`类型`操作员检查类型的给定值，并始终返回七个字符串值，令人惊讶的是，没有一个与七个内置类型，我们刚刚上市的确切的1对1的比赛。

```js
typeof undefined     === "undefined"; // true
typeof true          === "boolean";   // true
typeof 42            === "number";    // true
typeof "42"          === "string";    // true
typeof { life: 42 }  === "object";    // true

// added in ES6!
typeof Symbol()      === "symbol";    // true
```

这六个列出的类型具有相应类型的值，并返回一个同名的字符串值，如下所示。`符号`是一种新的数据类型为6，将覆盖在3章。

正如你可能注意到的，我排除了`无效的`从上面的清单。它是_特殊的_-特别的，当它与组合在一起时是不安全的。`类型`算子：

```js
typeof null === "object"; // true
```

那会很好（而且正确！）如果它回来了`“空”`但是，js中原有的bug已经持续了将近20年，而且很可能永远不会被修复，因为现有的Web内容太多，依赖于它的bug行为，即“修复”bug。_创造_更多的“臭虫”，打破了大量的网络软件。

如果你想测试一个`无效的`使用类型的值，您需要一个复合条件：

```js
var a = null;

(!a && typeof a === "object"); // true
```

`无效的`是唯一的原始价值，是“falsy”（又名假像；见4章）但这也返回`“对象”`从`类型`检查。

那么，第七个字符串值是什么？`类型`能回来吗？

```js
typeof function a(){ /* .. */ } === "function"; // true
```

很容易认为`功能`将是js中的顶级内置类型，特别是考虑到`类型`算子。但是，如果您阅读了规范，您会看到它实际上是对象的“子类型”。具体来说，函数是REF。`[ [调用] ]`允许调用它的属性。

函数实际上是对象这一事实非常有用。最重要的是，它们可以拥有属性。例如:

```js
function a(b,c) {
	/* .. */
}
```

函数对象有一个`长度`属性设置为它声明的形参的个数。

```js
a.length; // 2
```

因为您已经用两个正式命名参数声明了这个函数（`B`和`C`“函数的长度”是`二`。

数组呢？它们是js的原材料，它们是特殊类型的吗？

```js
typeof [1,2,3] === "object"; // true
```

不，只是对象。把它们看作对象的“子类型”（参见第3章）也是最合适的，在这种情况下，附加数字索引的特性（而不是仅仅像普通对象那样键入字符串）并保持自动更新。`。长度`财产。

## 值类型

在JavaScript中，变量没有类型——**值类型**。变量可以随时保存任何值。

另一种考虑JS类型的方法是js没有“强制类型”，因为引擎不坚持A类型。_变量_总是持有的值_相同的初始型_它开始于。一个赋值语句中的变量可以保持一个`一串`在下一个舱里`数`等等。

这个_价值_四十二`有一种内在的类型`数`，和其`类型_cannot be changed. 另一个值，比如_“42”`与`一串`类型，可以创建`从_这个_数`价值`四十二`通过一个被调用的过程`强制**（见第4章）。**如果你使用

类型`对于变量，它不是问“变量的类型是什么？”似乎是因为js变量没有类型。相反，它在问“值的类型是什么？”`在里面_变量？”_这个

```js
var a = 42;
typeof a; // "number"

a = true;
typeof a; // "boolean"
```

类型`运算符总是返回字符串。所以：`第一

```js
typeof typeof 42; // "string"
```

typeof 42`返回`“数”`，和`类型的“数”`是`“字符串”`。`未定义

### `“未申报”`没有价值的变量

目前_，实际上有_未定义`价值。打电话`类型`对这些变量将返回`“未定义”`：`大多数开发人员都会想到“未定义”这个词，并认为它是“未声明的”的同义词，然而，在JS中，这两个概念是完全不同的。

```js
var a;

typeof a; // "undefined"

var b = 42;
var c;

// later
b = c;

typeof b; // "undefined"
typeof c; // "undefined"
```

“未定义”变量是在可访问范围内声明的变量，但

在那一刻_没有其他价值。相比之下，未声明的变量是未在可访问范围内正式声明的变量。_考虑：

一个恼人的混乱是浏览器分配给这个条件的错误消息。正如你所看到的，信息是“B未定义”，这当然是很容易和合理的混淆与“B是未定义的”，但是，“未定义”和“未定义”是非常不同的东西。如果浏览器说“B没有找到”或“B未声明”之类的话，那会很好的，这样可以减少混淆！

```js
var a;

a; // undefined
b; // ReferenceError: b is not defined
```

还有一种特殊的行为。

类型`因为它涉及到未声明的变量，甚至进一步加强了混淆。考虑：`这个

```js
var a;

typeof a; // "undefined"

typeof b; // "undefined"
```

类型`操作符返回`“未定义”`即使是“未声明的”（或未定义的）变量。注意，我们执行时没有抛出错误。`类型B`，即使`B`是未声明的变量。这是一种特殊的安全防范措施。`类型`。`和上面一样，如果

类型`使用未声明的变量返回“秘而不宣”而不是将结果值与不同的“定义”案。`类型

### `未申报`然而，在浏览器中处理JavaScript时，这种安全保护是一个有用的特性，其中多个脚本文件可以将变量加载到共享全局命名空间中。

注：

**许多开发人员认为在全局命名空间中不应该有任何变量，并且所有的内容都应该包含在模块和私有/单独的命名空间中。这在理论上是伟大的，但在实践中几乎是不可能的，仍然是一个很好的奋斗目标！幸运的是，6添加模块一流的支持，这将最终使更加实用。**举个简单的例子，假设程序中有一个“调试模式”，由全局变量（标志）控制。

调试`。您需要检查在执行调试任务（如将消息记录到控制台）之前是否声明了该变量。一个顶级的全球`var调试=真`声明只包含在一个“调试js”文件中，在开发/测试时只加载到浏览器中，而不是在生产中。`但是，您必须注意如何检查全局。

调试`在应用程序代码的其余部分中变量，这样就不会抛出`引用错误`。安全卫士`类型`我们的朋友是这种情况吗？。`这种检查非常有用，即使您没有处理用户定义的变量（如

```js
// oops, this would throw an error!
if (DEBUG) {
	console.log( "Debugging is starting" );
}

// this is a safe existence check
if (typeof DEBUG !== "undefined") {
	console.log( "Debugging is starting" );
}
```

调试`）。如果您正在对内置API进行功能检查，您可能会发现在不抛出错误的情况下进行检查是有帮助的：`注：

```js
if (typeof atob === "undefined") {
	atob = function() { /*..*/ };
}
```

**如果你定义一个“polyfill”的特征，如果它不存在，你可能想避免使用**VaR`为了使`爱特伯`宣言.如果你声明`VaR爱特伯`VaR爱特伯`里面的`如果`声明，此声明已悬挂（见_范围和关闭_这个系列的标题）到范围的顶部，即使`如果`情况不会过去（因为全球`爱特伯`已经存在！）在一些浏览器和一些特殊类型的全局内置变量（通常称为“宿主对象”）中，这个重复声明可能会抛出一个错误。省略`VaR`防止悬挂声明。

对全局变量进行这些检查的另一种方法，但不具有`类型`是观察所有全局变量也是全局对象的属性，这在浏览器中基本上是`窗口`对象。因此，上述检查可能已经（相当安全地）完成了：

```js
if (window.DEBUG) {
	// ..
}

if (!window.atob) {
	// ..
}
```

与引用未声明变量不同，没有`引用错误`如果您试图访问对象属性（甚至在全局上），则抛出。`窗口`对象）不存在。

另一方面，手动用一个全局变量引用全局变量`窗口`参考一些开发商宁愿避免，尤其是如果你的代码需要运行在多个js环境（不只是浏览器，而服务器端的js，例如），在全局对象可能并不总是被称为`窗口`。

从技术上讲，这个安全卫士`类型`即使您没有使用全局变量也是有用的，尽管这些情况并不常见，一些开发人员可能会发现这种设计方法不太理想。设想一个实用程序函数，您希望其他人复制并粘贴到它们的程序或模块中，在其中您希望检查包含的程序是否定义了某个变量（以便您可以使用它）：

```js
function doSomethingCool() {
	var helper =
		(typeof FeatureXYZ !== "undefined") ?
		FeatureXYZ :
		function() { /*.. default feature ..*/ };

	var val = helper();
	// ..
}
```

`dosomethingcool()`变量的测试`featurexyz`如果发现，使用它，但如果没有，使用它自己的。现在，如果某人在模块/程序中包含了这个实用程序，它就可以安全地检查它们是否已经定义了。`featurexyz`或不：

```js
// an IIFE (see "Immediately Invoked Function Expressions"
// discussion in the *Scope & Closures* title of this series)
(function(){
	function FeatureXYZ() { /*.. my XYZ feature ..*/ }

	// include `doSomethingCool(..)`
	function doSomethingCool() {
		var helper =
			(typeof FeatureXYZ !== "undefined") ?
			FeatureXYZ :
			function() { /*.. default feature ..*/ };

		var val = helper();
		// ..
	}

	doSomethingCool();
})();
```

在这里,`featurexyz`根本不是一个全局变量，但我们仍在使用`类型`为了安全检查。重要的是，这里有_不_我们可以使用的对象（就像我们为全局变量所做的那样`___窗口。`来做支票，所以`类型`很有帮助。

其他开发人员更喜欢一种称为“依赖注入”的设计模式，而不是`dosomethingcool()`检查隐式`featurexyz`要在外部/周围定义它，它需要显式地传递依赖项，比如：

```js
function doSomethingCool(FeatureXYZ) {
	var helper = FeatureXYZ ||
		function() { /*.. default feature ..*/ };

	var val = helper();
	// ..
}
```

在设计这样的功能时，有很多选择。这里没有一种模式是“正确的”或“错误的”——每个方法都有不同的权衡。但总的来说，这很好。`类型`未申报的安全警卫给我们更多的选择。

## 回顾

JavaScript有七个内置的_类型_：`无效的`，`未定义`，`布尔`，`数`，`一串`，`对象`，`符号`。它们可以由`类型`算子。

变量没有类型，但它们中的值是。这些类型定义了值的内在行为。

许多开发人员会假定“未定义”和“未声明”大致相同，但在JavaScript，它们是完全不同的。`未定义`是一个声明变量可以保存的值。“未声明”意味着从未声明过变量。

不幸的是，这种JavaScript混淆了这两种方面，不仅在其错误消息（“referenceerror：一个未定义”）也在返回值`类型`，这是`“未定义”`对于这两种情况。

但是，安全保护（防止错误）`类型`当对未声明变量使用时，在某些情况下可能会有所帮助。
