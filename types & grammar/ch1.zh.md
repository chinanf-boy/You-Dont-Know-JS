
# 你不知道JS: 类型和语法

# 第1章: 类型

大多数开发人员会说动态语言(如js)没有ㄢ_类型_ㄢ让我们看看es5.1规范(<http://www.ecma-international.org/ecma-262/5.1/>)不得不谈这个话题: 

> 此规范中的算法操作值,每个值都有关联类型ㄢ可能的值类型正好是本子句中定义的值类型ㄢ类型进一步分为ECMAScript语言类型和规格型号ㄢ
>
> ECMAScript语言类型对应,利用脚本语言ECMAScript程序直接操作的值ㄢECMAScript语言类型是不确定的,空的,布尔,字符串,数字,和对象ㄢ

现在,如果您是强类型(静态类型)语言的爱好者,您可能会反对使用"类型ℽ这个词,在这些语言中,"类型ℽ表示一大堆ㄢ_更多_比它在JS里做的要多ㄢ

有些人说js不应该自称有"类型ℽ,而应该称为"标签ℽ或"子类型ℽㄢ

呸!我们将使用这个粗略的定义(与规范的措辞相同的定义): a_类型_是一个固有的ㄡ内置的特性集,它唯一地标识一个特定值的行为,并将其与其他值区别开来,这两个属性都是引擎ㄢ**并向开发人员**ㄢ

换句话说,如果引擎和开发人员都重视价值ㄢ`四十二`(数字)与他们对待价值不同ㄢ`"42ℽ`(字符串),然后这两个值有不同_类型_ℴℴ`数`和`一串`,分别ㄢ当你使用`四十二`,你是_未来_做数学之类的数字ㄢ但当你使用`"42ℽ`,你是_未来_做string'ish,像输出到页面,等等ㄢ**这两个值有不同的类型ㄢ**

这决不是一个完美的定义ㄢ但这对讨论来说已经足够了ㄢ它与JS描述自己的方式是一致的ㄢ

# 任何其他名称的类型ⅆ

除了学术定义上的分歧,为什么JavaScript也有关系呢?_类型_或不?

对每个问题有正确的理解_类型_它的内在行为对于理解如何正确和准确地将值转换为不同类型是绝对必要的(参见第4章)ㄢ几乎所有编写过的JS程序都需要以某种形式或形式处理值强制,所以重要的是你要有责任感和信心ㄢ

如果你有`数`价值`四十二`但你想把它当成一个`一串`如拔出`"2ℽ`作为位置上的人物`一`显然,你必须首先转换(强制)这个值ㄢ`数`到`一串`ㄢ

这似乎够简单了ㄢ

但是这种胁迫有很多不同的方式发生ㄢ其中一些方法是明确的,易于推理,而且可靠ㄢ但是如果你不小心,胁迫会以非常奇怪和令人惊讶的方式发生ㄢ

强迫混淆可能是JavaScript开发人员最深刻的挫折之一ㄢ它经常被批评为是这样的ㄢ_危险的_被认为是语言设计中的一个缺陷,被回避和避免ㄢ

通过对JavaScript类型的全面了解,我们的目的是说明为什么强制的_坏名声_主要是言过其实的,有点名不副实,翻转你的视角,看到胁迫的能力和有效性ㄢ但首先,我们必须更好地把握价值观和类型ㄢ

## 内置类型

JavaScript定义了七种内置类型: 

-   `无效的`
-   `未定义`
-   `布尔`
-   `数`
-   `一串`
-   `对象`
-   `符号`ℴℴ增加了6!

**注: **所有这些类型除外`对象`被称为"原语ℽㄢ

这个`类型`操作员检查类型的给定值,并始终返回七个字符串值,令人惊讶的是,没有一个与七个内置类型,我们刚刚上市的确切的1对1的比赛ㄢ

```js
typeof undefined     === "undefined"; // true
typeof true          === "boolean";   // true
typeof 42            === "number";    // true
typeof "42"          === "string";    // true
typeof { life: 42 }  === "object";    // true

// added in ES6!
typeof Symbol()      === "symbol";    // true
```

这六个列出的类型具有相应类型的值,并返回一个同名的字符串值,如下所示ㄢ`符号`是一种新的数据类型为6,将覆盖在3章ㄢ

正如你可能注意到的,我排除了`无效的`从上面的清单ㄢ它是_特殊的_-特别的,当它与组合在一起时是不安全的ㄢ`类型`算子: 

```js
typeof null === "object"; // true
```

那会很好(而且正确!)如果它回来了`"空ℽ`但是,js中原有的bug已经持续了将近20年,而且很可能永远不会被修复,因为现有的Web内容太多,依赖于它的bug行为,即"修复ℽbugㄢ_创造_更多的"臭虫ℽ,打破了大量的网络软件ㄢ

如果你想测试一个`无效的`使用类型的值,您需要一个复合条件: 

```js
var a = null;

(!a && typeof a === "object"); // true
```

`无效的`是唯一的原始价值,是"falsyℽ(又名假像;见4章)但这也返回`"对象ℽ`从`类型`检查ㄢ

那么,第七个字符串值是什么?`类型`能回来吗?

```js
typeof function a(){ /* .. */ } === "function"; // true
```

很容易认为`功能`将是js中的顶级内置类型,特别是考虑到`类型`算子ㄢ但是,如果您阅读了规范,您会看到它实际上是对象的"子类型ℽㄢ具体来说,函数是REFㄢ`[ [调用] ]`允许调用它的属性ㄢ

函数实际上是对象这一事实非常有用ㄢ最重要的是,它们可以拥有属性ㄢ例如:

```js
function a(b,c) {
	/* .. */
}
```

函数对象有一个`长度`属性设置为它声明的形参的个数ㄢ

```js
a.length; // 2
```

因为您已经用两个正式命名参数声明了这个函数(`B`和`C`"函数的长度ℽ是`二`ㄢ

数组呢?它们是js的原材料,它们是特殊类型的吗?

```js
typeof [1,2,3] === "object"; // true
```

不,只是对象ㄢ把它们看作对象的"子类型ℽ(参见第3章)也是最合适的,在这种情况下,附加数字索引的特性(而不是仅仅像普通对象那样键入字符串)并保持自动更新ㄢ`ㄢ长度`财产ㄢ

## 值类型

在JavaScript中,变量没有类型ℴℴ**值类型**ㄢ变量可以随时保存任何值ㄢ

另一种考虑JS类型的方法是js没有"强制类型ℽ,因为引擎不坚持A类型ㄢ_变量_总是持有的值_相同的初始型_它开始于ㄢ一个赋值语句中的变量可以保持一个`一串`在下一个舱里`数`等等ㄢ

这个_价值_ `四十二`有一种内在的类型`数`,和其_类型_不能改变ㄢ另一个值,比如`"42ℽ`与`一串`类型,可以创建_从_这个`数`价值`四十二`通过一个被调用的过程**强制**(见第4章)ㄢ

如果你使用`类型`对于变量,它不是问"变量的类型是什么?ℽ似乎是因为js变量没有类型ㄢ相反,它在问"值的类型是什么?ℽ_在里面_变量?ℽ

```js
var a = 42;
typeof a; // "number"

a = true;
typeof a; // "boolean"
```

这个`类型`运算符总是返回字符串ㄢ所以: 

```js
typeof typeof 42; // "string"
```

第一`typeof 42`返回`"数ℽ`,和`类型的"数ℽ`是`"字符串ℽ`ㄢ

### `未定义`"未申报ℽ

没有价值的变量_目前_,实际上有`未定义`价值ㄢ打电话`类型`对这些变量将返回`"未定义ℽ`: 

```js
var a;

typeof a; // "undefined"

var b = 42;
var c;

// later
b = c;

typeof b; // "undefined"
typeof c; // "undefined"
```

大多数开发人员都会想到"未定义ℽ这个词,并认为它是"未声明的ℽ的同义词,然而,在JS中,这两个概念是完全不同的ㄢ

"未定义ℽ变量是在可访问范围内声明的变量,但_在那一刻_没有其他价值ㄢ相比之下,未声明的变量是未在可访问范围内正式声明的变量ㄢ

考虑: 

```js
var a;

a; // undefined
b; // ReferenceError: b is not defined
```

一个恼人的混乱是浏览器分配给这个条件的错误消息ㄢ正如你所看到的,信息是"B未定义ℽ,这当然是很容易和合理的混淆与"B是未定义的ℽ,但是,"未定义ℽ和"未定义ℽ是非常不同的东西ㄢ如果浏览器说"B没有找到ℽ或"B未声明ℽ之类的话,那会很好的,这样可以减少混淆!

还有一种特殊的行为ㄢ`类型`因为它涉及到未声明的变量,甚至进一步加强了混淆ㄢ考虑: 

```js
var a;

typeof a; // "undefined"

typeof b; // "undefined"
```

这个`类型`操作符返回`"未定义ℽ`即使是"未声明的ℽ(或未定义的)变量ㄢ注意,我们执行时没有抛出错误ㄢ`类型B`,即使`B`是未声明的变量ㄢ这是一种特殊的安全防范措施ㄢ`类型`ㄢ

和上面一样,如果`类型`使用未声明的变量返回"秘而不宣ℽ而不是将结果值与不同的"定义ℽ案ㄢ

### `类型`未申报

然而,在浏览器中处理JavaScript时,这种安全保护是一个有用的特性,其中多个脚本文件可以将变量加载到共享全局命名空间中ㄢ

**注: **许多开发人员认为在全局命名空间中不应该有任何变量,并且所有的内容都应该包含在模块和私有/单独的命名空间中ㄢ这在理论上是伟大的,但在实践中几乎是不可能的,仍然是一个很好的奋斗目标!幸运的是,6添加模块一流的支持,这将最终使更加实用ㄢ

举个简单的例子,假设程序中有一个"调试模式ℽ,由全局变量(标志)控制ㄢ`调试`ㄢ您需要检查在执行调试任务(如将消息记录到控制台)之前是否声明了该变量ㄢ一个顶级的全球`var调试=真`声明只包含在一个"调试jsℽ文件中,在开发/测试时只加载到浏览器中,而不是在生产中ㄢ

但是,您必须注意如何检查全局ㄢ`调试`在应用程序代码的其余部分中变量,这样就不会抛出`引用错误`ㄢ安全卫士`类型`我们的朋友是这种情况吗?ㄢ

```js
// oops, this would throw an error!
if (DEBUG) {
	console.log( "Debugging is starting" );
}

// this is a safe existence check
if (typeof DEBUG !== "undefined") {
	console.log( "Debugging is starting" );
}
```

这种检查非常有用,即使您没有处理用户定义的变量(如`调试`)ㄢ如果您正在对内置API进行功能检查,您可能会发现在不抛出错误的情况下进行检查是有帮助的: 

```js
if (typeof atob === "undefined") {
	atob = function() { /*..*/ };
}
```

**注: **如果你定义一个"polyfillℽ的特征,如果它不存在,你可能想避免使用`VaR`为了使`爱特伯`宣言.如果你声明`VaR爱特伯`在里面`如果`声明,此声明已悬挂(见_范围和关闭_这个系列的标题)到范围的顶部,即使`如果`情况不会过去(因为全球`爱特伯`已经存在!)在一些浏览器和一些特殊类型的全局内置变量(通常称为"宿主对象ℽ)中,这个重复声明可能会抛出一个错误ㄢ省略`VaR`防止悬挂声明ㄢ

对全局变量进行这些检查的另一种方法,但不具有`类型`是观察所有全局变量也是全局对象的属性,这在浏览器中基本上是`窗口`对象ㄢ因此,上述检查可能已经(相当安全地)完成了: 

```js
if (window.DEBUG) {
	// ..
}

if (!window.atob) {
	// ..
}
```

与引用未声明变量不同,没有`引用错误`如果您试图访问对象属性(甚至在全局上),则抛出ㄢ`窗口`对象)不存在ㄢ

另一方面,手动用一个全局变量引用全局变量`窗口`参考一些开发商宁愿避免,尤其是如果你的代码需要运行在多个js环境(不只是浏览器,而服务器端的js,例如),在全局对象可能并不总是被称为`窗口`ㄢ

从技术上讲,这个安全卫士`类型`即使您没有使用全局变量也是有用的,尽管这些情况并不常见,一些开发人员可能会发现这种设计方法不太理想ㄢ设想一个实用程序函数,您希望其他人复制并粘贴到它们的程序或模块中,在其中您希望检查包含的程序是否定义了某个变量(以便您可以使用它): 

```js
function doSomethingCool() {
	var helper =
		(typeof FeatureXYZ !== "undefined") ?
		FeatureXYZ :
		function() { /*.. default feature ..*/ };

	var val = helper();
	// ..
}
```

`dosomethingcool()`变量的测试`featurexyz`如果发现,使用它,但如果没有,使用它自己的ㄢ现在,如果某人在模块/程序中包含了这个实用程序,它就可以安全地检查它们是否已经定义了ㄢ`featurexyz`或不: 

```js
// an IIFE (see "Immediately Invoked Function Expressions"
// discussion in the *Scope & Closures* title of this series)
(function(){
	function FeatureXYZ() { /*.. my XYZ feature ..*/ }

	// include `doSomethingCool(..)`
	function doSomethingCool() {
		var helper =
			(typeof FeatureXYZ !== "undefined") ?
			FeatureXYZ :
			function() { /*.. default feature ..*/ };

		var val = helper();
		// ..
	}

	doSomethingCool();
})();
```

在这里,`featurexyz`根本不是一个全局变量,但我们仍在使用`类型`为了安全检查ㄢ重要的是,这里有_不_我们可以使用的对象(就像我们为全局变量所做的那样`___窗口ㄢ`来做支票,所以`类型`很有帮助ㄢ

其他开发人员更喜欢一种称为"依赖注入ℽ的设计模式,而不是`dosomethingcool()`检查隐式`featurexyz`要在外部/周围定义它,它需要显式地传递依赖项,比如: 

```js
function doSomethingCool(FeatureXYZ) {
	var helper = FeatureXYZ ƜƜ
		function() { /*.. default feature ..*/ };

	var val = helper();
	// ..
}
```

在设计这样的功能时,有很多选择ㄢ这里没有一种模式是"正确的ℽ或"错误的ℽℴℴ每个方法都有不同的权衡ㄢ但总的来说,这很好ㄢ`类型`未申报的安全警卫给我们更多的选择ㄢ

## 回顾

JavaScript有七个内置的_类型_: `无效的`,`未定义`,`布尔`,`数`,`一串`,`对象`,`符号`ㄢ它们可以由`类型`算子ㄢ

变量没有类型,但它们中的值是ㄢ这些类型定义了值的内在行为ㄢ

许多开发人员会假定"未定义ℽ和"未声明ℽ大致相同,但在JavaScript,它们是完全不同的ㄢ`未定义`是一个声明变量可以保存的值ㄢ"未声明ℽ意味着从未声明过变量ㄢ

不幸的是,这种JavaScript混淆了这两种方面,不仅在其错误消息("referenceerror: 一个未定义ℽ)也在返回值`类型`,这是`"未定义ℽ`对于这两种情况ㄢ

但是,安全保护(防止错误)`类型`当对未声明变量使用时,在某些情况下可能会有所帮助ㄢ
