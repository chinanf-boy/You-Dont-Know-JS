
# 你不知道JS：异步性能

# 第6章基准测试与调优

由于本书的前四章都是关于性能的编码模式（异步和并发），第5章是关于宏程序体系结构级别的性能，本章在微观层面上关注性能的主题，重点是单个表达式/语句。

其中一个最常见的好奇心领域——事实上，一些开发人员可能对此非常着迷——正在分析和测试如何编写一行或一组代码的各种选项，哪一个更快。

我们将研究其中的一些问题，但从一开始就明白这一章是重要的。**不**关于喂养微性能调优的困扰，比如某些给定的JS引擎是否可以运行`+ +`速度比`+ +`。这一章更重要的目标是弄清楚哪些JS性能重要，哪些不好，_以及如何辨别差异_。

但是，在我们到达那里之前，我们需要探索如何最准确和可靠地测试JS性能，因为大量的误解和神话充斥了我们的集体邪教知识库。我们得仔细检查那些垃圾，才能找到清晰的地方。

## 标杆管理

好了，开始消除一些误解吧。我敢打赌，绝大多数js开发人员，如果被要求对某一操作的速度（执行时间）进行基准测试，最初会这样做：

```js
var start = (new Date()).getTime();	// or `Date.now()`

// do some operation

var end = (new Date()).getTime();

console.log( "Duration:", (end - start) );
```

举起你的手，如果那大概是你想到的。是的，我想是这样。这种方法有很多错误，但不要觉得不好；**我们都去过那里。**

那个测量准确地告诉了你什么？了解它所做的和不说操作的执行时间是学习如何在JavaScript中适当地测试性能的关键。

如果报告的持续时间是`零`你可能会相信它花了不到一毫秒的时间。但这不是很准确。有些平台没有单毫秒精度，但只更新计时器的增量较大。例如，旧版本的Windows（因此IE）只有15ms精度，这意味着操作至少需要那么长的时间比其他任何东西`零`被报道！

此外，无论报告的持续时间如何，您唯一知道的是，操作在大约一次运行时花费了大约那么长的时间。你几乎没有信心，它总是以那个速度运行。你不知道发动机或系统是否在某一时刻有某种干扰，而在其他情况下，运行速度可能更快。

如果报告的持续时间是`四`？你更确定这花了大约四毫秒吗？不.可能花的时间少了，可能还有其他的延误。`开始`或`结束`时间戳。

更令人担忧的是，你也不知道的情况下，这一操作试验不过于乐观。js引擎可能会找到一种方法来优化你的隔离测试用例，但是在一个更真实的程序中，这样的优化将被稀释或者不可能，这样操作就比你的测试运行得慢。

所以…我们知道什么？不幸的是，随着这些实现的陈述，**我们知道的很少。**一些如此低的自信甚至远远不够建立你的决心。你的“基准”基本上是没用的。更糟糕的是，这是危险的，因为它意味着虚假的信心，不仅对你，而且对那些不认真考虑导致这些结果的条件的人。

### 重复

“好吧，”你说，“把它周围的环，整个测试需要更长的时间。”如果你重复操作100次，和整个环据说总共需要137ms，然后你可以除以100得到1.37ms平均持续时间为每个操作，对吗？

嗯，不完全是。

一个直接的数学平均值本身就不足以做出你打算外推到整个应用程序宽度的性能判断。一百次，甚至一对夫妇的异常（高或低）可使平均，然后当你运用这些结论反复，你甚至进一步抬高，斜不轻信。

与其只运行固定数量的迭代，您可以选择运行测试循环，直到某个时间段已经过去。这可能更可靠，但你如何决定要运行多久呢？您可能猜到它应该是运行一次需要多长时间的倍数。错误。

实际上，重复的时间长度应该基于你所使用的计时器的准确度，特别是尽量减少不准确的机会。你的计时器越不精确，你就需要越长时间运行以确保最小化错误率。为15ms定时器是非常糟糕的，准确的基准；以减少其不确定性（又名“误差率”）小于1%，你需要

但是，那只是一个样本。为了确保你在计算偏差，你需要大量的样本来平均。你还想了解一下最差的样品有多慢，最好的样品有多快，最好的和最差的样品相隔多远等等。你要知道，不只是一个数字，告诉你如何快速的东西跑，但也有一些是值得信赖的，可量化的措施。

此外，您可能希望将这些不同的技术（以及其他技术）结合起来，以便在所有可能的方法中得到最佳平衡。

这只是最低限度的开始。如果你已经接近性能基准的东西那么严重比我只是一笔带过，嗯…”你不知道：适当的标杆管理。”

### benchmark.js

任何相关和可靠的基准都应以统计良好的做法为基础。我不打算写一章统计这里，所以我会挥手围绕一些术语：标准差，方差，误差范围。如果你不知道这些术语的真正含义——我在大学里上过统计学课，我对它们还有些模糊——你实际上没有资格编写你自己的基准逻辑。

幸运的是，像John David Dalton和Mathias Bynens聪明的人理解这些概念，并写了一个叫Benchmark.js（统计学上合理的基准测试工具<http://benchmarkjs.com/>）。所以我可以简单地说：“只要用那个工具就可以结束悬念。”

我不会为Benchmark.js的作品重复整个文件；他们有很棒的API文档（<http://benchmarkjs.com/docs>）你应该读。也有一些伟大的（<http://calendar.perfplanet.com/2010/bulletproof-javascript-benchmarks/>）writeups（<http://monsur.hossa.in/2012/12/11/benchmarkjs.html>关于更多的细节和方法。

只是快速演示的目的，这里是你如何可以使用benchmark.js运行一个快速的性能测试：

```js
function foo() {
	// operation(s) to test
}

var bench = new Benchmark(
	"foo test",				// test name
	foo,					// function to test (just contents)
	{
		// ..				// optional extra options (see docs)
	}
);

bench.hz;					// number of operations per second
bench.stats.moe;			// margin of error
bench.stats.variance;		// variance across samples
// ..
```

有_太多了_想要了解更多的使用benchmark.js除了这一瞥，包括我在这里。但关键是它处理了为给定的JavaScript代码设置一个公平、可靠和有效的性能基准的所有复杂性。如果您打算测试和基准代码，那么这个库是您应该首先打开的地方。

我们在这里展示的使用测试单个操作像X，但它是相当普遍的，你想要比较X到Y的这是很容易通过简单的设置了两种不同的方法在“套房”（一benchmark.js组织特征）。然后，你把它们从头到脚运行，并比较统计数据来判断x或y是否更快。

benchmark.js当然可以用于测试浏览器JavaScript（见“jsperf .com”部分，在本章的后面），但它也可以运行在非浏览器环境（Node.js，等）。

一个尚未开发的潜在用途的情况下，Benchmark.js是使用它在您的开发或测试环境中运行性能自动回归测试对你的应用程序中的JavaScript关键路径部分。类似于在部署之前如何运行单元测试套件，您还可以将性能与以前的基准进行比较，以监视您是否改进或降低了应用程序性能。

#### 安装/拆卸

在前面的代码段，我们掩饰了“附加选项”`{ ..}`对象。但有两种选择我们应该讨论：`设置`和`拆卸`。

这两个选项让您定义在测试用例运行之前和之后调用的函数。

了解你的情况是非常重要的。`设置`和`拆卸`代码**不为每个测试迭代运行**。考虑它的最好方法是有一个外循环（重复循环）和一个内部循环（重复测试迭代）。`设置`和`拆卸`在每一个开始和结束时运行。_外面的_循环（又名循环）迭代，但不在内部循环中。

这为什么重要？让我们假设您有一个测试用例，看起来如下所示：

```js
a = a + "w";
b = a.charAt( 1 );
```

然后，设置测试`设置`如下：

```js
var a = "x";
```

你的诱惑可能是相信`一`开始是`“X”`对于每个测试迭代。

但不是！它的起点`一`在`“X”`对于每一个测试周期，然后重复`+“W”`融合将是一个大的`一`值，即使您只访问该字符。`“W”`在`一`位置。

当您将副作用更改为DOM之类的内容时，最常见的情况是添加子元素。您可能认为您的父元素每次都被设置为空，但实际上它添加了很多元素，这将显著影响测试的结果。

## 背景是金

不要忘记检查特定性能基准的上下文，特别是x和y任务之间的比较。因为你的测试表明x比y快，并不意味着结论“x比y快”实际上是相关的。

例如，假设性能测试显示x每秒钟运行10000000次操作。

让我们更仔细地考虑结果：每秒10000000次操作是每毫秒10000次操作，每微秒10次运算。换句话说，一个单一的操作需要0.1微秒，或100纳秒。很难理解100ns是多么小，但相比之下，这是经常提到的，人类的眼睛并不是一般能够识别任何小于100ms，这比X操作100ns的速度慢一百万倍。

即使是最近的科学研究显示，也许大脑可以处理为13ms快速（约8倍的速度比以前的断言）意味着x仍在运行的125000倍，人的大脑可以感知到一个不同的事情发生得更快。**X真的，真的很快。**

但更重要的是，让我们来讨论x和y之间的差异，2000000次运算的差异。如果X和Y是以100ns，80ns，区别是20ns，在最好的情况下，仍然是一个650第一千的区间，人的大脑可以感知。

我的观点是什么？**所有这些性能差异都不重要！**

但是，等一下，如果这个操作会连续发生好几次呢？那么差异就可以相加，对吧？

好吧，那么我们要问的是，X操作的可能性有多大，一次又一次地跑，一个接一个地跑，而这只需要650000次，只是为了获得一点希望，人类的大脑能够感知它。更可能的是，它必须在一个紧密的循环中发生5000000到10000000次，甚至达到相关性。

虽然你的计算机科学家可能会抗议这是可能的，但现实主义中更响亮的声音应该理智地检查，这究竟有多大的可能性或可能性。即使在罕见的情况下它是相关的，在大多数情况下也不相关。

绝大多数基准测试都是在微小的操作上完成的，比如`+ X`VS`X + +`神话——**完全是假的**为了支持x在性能基础上优于y的结论。

### 引擎优化

如果X在你的孤立测试中比Y快10微秒，你就不能可靠地推断出，这意味着X总是比Y快，应该永远使用。表演不是这样的。这要复杂得多。

例如，让我们想象（纯属假设），你测试的一些microperformance等行为比较：

```js
var twelve = "12";
var foo = "foo";

// test 1
var X1 = parseInt( twelve );
var X2 = parseInt( foo );

// test 2
var Y1 = Number( twelve );
var Y2 = Number( foo );
```

如果你明白什么`parseInt（..）`做比较`数字（..）`你可以想象，`parseInt（..）`可能有更多的工作要做，特别是`Foo`案例。或者你可能凭直觉认为他们应该要做的工作在相同的金额`Foo`情况，因为两个都应该能够停在第一个字符。`“F”`。

哪个直觉是正确的？我真的不知道。但我会证明，你的直觉是什么并不重要。测试结果可能是什么？再一次，我在这里做一个纯粹的假设，我没有尝试过，我也不关心。

让我们假装测试回来了`X`和`Y`统计上完全相同。你有没有证实你的直觉？`“F”`性格的事吗？不.

在我们的假设中，引擎可能会识别变量。`十二`和`Foo`只在每个测试中使用一个地方，因此它可能决定内联这些值。然后它可能会意识到`编号（“12”）`可以被替换`十二`。也许会得出同样的结论。`parseInt（..）`也许不是。

或者一个引擎的死代码去除启发式可以介入，它可以实现变量。`X`和`Y`没有被使用，所以声明它们是不相关的，所以在任何一个测试中都不会做任何事情。

所有这些都是基于对一个测试运行的假设的想法。现代发动机非常复杂得多，我们的直觉在这里。他们会做各种各样的技巧，比如跟踪和跟踪一段代码在很短的时间内是如何运行的，或者是使用一组特别受限的输入。

如果引擎因为固定的输入而优化了某种方式，但是在你的实际程序中，你会给出更多不同的输入，优化决策会有不同的结果（或者根本不存在）。或者，如果引擎在优化中踢了什么，因为它看到代码由基准实用程序运行数万次，但在实际程序中，它只在近距离运行一百次，而在这种情况下，引擎决定优化是不值得的吗？

我们假设的所有优化都可能发生在我们受限的测试中，但也许引擎不会在更复杂的程序中执行（出于各种原因）。或者它可以反转——引擎可能不能优化这种琐碎的代码，但当系统已经被更复杂的程序征税时，它可能更倾向于更积极地优化它。

我想说的一点是，你真的不太清楚到底发生了什么。

这是否意味着你真的不能做任何有用的测试？**绝对不是！**

这归根结底是测试。_不是真实的_代码给你_不是真实的_结果.在尽可能实用的情况下，您应该测试代码中实际的、不平凡的代码片段，并尽可能地根据实际情况进行测试。只有这样，你所得到的结果才有可能接近现实。

微像`+ X`VS`X + +`很可能是假的，我们不妨干脆假设他们是这样的。

## jsperf.com

而Benchmark.js对你的代码的性能无论在JS环境你运行测试是有用的，不能强调不够，你需要编译来自许多不同的环境中测试结果（桌面浏览器，移动设备等）如果你想有任何可靠的试验结论的希望。

例如，高端台式机上的Chrome不太可能像智能手机上的Chrome手机那样运行。当电池开始断电时，智能手机的电池电量将保持2%的电池寿命。

如果你想在任何合理的意义上，除了在一个单一的环境中，“X比Y快”，你就需要尽可能多地测试那些真实世界的环境。仅仅因为Chrome执行X操作比Y快，并不意味着所有浏览器都能做到。当然，您也可能会希望将多个浏览器测试结果与用户的统计数据交叉引用。

有一个很棒的网站为此称jsperf（<http://jsperf.com>）。它使用benchmark.js图书馆我们前面谈到的运行统计准确、可靠的测试，并在一个公开的URL的测试，你可以通过在别人使。

每次测试运行，结果被收集并坚持试验，与累积试验结果绘制在页面的任何人看到。

当在站点上创建测试时，您首先需要填写两个测试用例，但是您可以添加尽可能多的测试用例。你也有能力建立`设置`在每个测试周期的开始运行的代码`拆卸`每个周期结束时运行的代码。

**注：**只做一个测试用例的技巧（如果你对一个方法进行基准测试而不是从头到脚）是在第一次创建时用占位符文本填充第二个测试输入框，然后编辑测试并留下第二个测试空白，这将删除它。以后您总是可以添加更多的测试用例。

您可以定义初始页面设置（导入库、定义实用程序助手函数、声明变量等）。也有定义的安装和拆卸的行为如果需要的选项--参照“设置/清除“在benchmark.js讨论前面的部分。

### 完整性检查

jsperf是一个很好的资源，但有发表的，当你对它们很有缺陷的或虚假的测试非常重要，因为各种原因，概述本章到目前为止。

考虑：

```js
// Case 1
var x = [];
for (var i=0; i<10; i++) {
	x[i] = "x";
}

// Case 2
var x = [];
for (var i=0; i<10; i++) {
	x[x.length] = "x";
}

// Case 3
var x = [];
for (var i=0; i<10; i++) {
	x.push( "x" );
}
```

对这个测试场景的一些思考：

-   开发者把自己的循环测试用例是非常普遍的，他们忘了，Benchmark.js已经做了所有你需要的重复。真的很有可能`对于`这些情况下的循环是完全不必要的噪声。
-   声明和初始化`X`包含在每个测试用例中，可能是不必要的。回想一下，如果`x = [ ]`在`设置`代码，它实际上不会在每次测试迭代之前运行，而是在每个循环开始时运行。这意味着`X`将继续增长相当大，而不仅仅是大小`十`暗示的`对于`环。

    这样做的目的是确保测试仅限于JS引擎如何使用非常小的数组（大小）。`十`）？那_能够_是有意的，但如果是这样的话，你必须考虑一下，这是否过于关注细致入微的内部实现细节。

    另一方面，测试的意图是否包含了数组实际上会变得相当大的上下文？js引擎与较大数组相关的行为是否与实际的实际使用情况相关且准确？

-   是想知道多少钱吗？`x.length`或`x.push（..）`将操作添加到`X`阵列？好的，这可能是一个有效的测试对象。但又一次，`推（…）`是一个函数调用，所以它肯定会慢于`[例句]`访问。可以说，案件1和2比案件3更公平。

这里还有一个例子，说明了常见的苹果对橙子的缺陷：

```js
// Case 1
var x = ["John","Albert","Sue","Frank","Bob"];
x.sort();

// Case 2
var x = ["John","Albert","Sue","Frank","Bob"];
x.sort( function mySort(a,b){
	if (a < b) return -1;
	if (a > b) return 1;
	return 0;
} );
```

在这里，最明显的意图是找出定制速度要慢多少。`mysort（..）`比较器是内置默认比较器。但是通过指定函数`mysort（..）`作为内联函数表达式，您创建了一个不公平/虚假的测试。在这里，第二例不仅是测试一个客户**但它也测试为每次迭代创建一个新函数表达式。**

如果你运行一个类似的测试，但是更新它仅仅是为了创建一个内联函数表达式，而不是使用一个预先声明的函数，你会惊讶吗？内联函数表达式的创建可以从2%到20%慢！？

除非你有这个测试的意图_是_为了考虑内联函数表达式创建“成本”，一个更好的/更公平的测试将`mysort（..）`页面设置中的声明——不要将其放入测试中`设置`这是不必要的重复说明每个周期，只是参考它的名字在测试案例：`x.sort（mysort）`。

在前面的例子中，另一个陷阱是不透明的避免或添加额外的工作”，一个测试用例，创建一个苹果和橘子的情景：

```js
// Case 1
var x = [12,-14,0,3,18,0,2.9];
x.sort();

// Case 2
var x = [12,-14,0,3,18,0,2.9];
x.sort( function mySort(a,b){
	return a - b;
} );
```

抛开前面提到的内联函数表达式陷阱，第二种情况`mysort（..）`在本例中工作，因为您提供了它的数字，但当然会用字符串失败。第一种情况不会抛出错误，但实际上它的行为不同，结果也不同！这应该是显而易见的，但是：**不同的结果在两个测试案例之间几乎无效，整个测试！**

但除了不同的结果，在这种情况下，内置的`排序（…）`比较器实际上正在做“额外工作”。`mysort()`不，是内置一个胁迫比较值的字符串和字典序比较。第一个片段导致`[ - 14, 0, 0，12, 18，2.9，3 ]`而第二段代码结果（可能更准确地基于意图）`[ - 14, 0, 0，2.9，3, 12, 18 ]`。

所以这个测试是不公平的，因为它实际上并没有在两个用例之间执行相同的任务。你得到的任何结果都是假的。

这些相同的陷阱甚至可能更加微妙：

```js
// Case 1
var x = false;
var y = x ? 1 : 2;

// Case 2
var x;
var y = x ? 1 : 2;
```

在这里，意图可能是将强制的性能影响测试为`？：`接线员会这样做的`X`表达式不是布尔值（参见_类型与语法_这本书系列的标题）。所以，你显然同意第二种情况下有额外的工作来做强制的事实。

这个微妙的问题？你的设置`X`在第一种情况下的值，而不是设置在另一种情况下，所以你实际上是在第一种情况下，在第二种情况下不做的工作。要消除任何潜在的（轻微的）偏差，请尝试：

```js
// Case 1
var x = false;
var y = x ? 1 : 2;

// Case 2
var x = undefined;
var y = x ? 1 : 2;
```

现在在这两种情况下都有一个任务，所以你要测试的东西——强制`X`或者不可能被更精确地隔离和测试。

## 编写好的测试

让我看看我是否能说出我要在这里做的更大的一点。

良好的测试创作需要仔细分析一下两个测试用例之间存在的差异以及它们之间的差异。_故意的_或_无意的_。

当然，有意的差异是正常的，但很容易造成无意的差异，影响你的结果。你必须非常非常小心避免歪斜。此外，你可能想要一个不同，但它可能不是显而易见的其他读者测试你的意图是什么，所以他们可能会怀疑（或信任）！你的测试不正确。你怎么解决的？

**写出更好、更清晰的测试。**而且，花时间记录（使用jsperf.com“说明”字段和/或代码注释）正是你考试的目的是什么，甚至到了细致入微的细节。召唤出故意的差异，这将帮助别人，你未来的自己更好地发现意外差异可以测试结果扭曲。

在页面或测试设置中预先声明与测试无关的东西，这样它们就不在测试的定时部分了。

与其试图缩小真正代码的一小部分，而不是仅仅从上下文中计算基准，而是在包含较大（但仍相关）上下文的情况下，测试和基准测试会更好。这些测试也往往运行速度较慢，这意味着你发现的任何差异在上下文中更为相关。

## microperformance

好了，到现在我们一直在跳各种microperformance问题和一般看着disfavorably在沉迷于他们。我想稍等一下，直接给他们讲。

当考虑性能基准代码时，首先需要更加舒适的是，所编写的代码并不总是引擎实际运行的代码。我们在第1章中简要地讨论了这个主题，当时我们讨论了编译器的语句重新排序，但是在这里，我们将建议编译器有时可以决定运行不同于您编写的代码，而不仅仅是不同的顺序，而是不同的内容。

让我们来考虑这段代码：

```js
var foo = 41;

(function(){
	(function(){
		(function(baz){
			var bar = foo + baz;
			// ..
		})(1);
	})();
})();
```

你可以考虑一下`Foo`在最内部函数中需要进行三级范围查找的引用。我们覆盖了_范围和关闭_这本书的系列作品标题词汇范围，而事实上，编译器通常缓存查找，这样referenci`Foo`从不同的范围来看，实际上并没有“额外的”成本。

但还有更深层次的考虑。如果编译器实现了该怎么办？`Foo`不在任何地方引用，而是在一个位置上引用，并且它进一步注意到这个值决不是什么，除了`四十一`如图所示？

js编译器是否可以决定删除`Foo`完全可变，并且_内联_值，例如：

```js
(function(){
	(function(){
		(function(baz){
			var bar = 41 + baz;
			// ..
		})(1);
	})();
})();
```

**注：**当然，编译器也可能会做类似的分析，并用`巴兹`这里也有变数。

当你开始思考你的JS代码作为一个提示或建议对发动机做了什么，而不是字面上的要求，你意识到了离散的句法细节很多的困扰可能是毫无根据的。

另一个例子：

```js
function factorial(n) {
	if (n < 2) return 1;
	return n * factorial( n - 1 );
}

factorial( 5 );		// 120
```

啊，好的老式“阶乘”算法！您可能认为js引擎将运行该代码，主要是。老实说，可能是——我不是很确定。

但是，作为一个轶事，用C表示的相同代码和用高级优化编译的代码将导致编译器实现该调用。`阶乘（5）`可以用常量替换`一百二十`排除功能，完全调用！

此外，一些发动机有一个实践“展开递归，它可以实现递归，你表达的其实是可以做“容易”（即，更有）与环。前面的代码可能是_重写_由js引擎运行：

```js
function factorial(n) {
	if (n < 2) return 1;

	var res = 1;
	for (var i=n; i>1; i--) {
		res *= i;
	}
	return res;
}

factorial( 5 );		// 120
```

现在，让我们假设，在前面的片段中，你一直担心是否`n * factorial(n-1)`或`n =阶乘（- n）`跑得快。也许你甚至做了一个性能基准测试，试图找出哪一个更好。但你忽略了这样的事实：在更大的背景下，发动机不运行的代码或者线因为它可能展开递归！

说起`——`，`——N`与`n`经常被引用为一个可以通过选择`——N`版本，因为从理论上来说，它在处理的组装级别上需要较少的努力。

这种迷恋在现代JavaScript中基本上是没有意义的。这是你应该让发动机来处理的事情。你应该写最有意义的代码。比较这三`对于`环：

```js
// Option 1
for (var i=0; i<10; i++) {
	console.log( i );
}

// Option 2
for (var i=0; i<10; ++i) {
	console.log( i );
}

// Option 3
for (var i=-1; ++i<10; ) {
	console.log( i );
}
```

即使你有一些理论在第二或第三个选项是不是一点点的第一选择更高性能，这是不恰当的，第三环是更混乱因为你开始`- 1`对于`我`解释这一事实`+ +我`预增量使用。第一个和第二个选项之间的差别实在是太不相干了。

js引擎完全可以看到一个地方。`我+ +`使用，并认识到它可以安全地取代它的`+ +我`等价物，这意味着你花时间决定挑选哪一个是完全浪费和结果的模拟。

这是愚蠢的microperformance痴迷的另一个常见的例子：

```js
var x = [ .. ];

// Option 1
for (var i=0; i < x.length; i++) {
	// ..
}

// Option 2
for (var i=0, len = x.length; i < len; i++) {
	// ..
}
```

这里的理论是，您应该缓存`X`变量数组`伦恩`因为表面上它不会改变，避免付出代价`x.length`为循环的每次迭代进行协商。

如果运行性能基准`x.length`与缓存中的用法相比`伦恩`变量，你会发现，虽然理论听起来不错，在实践中，任何测量的差异在统计上完全无关。

事实上，在像V8这样的引擎中，它可以显示出来。<http://mrale.ph/blog/2014/12/24/array-length-caching.html>）你可以通过预先缓存长度而不是让引擎为你计算，使事情变得更糟。不要试图战胜你的JavaScript引擎，你可能会输的时候，性能优化。

### 并非所有发动机都是一样的。

不同浏览器中不同的js引擎都可以“规范兼容”，同时拥有完全不同的代码处理方式。JS规范不需要任何性能相关的--好吧，除了6的尾调用优化”包括在本章的后面。

发动机可以自由地决定一个操作将得到它的注意优化，也许在另一个操作上降低性能。在所有浏览器中找到一种运行速度总是更快的方法可能非常困难。

有一个运动在一些在JS开发社区，特别是那些与Node.js谁工作，分析具体的内部实现细节的V8 JavaScript引擎，写js代码，能够充分利用多V8作品做出决定。通过这样的努力，您实际上可以实现令人惊讶的高性能优化，因此付出的努力可能会相当高。

一些常用的例子（[https://github.com/petkaantonov/bluebird/wiki/optimization-killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)）用于V8引擎：

-   不要错过`争论`从一个功能，其他功能的变量，如“漏”减缓功能实现
-   隔离`试试。赶上`在自己的功能中。浏览器努力优化任何功能与`试试。赶上`在这，所以运动，构建自身的功能意味着你有去优化伤害而让周围的代码优化。

但是，我们不必特别关注这些技巧，让我们理智地检查一下一般意义上的V8优化方法。

您真的编写只需要运行在一个js引擎中的代码吗？即使你的代码是完全用于Node.js_马上_，假设V8会_总是_使用的JS引擎可靠吗？它是可能的，总有一天，几年以后，有一个服务器端的JS平台除了Node.js，你选择运行你的代码吗？如果您以前优化过的程序在新引擎上运行的速度要慢得多呢？

或者，如果你的代码总是从这里一直运行在V8引擎上，但是V8在某个时候决定改变某些操作集的方式，以至于以前的速度很慢，反之亦然？

这些场景也不只是理论上的。过去，将多个字符串值放入数组中，然后调用`加入（“”）`在数组的值将比只使用`+`直接与值串联。这一点的历史原因是细微的，但它与内部实现细节有关如何在内存中存储和管理字符串值。

因此，当时在业界传播的“最佳实践”建议表明开发人员总是使用数组。`加入（…）`方法。许多跟随。

除此之外，js引擎在某种程度上改变了内部管理字符串的方法，并特别为`+`级联。他们没有减速。`加入（…）`但他们付出了更多的努力。`+`用法，因为它仍然相当广泛。

**注：**规范和优化一些特定的方法主要基于其现有的广泛使用，通常被称为实践（比喻）”的cowpath铺路。”

一旦处理字符串和连接的新方法生效，不幸的是，使用数组的所有代码都在野外。`加入（…）`连接字符串是最优的。

另一个例子：有一段时间，Opera浏览器不同于其他浏览器如何处理装箱/拆箱原始包装对象（见_类型与语法_这本书系列的标题）。因此，他们对开发人员的建议是使用`字符串`对象而不是原语`一串`如果属性类似`长度`或方法`charAt（..）`需要访问。这个建议对当时的歌剧可能是正确的，但对于其他主流当代浏览器来说，这完全是截然相反的，因为他们特别针对`一串`原语而不是它们的对象包装器。

我认为这些问题至少是可能的，如果不可能，甚至今天的代码。因此，我非常谨慎地在纯粹基于引擎实现细节的js代码中进行广泛的性能优化，**特别是如果这些细节只适用于某个引擎。**。

反向也是值得警惕：你不必改变一块代码的工作围绕一个引擎的难度与可接受的性能运行一段代码。

从历史上看，IE一直是许多此类挫折的首当其冲，因为在旧IE版本中有很多场景，它在性能方面遇到困难，当时的其他主流浏览器似乎没有什么麻烦。字符串串联讨论我们刚刚实际上是一个真正的关注早在IE6和IE7的日子，有可能得到了更好的性能`加入（…）`比`+`。

但很难指出，只有一个浏览器的性能问题是使用代码方法的理由，这种方法很可能在所有其他浏览器中都是次优的。即使有问题的浏览器对你的站点的受众有很大的市场份额，编写适当的代码并依靠浏览器更新自己以更好地优化最终可能更为实际。

“没有什么比一个临时的黑客更长久。“机会是，你写现在工作周围的一些性能缺陷的代码可能会比在浏览器本身性能的bug。

在一个浏览器每五年更新一次的日子里，这是一个更艰难的要求。但就目前来看，所有浏览器都在以更快的间隔更新（尽管移动世界显然还落后），而且它们都在竞相优化Web特性。

如果你碰到一个浏览器的例子_做_有一个别人都不喜欢的表现疣，一定要通过任何你可以得到的方法向他们汇报。大多数浏览器都公开了适合此目的的公共bug跟踪器。

**提示：**我只是建议工作

### 重点

而不是担心这些microperformance的细微差别，我们应该看大图片类型优化。

你怎么知道什么是大图片呢？您必须首先了解您的代码是否在关键路径上运行。如果它不在关键路径上，那么优化的可能性就不大了。

曾经听过这样的告诫，“那是过早的优化！”？它来自Donald Knuth的名言：“过早优化是万恶之源。”。许多开发人员引用这句话暗示大多数优化是“为时过早”，因此是浪费精力。真相一如往常，更加微妙。

这是Knuth的话，在上下文中：

> 程序员浪费大量的时间来思考或担心**非关键**他们的部分程序，这些效率的尝试实际上有强烈的负面影响，当调试和维护被考虑。我们应该忘记一些小的效率，比如说大约97%的时间：过早的优化是万恶之源。然而，我们不应错过这方面的机会。**批评的**3%。[强调]

（[HTTP：//web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf](http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf)《计算调查》，第6卷，第4期，1974年12月）

我相信这是一个公平的解释说Knuth_意味_“非关键路径优化是万恶之源”，所以关键是要弄清楚你的代码是否在关键路径上——你应该优化它！——或者不。

我甚至会说：没有时间优化关键路径是浪费，不管多少是得救的；但没有对非关键路径的优化是合理的，是保存无论多少。

如果你的代码是在关键路径上，如代码的“热”片，要跑了一遍又一遍，或在关键地方UX的用户会发现，就像一个动画循环或CSS样式的更新，那么你应该不遗余力地尝试运用相关，可显著优化。

例如，考虑一个关键的路径动画循环，它需要将字符串值强制为一个数字。当然有多种方法可以做到这一点（参见_类型与语法_这本书的书名）但是哪一本是最快的？

```js
var x = "42";	// need number `42`

// Option 1: let implicit coercion automatically happen
var y = x / 2;

// Option 2: use `parseInt(..)`
var y = parseInt( x, 0 ) / 2;

// Option 3: use `Number(..)`
var y = Number( x ) / 2;

// Option 4: use `+` unary operator
var y = +x / 2;

// Option 5: use `|` unary operator
var y = (x | 0) / 2;
```

**注：**如果您有兴趣研究一下这些选项中性能的细微差别，我将把它作为一个练习留给读者来设置一个测试。

当考虑到这些不同的选择时，正如他们所说，“其中一件事情和其他的不一样。”`parseInt（..）`没有工作，但它也没有更多的--它将字符串而不是强迫。你可能猜对了`parseInt（..）`是一个较慢的选项，你应该避免它。

当然，如果`X`永远是一个价值**需求分析**，如`“42px”`（类似于CSS样式查找），然后`parseInt（..）`真的是唯一合适的选择！

`数字（..）`也是函数调用。从行为的角度来看，它与`+`一元运算符选项，但实际上可能稍慢一点，需要更多的机器来执行函数。当然，也有可能是JS引擎识别这种行为的对称，只是处理内联`数字（..）`行为（又名`+ X`）为你！

但是记住，沉迷于`+ X`与`X | 0`在大多数情况下很可能是在浪费精力。这是一个microperformance问题，和一个你不应该让口述/降低程序的可读性。

虽然性能在程序的关键路径中非常重要，但它不是唯一的因素。在性能上大致相似的几个选项中，可读性应该是另一个重要的关注点。

## 尾调用优化（TCO）

正如我们前面提到过的，6包括特定要求的企业进入表演的世界。它与函数调用可能发生的特定形式的优化有关：_尾部调用优化_。

简单地说，“尾调用”是出现在另一个函数的“尾部”的函数调用，这样在调用结束之后，就没有什么可以做的（除了返回它的结果值）。

例如，这里有一个带有尾部调用的非递归设置：

```js
function foo(x) {
	return x;
}

function bar(y) {
	return foo( y + 1 );	// tail call
}

function baz() {
	return 1 + bar( 40 );	// not tail call
}

baz();						// 42
```

`富（y + 1）`是尾调用`酒吧（…）`因为在`富（…）`完成，`酒吧（…）`除了在本例中返回`富（…）`呼叫。然而,`酒吧（40）`是_不_尾调用，因为它完成后，它的结果值必须添加到`一`之前`baz()`可以退货吗？。

没有太多繁琐的细节，呼唤一种新的功能需要保留的内存，额外的时间来管理“调用堆栈”，称为“堆栈”。所以前一段通常需要为每个堆栈帧`baz()`，`酒吧（…）`，和`富（…）`都在同一时间。

然而，如果一个TCO引擎能够实现`富（y + 1）`电话是_尾巴的位置_意思`酒吧（…）`基本上是完整的，然后当调用`富（…）`它没有N`酒吧（…）`。这不仅速度更快，而且占用内存更少。

这种优化在一个简单的代码片段中并不是什么大问题，但它变成了一个_更大的问题_在处理递归时，特别是如果递归可能导致成百上千的堆栈帧。使用TCO，引擎可以用一个堆栈帧执行所有这些调用！

递归在JS中是一个棘手的话题，因为没有TCO，引擎必须实现任意的（和不同的）！限制递归堆栈在停止之前的深度，以防止内存耗尽。使用TCO，递归函数_尾巴的位置_调用本质上是不受限制的，因为没有任何额外的内存使用！

考虑到递归`阶乘（..）`从以前，但重写，使其TCO友好：

```js
function factorial(n) {
	function fact(n,res) {
		if (n < 2) return res;

		return fact( n - 1, n * res );
	}

	return fact( n, 1 );
}

factorial( 5 );		// 120
```

这个版本的`factorial(..)`仍然是递归的，但它也可优化TCO，因为内`事实（…）`电话是_尾巴的位置_。

**注：**重要的是要注意，TCO只适用于实际的尾部调用。如果不使用尾部调用来编写递归函数，那么性能将回到正常的堆栈帧分配中，并且这种递归调用堆栈的引擎限制仍然适用。许多递归函数可以重写，正如我们刚才展示的那样。`阶乘（..）`但它需要仔细注意细节。

其中一个原因，6需要引擎实现TCO的而不是由他们的自由裁量权是因为_缺乏TCO_实际上减少了使用递归实现JS中某些算法的可能性，因为担心调用堆栈限制。

如果在发动机TCO的缺乏会优雅地降低在所有情况下，性能下降，它不可能是6需要_要求_。但是，由于缺乏TCO实际上可以使某些程序不实用，所以它更像是语言的一个重要特性，而不是一个隐藏的实现细节。

6保证，从现在起，JS开发者将能够依靠这种优化在所有6 +兼容的浏览器。这是JS的胜利！

## 回顾

有效地对一段代码进行基准测试，特别是将其与相同代码的另一个选项进行比较，以确定哪种方法更快，需要仔细注意细节。

而不是滚动自己的统计上有效的标杆管理的逻辑，只是用benchmark.js图书馆，这确实是你。但要注意你如何编写测试，因为构建一个看似有效但实际上有缺陷的测试是非常容易的，即使微小的差异也会使结果完全不可靠。

尽可能多地从不同的环境中获得尽可能多的测试结果，以消除硬件/设备偏差是很重要的。jsperf.com是众包的性能基准测试运行一个神奇的网站。

许多常见的性能测试，不幸的是microperformance痴迷于无关的细节`X + +`与`+ X`。编写好的测试意味着理解如何关注大的图片关注点，比如优化关键路径，避免陷入像JS引擎的具体实现那样的陷阱。

尾部调用优化（TCO）是一个必需的优化为6，会使一些递归模式实际在JS那里不可能会有其他。TCO允许函数调用_尾巴的位置_另一个函数执行时不需要任何额外的资源，这意味着引擎不再需要对递归算法的调用堆栈深度设置任意限制。
