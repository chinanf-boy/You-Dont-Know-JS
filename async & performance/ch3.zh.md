
# 你不知道JS：异步性能

# 第3章：承诺

在2章中，我们确定了两大类缺陷采用回调表示程序异步和并发：顺序和缺乏信任缺乏。既然我们更深入地理解了这些问题，现在是时候把注意力转向能够解决这些问题的模式了。

我们首先要解决的问题是_控制反转_信任是如此的脆弱，那么容易失去举行。

回想一下，我们结束了_延续_我们的程序在回调函数中，并将回调传递给另一方（甚至可能是外部代码），只要交叉手指，调用回调函数就行了。

我们这样做是因为我们想说，“这里发生了什么_后来_在当前步骤结束后。

但如果我们能uninvert，_控制反转_？如果不是把我们的程序延续到另一方，我们可以期望它返回我们知道任务完成的能力，然后我们的代码可以决定下一步该做什么？

这种范式被称为**承诺**。

承诺开始以JS世界的风暴，为开发商和规范的作家都拼命寻求解开地狱的疯狂在回调代码/设计。事实上，最新的异步API添加到JS和DOM平台是建立在承诺。所以，你可以深入了解和学习它们，这是个好主意，你不这么认为吗？！？

**注：**本章中经常使用“立即”这个词，一般用来指一些承诺解决行动。然而，从本质上说，“立即”指的是工作队列行为（参见第1章），而不是严格同步的。_现在_感。

## 什么是承诺？

当开发人员决定学习一种新技术或模式时，通常他们的第一步是“向我展示代码”。这是很自然的，我们只是先跳脚，然后边走边学习。

但事实证明，有些抽象在单独的API上丢失了。承诺是其中的一种工具，它可以很明显地从某人如何使用它，不管他们是否理解它的用途，而不仅仅是学习和使用API。

所以在我展示承诺代码之前，我想充分解释一个承诺在概念上到底是什么。我希望这将引导你更好的为你探索整合到自己的异步流承诺理论。

考虑到这一点，让我们来看看两种不同的类比。_是_。

### 未来价值

想象一下这样的场景：我走到柜台，在一家快餐店，并把一个芝士汉堡的订单。我给收银员1.47美元。我下订单并付了钱，我已提出要求。_价值_回（汉堡）。我已经开始交易了。

但往往，汉堡不是立即可用的我。收银员递给我的东西在我的汉堡的地方：一个有订单号的收据。这是一张借条的阶数（“我欠你的”）_承诺_，最终，我应该得到我的汉堡。

我拿着收据和订单号。我知道它代表我的_未来的汉堡_所以我不需要再担心了——除了饥饿！

当我等待的时候，我可以做其他的事情，比如给朋友发短信说：“嘿，你能和我一起去吃午饭吗？”我要吃一个汉堡。”

我在推理我的_未来的汉堡_虽然我还没有拿到它。我的大脑能够这样做是因为它是处理订单号为汉堡的占位符。占位符实质上构成了值。_时间无关_。这是一个**未来价值**。

最后，我听到，“订单113！”我兴高采烈地走到柜台与收据在手。我的手我的收据到收银台，我把我的三明治的回报。

换句话说，曾经的我_未来价值_准备好了，我把我的价值承诺换成了价值本身。

但是还有另一个可能的结果。他们把我的订单号，但是当我去找回我的芝士汉堡，收银员遗憾地告诉我，“我很抱歉，但我们似乎所有的汉堡”。撇开这一场景的客户失望的一刹那，我们可以看到一个重要的特征_未来价值_他们可以表示成功或失败。

每一次我点了一个汉堡，我知道我会得到一个芝士汉堡最终还是我把汉堡不足令人伤心的消息，我会找出别的吃的午餐。

**注：**在代码中，事情并不那么简单，因为它们的阶数可能永远不会被调用，在这种情况下，我们离开了无限期中一个悬而未决的状态。我们以后再处理那个案件。

#### 现在和以后的价值观

这一切听起来可能过于抽象，无法应用到您的代码中。所以让我们更具体些。

然而，在我们介绍如何以这种方式工作的承诺，我们将获得的代码，我们已经明白，回调！——如何_未来价值_。

当您编写代码来分析某个值时，例如在`数`不管你是否意识到，你一直在对这个价值观做一些非常重要的事情，那就是它是一个具体的东西。_现在_价值已经：

```js
var x, y = 2;

console.log( x + y ); // NaN  <-- because `x` isn't set yet
```

这个`x + y`操作假设`X`和`Y`已经设置。我们将在短期内阐述，我们假设`X`和`Y`价值观已经_断然的_。

指望那`+`操作员本身将神奇地能够探测和等待直到两个。`X`和`Y`解决（又名准备），只有这样做的操作。如果不同的语句完成，这将导致程序的混乱。_现在_和其他人完成_后来_，对吗？

如果两个语句中的一个（或两个）可能还没有完成，你怎么可能推断出它们之间的关系呢？如果语句2依赖于语句1完成，则只有两个结果：语句1完成正确_现在_一切进展顺利，或声明1尚未完成，因此语句2将失败。

如果第1章听起来很熟悉的话，那就好了！

让我们回到我们的`x + y`数学运算。想象一下，如果有一种方式说，“添加`X`和`Y`但是如果他们中的任何一个还没有准备好，就等到他们。尽快把它们加起来。”

你的大脑可能会跳到回调。好的，所以…

```js
function add(getX,getY,cb) {
	var x, y;
	getX( function(xVal){
		x = xVal;
		// both are ready?
		if (y != undefined) {
			cb( x + y );	// send along sum
		}
	} );
	getY( function(yVal){
		y = yVal;
		// both are ready?
		if (x != undefined) {
			cb( x + y );	// send along sum
		}
	} );
}

// `fetchX()` and `fetchY()` are sync or async
// functions
add( fetchX, fetchY, function(sum){
	console.log( sum ); // that was easy, huh?
} );
```

花一点时间让这个片段的美丽（或缺乏）沉入其中（耐心地吹口哨）。

而丑是不可否认的，有一些关于这个异步模式的通知很重要。

在那个片段中，我们对待`X`和`Y`作为未来的价值观，我们表达了一种行动。`添加（..）`（从外面）不在乎是否`X`或`Y`或者两者都可以立即使用。换句话说，它规范了_现在_和_后来_这样我们就可以依靠一个可预测的结果`添加（..）`操作。

通过使用一个`添加（..）`这在时间上是一致的——它的行为相同。_现在_和_后来_时间异步代码的原因更容易。

更明确地说：始终如一地处理两者_现在_和_后来_我们两个都做_后来_：所有操作成为异步。

当然，这种粗糙的回调方法不尽人意。这只是实现推理的好处的第一小步。_未来价值_不必担心何时可用或不可用。

#### 价值的承诺

我们将在本章后面讨论更多关于承诺的细节，所以如果有些问题令人困惑的话不要担心，但是让我们简单地看看如何表达。`x + y`例如通过`承诺`S：

```js
function add(xPromise,yPromise) {
	// `Promise.all([ .. ])` takes an array of promises,
	// and returns a new promise that waits on them
	// all to finish
	return Promise.all( [xPromise, yPromise] )

	// when that promise is resolved, let's take the
	// received `X` and `Y` values and add them together.
	.then( function(values){
		// `values` is an array of the messages from the
		// previously resolved promises
		return values[0] + values[1];
	} );
}

// `fetchX()` and `fetchY()` return promises for
// their respective values, which may be ready
// *now* or *later*.
add( fetchX(), fetchY() )

// we get a promise back for the sum of those
// two numbers.
// now we chain-call `then(..)` to wait for the
// resolution of that returned promise.
.then( function(sum){
	console.log( sum ); // that was easier!
} );
```

这段代码中有两层承诺。

`fetchx()`和`fetchy()`直接调用它们返回的值（承诺！）进入`添加（..）`。这些承诺所代表的潜在价值可能已经准备就绪。_现在_或_后来_但每一个承诺，规范行为是相同的无论。我们的原因`X`和`Y`时间独立的价值观。他们是_未来价值_。

第二层是承诺`添加（..）`创建（通过`承诺（全部）]）`然后返回，我们通过调用等待`然后（…）`。当`添加（..）`操作完成，我们`总和`未来价值_准备好了，我们可以把它打印出来。我们藏在里面_添加（..）`等待的逻辑`X`和`Y`未来价值`。_注：_里面

**添加（..）**，的`承诺（全部）]）`呼叫创造承诺（等待）`promisex`和`promisey`解决）。链式调用`然后（…）`创造另一个承诺`返回值[ 0 ] +值[ 1 ]`行立即解析（添加结果）。因此，该`然后（…）`呼叫我们链结束的`添加（..）`调用——在代码片段的结尾——实际上是对返回的第二个承诺进行操作，而不是由`承诺（全部）]）`。而且，虽然我们没有把第二个结束`然后（…）`它也创造了另一个承诺，如果我们选择观察/使用它的话。这一承诺链的内容将在本章后面更详细地解释。`就像汉堡的订单，这是可能的，一个承诺，而不是履行拒绝决议。与实现的承诺不同，在值总是编程的情况下，拒绝值（通常称为“拒绝原因”）可以由程序逻辑直接设置，也可以从运行时异常隐式产生。`有了承诺，

然后（…）

调用实际上可以接受两个函数，第一个用于实现（如前面所示），第二个函数用于拒绝：`如果出了什么问题`X

```js
add( fetchX(), fetchY() )
.then(
	// fullfillment handler
	function(sum) {
		console.log( sum );
	},
	// rejection handler
	function(err) {
		console.error( err ); // bummer!
	}
);
```

或`Y`或者，在添加过程中，不知何故失败了。`添加（..）`返回被拒绝，第二个回调错误处理程序传递给`然后（…）`将从承诺中得到拒绝值。`因为承诺封装了时间依赖状态——等待基础的实现或拒绝。`将从承诺中得到拒绝值。

因为承诺封装了时间依赖的状态——等待基础价值的实现或拒绝——从外部看，承诺本身是时间独立的，因此承诺可以以可预测的方式组合起来，而不考虑时间和结果。

而且，一旦承诺得到解决，它就会永远保持下去——它变成了一个承诺。_永恒的价值_在这一点上，然后可以_观察_必要时多次。

**注：**因为承诺在外部是不变的，一旦解决，现在就可以安全地将该值传递给任何一方，并且知道它不能被意外地或恶意地修改。这是特别真实的多个缔约方遵守决议的承诺。一方不可能影响另一方遵守承诺的能力。听起来像是一个学术性的话题，但实际上它是一个承诺，设计最基本、最重要的方面，而不应该随便过。

这是了解承诺的最重要和最重要的概念之一。有了大量的工作，你可以随意地用丑陋的回调组合来创建同样的效果，但这并不是一个真正有效的策略，特别是因为你必须一遍又一遍地做。

承诺是一种易于重复的封装和组合机制。_未来价值_。

### 完成事件

正如我们刚才看到的，一个人的承诺表现为_未来价值_。但是还有另一种方法来考虑一个承诺的解决方案：作为一个流控制机制，在一个异步任务中有两个或多个步骤。

让我们假设调用一个函数`富（…）`执行某项任务。我们不知道它的任何细节，我们也不关心。它可能马上完成任务，也可能需要一段时间。

我们只是需要知道什么时候`富（…）`完成，这样我们就可以继续我们的下一个任务了。换句话说，我们希望有一个通知的方法。`富（…）`完成了，这样我们就可以_持续_。

在典型的JavaScript方式中，如果您需要侦听通知，您可能会考虑到事件。所以我们可以把我们需要通知需要听一_完成_（或_延续_事件由`富（…）`。

**注：**无论你把它称为“完成事件”还是“延续事件”都取决于你的观点。更关注的是发生了什么`富（…）`或者发生了什么_之后_富（…）`完成了吗？这两种观点都是准确和有用的。事件通知告诉我们`富（…）`有`完整的_但也可以_持续_下一步。事实上，您传递给事件通知的回调本身就是我们前面所称的_延续_。因为_完成事件_更侧重于_富（…）`这是我们目前比较关注的，我们有点赞成。`完成事件_在本文的其余部分。_而回调，“通知”将我们的回调函数的调用（任务

富（…）`）。但是有了承诺，我们就可以扭转关系，期望我们能倾听来自某个事件的信息。`富（…）`通知后，继续进行。`首先，考虑一些伪代码：

我们的电话

```js
foo(x) {
	// start doing something that could take a while
}

foo( 42 )

on (foo "completion") {
	// now we can do the next step!
}

on (foo "error") {
	// oops, something went wrong in `foo(..)`
}
```

富（…）`然后我们设置了两个事件侦听器，一个用于`“完成”`和一个`“错误”`——这两种可能`最终的_结果的_富（…）`呼叫。在本质上，`富（…）`甚至没有意识到调用代码已经订阅了这些事件，这是非常好的。`关注点分离_。_不幸的是，这种代码需要一些不存在的JS环境的“魔力”（可能有点不切实际）。下面是用js表达的更自然的方法：

富（…）

```js
function foo(x) {
	// start doing something that could take a while

	// make a `listener` event notification
	// capability to return

	return listener;
}

var evt = foo( 42 );

evt.on( "completion", function(){
	// now we can do the next step!
} );

evt.on( "failure", function(err){
	// oops, something went wrong in `foo(..)`
} );
```

`显式地创建一个事件订阅功能来返回，并且调用代码接收并注册这两个事件处理程序。`从正常回调面向代码的反转应该是显而易见的，它是有意的。而不是通过回调

富（…）`它返回我们调用的事件能力。`EVT`，接收回调。`但如果你回顾一下第2章，回调本身代表一个

控制反转_。因此，反转回调模式实际上是_反演反演_，或_uninversion控制_——将控制恢复回我们希望它首先出现的调用代码中。_一个重要的好处是，代码的多个独立部分可以被赋予事件侦听功能，并且它们都可以独立地被通知何时

富（…）`完成完成后的后续步骤：`uninversion控制

```js
var evt = foo( 42 );

// let `bar(..)` listen to `foo(..)`'s completion
bar( evt );

// also, let `baz(..)` listen to `foo(..)`'s completion
baz( evt );
```

_使一个更好的_关注点分离_，在那里_酒吧（…）`和`巴兹（..）`不需要参与`富（…）`被称为。同样，`富（…）`不需要知道或关心`酒吧（…）`和`巴兹（..）`存在或正在等待通知`富（…）`完成。`从本质上讲，这

EVT`目标`对象是在单独关注点之间的中立的第三方协商。

#### 承诺“事件”

正如你现在已经猜到的，`EVT`事件侦听能力是对承诺的类比。

在基于承诺的方法中，前一段代码将具有`富（…）`创建和返回`承诺`实例，然后这个承诺将被传递给`酒吧（…）`和`巴兹（..）`。

**注：**我们所承诺的“事件”并不是严格的事件（尽管它们确实像是为了这些目的而活动），而且它们通常不被称为事件。`“完成”`或`“错误”`。相反，我们使用`然后（…）`登记`“然后”`事件。或者更确切地说，`然后（…）`寄存器`“满足”`和/或`“拒绝”`事件（s），尽管我们没有看到代码中使用的那些术语。

考虑：

```js
function foo(x) {
	// start doing something that could take a while

	// construct and return a promise
	return new Promise( function(resolve,reject){
		// eventually, call `resolve(..)` or `reject(..)`,
		// which are the resolution callbacks for
		// the promise.
	} );
}

var p = foo( 42 );

bar( p );

baz( p );
```

**注：**所示的图案`新的承诺（函数（..）{…}）`一般称为[“显示构造函数”](http://domenic.me/2014/02/13/the-revealing-constructor-pattern/)。该功能通过立即执行（不是异步递延，如回调`然后（…）`），它提供了两个参数，在本例中我们命名`决定`和`拒绝`。这些是承诺的解析函数。`决心（…）`一般来说信号实现，和`拒绝（…）`信号抑制。

你也许能猜出里面是什么。`酒吧（…）`和`巴兹（..）`可能看起来像：

```js
function bar(fooPromise) {
	// listen for `foo(..)` to complete
	fooPromise.then(
		function(){
			// `foo(..)` has now finished, so
			// do `bar(..)`'s task
		},
		function(){
			// oops, something went wrong in `foo(..)`
		}
	);
}

// ditto for `baz(..)`
```

承诺解决并不一定要涉及发送消息，就像我们检查承诺时一样。_未来价值_。它可以是一个流控制信号，如前一段代码中使用的那样。

另一种方法是：

```js
function bar() {
	// `foo(..)` has definitely finished, so
	// do `bar(..)`'s task
}

function oopsBar() {
	// oops, something went wrong in `foo(..)`,
	// so `bar(..)` didn't run
}

// ditto for `baz()` and `oopsBaz()`

var p = foo( 42 );

p.then( bar, oopsBar );

p.then( baz, oopsBaz );
```

**注：**如果您以前见过基于承诺的编码，您可能会想相信代码的最后两行可以写成`p.then（..）然后（…）`，使用链接，而不是`p.then（..）；p.then（..）`。那会有完全不同的行为，所以要小心！的差异可能不是现在是明确的，但它实际上比我们迄今为止看到的不同的异步模式：分裂/分叉。不必担心，我们将在本章后面回到这一点。

而不是通过`P`承诺`酒吧（…）`和`巴兹（..）`我们用承诺来控制`酒吧（…）`和`巴兹（..）`将被处决，如果有的话。主要区别在于错误处理。

在第一段代码中，`酒吧（…）`不管是否被调用。`富（…）`成功或失败，如果它被通知，它会处理自己的回退逻辑。`富（…）`失败.这同样适用于`巴兹（..）`显然。

在第二段代码中，`酒吧（…）`只有调用`富（…）`成功，否则`OOPSBAR（..）`被称为。同上`巴兹（..）`。

方法都不_对的_本身。会有一个比另一个更受欢迎的例子。

无论哪种情况，都是承诺`P`那是从`富（…）`用来控制接下来发生的事情。

此外，这两个片段结束调用的事实`然后（…）`两次违背同一个诺言`P`说明了前面提出的观点，即承诺（一旦解决）将永远保持其相同的解决方案（履行或拒绝），随后可以在必要时多次观察。

每当`P`解决了，下一步总是一样的，都_现在_和_后来_。

## thenable鸭打字

在应许之地，一个重要的细节是如何确切地知道某个价值是否是真正的诺言。或者更直接地说，它的价值是否会像一个承诺？

鉴于承诺是由`新承诺（..）`语法，你可能会认为`P是承诺`是可以接受的支票。但不幸的是，有很多原因还不够充分。

主要的，你可以从另一个浏览器窗口中获得价值的承诺（iframe，等），这将不同于当前窗口/框架的一个自己的承诺，那将无法确定承诺的实例。

此外，库或框架可以选择出售自己的承诺和不使用原生的ES6`承诺`实现这样做。事实上，你很可能在旧浏览器中使用库的承诺，而这些浏览器根本就没有承诺。

当我们在本章后面讨论承诺解决过程时，它将变得更加明显，为什么一个非真正的但承诺一样的价值仍然是非常重要的，能够识别和同化。但现在，请相信我的话，这是一个关键的一块拼图。

因此，它是决定承认承诺的方式（或东西，像一个承诺）是定义了一种叫做“thenable”任何对象或函数具有`然后（…）`方法。它是假定任何这样的价值是一种承诺符合thenable。

一般说来，“检查”，假设一个值的类型根据其形状（什么性质的存在）称为“duck typing”--“如果它看起来像鸭子，叫起来像鸭子，它必须是一个鸭”（见_类型与语法_这本书系列的标题）。因此，duck typing检查一thenable大致是：

```js
if (
	p !== null &&
	(
		typeof p === "object" ||
		typeof p === "function"
	) &&
	typeof p.then === "function"
) {
	// assume it's a thenable!
}
else {
	// not a thenable
}
```

讨厌!设置

如果你试图用任何一个对象/函数值来实现一个承诺`然后（…）`功能上，但你不想它被视为一个承诺/ thenable，你运气不好，因为它会自动被公认为thenable和特殊规则处理（见本章之后）。

这甚至是真的，如果你没有意识到值有一个`然后（…）`在这。例如:

```js
var o = { then: function(){} };

// make `v` be `[[Prototype]]`-linked to `o`
var v = Object.create( o );

v.someStuff = "cool";
v.otherStuff = "not so cool";

v.hasOwnProperty( "then" );		// false
```

`v`不像一个承诺或thenable所有。它只是一个具有一些属性的普通对象。您可能正打算像其他对象那样发送该值。

但你不知道，`v`是也`[原型]`链接的（参见_对象原型_这本书系列的标题）到另一个对象`o`碰巧有一个`然后（…）`在这。所以thenable鸭子类型检查会认为和假设`v`是一个thenable。哦。

它甚至不需要像那样直接的意图：

```js
Object.prototype.then = function(){};
Array.prototype.then = function(){};

var v1 = { hello: "world" };
var v2 = [ "Hello", "World" ];
```

两`V1`和`V2`将被认为是thenables。您不能控制或预测任何其他代码意外或恶意添加。`然后（…）`到`object.prototype`，`array.prototype`或者其他任何本机原型。如果指定的是一个函数不会调用其参数为回调，那么任何承诺解决这样的价值将永远只是默默挂！疯子.

听起来难以置信还是不可能？也许.

但请记住，有几个著名的非承诺在社区图书馆已有6，已经对他们有了之前调用方法`然后（…）`。其中一些库选择重命名自己的方法以避免碰撞（这太糟糕了！）而其他人则被简单地归因于“基于承诺的编码不兼容”这一不幸的状态，以奖励他们无法做出改变以摆脱困境。

标准决定劫持以前非预定--完全通用的发声——`然后`属性名称意味着没有任何值（或它的任何委托），无论过去、现在或将来，都可以拥有`然后（…）`功能，不管是有意的或偶然的，或者说价值会迷茫在thenable承诺系统，这可能会产生错误，真的很难追踪。

**警告：**我不喜欢我们如何结束鸭打字thenables承诺识别。还有其他选择，比如“品牌化”甚至“反品牌化”，我们得到的似乎是最糟糕的妥协。但这并不全是厄运和忧郁。thenable鸭子类型可以是有益的，我们后面会看到。只是要注意，thenable鸭打字可以是危险的如果不正确地确定一些承诺吧。

## 承诺信任

我们现在看到的两强类比解释不同方面的什么承诺，可以做我们的异步代码。但是，如果我们止步于此，我们可能错过了承诺模式建立的最重要的一个特征：信任。

而_未来价值_和_完成事件_类比在我们探索过的代码模式中显式地发挥出来，它并不是完全清楚为什么承诺是如何设计来解决所有的问题的。_控制反转_我们在第2章的“信任问题”一节中提出的信任问题。但有一点的挖掘，我们可以发现一些重要的保证恢复异步编码，2章撕下去的信心！

让我们回顾与回调只编码的信任问题开始。当您将回调传递给实用程序时`富（…）`它可能：

-   过早回调回调
-   调用回调太晚（或从未）
-   调用回调次数太少或太多次
-   未能传递任何必需的环境/参数
-   吞咽可能发生的任何错误/异常

承诺的特点是故意设计，以提供有用的，可重复的答案，所有这些问题。

### 打得太早

首先，这是一个问题的代码是否可以介绍该样作用（见2章），有时一个任务完成，有时同步异步，从而导致竞争条件。

定义上的承诺不容易受到这种担心，因为即使是立即兑现的承诺（比如`新的承诺（函数（解析）{解析（42）；}）`）不能_观察_同步。

也就是说，当你打电话的时候`然后（…）`在承诺上，即使这个承诺已经解决了，你提供的回调`然后（…）`将**总是**异步调用（在第1章中，请参阅“作业”）。

不再需要插入你自己的`setTimeout（：0）`黑客。承诺防止该自动。

### 打电话太晚了

与前一点相似，一个承诺`然后（…）`注册观察回调时自动安排`决心（…）`或`拒绝（…）`被承诺创造能力称为。这些计划将在未来可预见的回调异步力矩解雇（见“工作”1章）。

同步观察是不可能的，所以同步的任务链不可能以这样的方式运行。`然后（…）`注册回调函数将被调用，以在下一个机会，立即异步（同样的，看到“工作”在1章），没有什么事情在一个回调函数可以影响/延迟其他回调函数调用。

例如:

```js
p.then( function(){
	p.then( function(){
		console.log( "C" );
	} );
	console.log( "A" );
} );
p.then( function(){
	console.log( "B" );
} );
// A B C
```

在这里,`“C”`不能中断并先于`“B”`由于诺言是如何定义来运作的。

#### 保证调度的怪癖

值得注意的是，虽然有调度之间的链式两单独承诺回调的相对顺序是不可靠的预测差别很多。

如果两个承诺`P1`和`P2`都已经解决了，应该是真的`然后（..）；P2。然后（..）`最终会调用回调函数`P1`在那之前`P2`。但是有一些微妙的情况，这可能不是真的，例如：

```js
var p3 = new Promise( function(resolve,reject){
	resolve( "B" );
} );

var p1 = new Promise( function(resolve,reject){
	resolve( p3 );
} );

var p2 = new Promise( function(resolve,reject){
	resolve( "A" );
} );

p1.then( function(v){
	console.log( v );
} );

p2.then( function(v){
	console.log( v );
} );

// A B  <-- not  B A  as you might expect
```

我们稍后会讨论这个问题，但正如你所看到的，`P1`不是立即的价值，而是另一个承诺。`P3`这本身就是用价值来决定的。`“B”`。指定的行为是_打开_P3`进入之内`P1`但异步，所以`P1`的回调（s）是`后面_P2_在异步作业队列中的回调（参见第1章）。`为了避免这种细致入微的噩梦，你永远都不应该依靠订货/回调在调度任何承诺。事实上，一个好的做法是不是代码以这样一种方式，在所有的多个回调事项排序。如果可以的话，避免这种情况。`从不调用回调

这是一个非常普遍的问题。它有多种方式可寻址。

### 首先，没有什么（甚至不是JS错误）可以阻止承诺通知它的解决方案（如果它已经解决）。如果你登记一个许诺履行和拒绝回调，并承诺会解决，其中一个回调函数将总是被称为。

当然，如果你自己有回调JS错误，你可能看不到你期望的结果，但回调将在事实上被称为。稍后我们将讨论如何通知回调中的错误，因为即使是这些错误也不会被吞噬。

但是如果承诺本身永远不能得到解决呢？即使是这样的条件，也可以提供一个答案，使用更高级别的抽象，称为“种族”：

有更多的细节要考虑这个承诺超时模式，但我们会回来以后。

重要的是，我们可以确保信号的结果

```js
// a utility for timing out a Promise
function timeoutPromise(delay) {
	return new Promise( function(resolve,reject){
		setTimeout( function(){
			reject( "Timeout!" );
		}, delay );
	} );
}

// setup a timeout for `foo()`
Promise.race( [
	foo(),					// attempt `foo()`
	timeoutPromise( 3000 )	// give it 3 seconds
] )
.then(
	function(){
		// `foo(..)` fulfilled in time!
	},
	function(err){
		// either `foo()` rejected, or it just
		// didn't finish in time, so inspect
		// `err` to know which
	}
);
```

foo()

为了防止它无限期地挂起我们的程序。`打电话太少或太多次`通过定义，

### 一

调用回调的适当次数。“太少”的情况是零调用，这与我们刚才检查的“从不”的情况是一样的。_“太多”的案例很容易解释。承诺是被定义的，这样只能解决一次。如果出于某种原因，希望创建代码尝试调用_决心（…）

或`拒绝（…）`多次，或试图调用两者，承诺将只接受第一个决议，并会默默地忽略任何后续尝试。`因为诺言只能解决一次，任何`然后（…）

注册回调函数只会被调用一次（每个）。`当然，如果多次注册相同的回调函数，那么（例如），`p.then（F）；p.then（F）；

）它将被多次调用。保证一个响应函数只调用一次不会阻止你自己开枪。`未能传递任何参数/环境`承诺最多可以有一个决议价值（履行或拒绝）。

### 如果您没有以任何方式显式解析值，则值为

未定义

，这是js中的典型。但不管什么价值，它总是会被传递给所有注册的（和适当的履行或拒绝）回调，要么`现在`或将来。_需要注意的事情：如果你打电话_决心（…）

或`拒绝（…）`有了多个参数后，第一个参数后面的所有参数都将被忽略。虽然这似乎违背了我们刚才描述的保证，但并不完全是因为它构成了允诺机制的无效用法。API的其他无效用法（如调用）`决心（…）`多次）也是类似的。`受保护的`所以这里的承诺行为是一致的（如果不是有点令人沮丧的话）。_如果要传递多个值，则必须将它们包装在传递的另一个值中，例如_阵列

或一个`对象`。`至于环境，js中的函数总是保留它们定义的范围的闭包（参见`范围和关闭

这个系列的标题），所以他们当然会继续访问你所提供的周围状态。当然，同样是回调的设计实现，所以这不是一个具体的增强受益的承诺--但这是保证我们可以依靠但。_吞咽任何错误/异常_在基本意义上，这是对前面一点的重述。如果你拒绝承诺

### 原因

（又名错误消息），那个值_原因_（又名错误消息），该值被传递到拒绝回调（s）。

但这里有更大的作用。如果在创建承诺的任何时刻，或者在观察其解析时，都会出现JS异常错误，例如`TypeError`或`引用错误`这个例外将被抓住，它将迫使有关的承诺被拒绝。

例如:

```js
var p = new Promise( function(resolve,reject){
	foo.bar();	// `foo` is not defined, so error!
	resolve( 42 );	// never gets here :(
} );

p.then(
	function fulfilled(){
		// never gets here :(
	},
	function rejected(err){
		// `err` will be a `TypeError` exception object
		// from the `foo.bar()` line.
	}
);
```

发生的JS异常`bar() foo。`变成一个你可以捕捉并回应的承诺。

这是一个重要的细节，因为它有效地解决了另一个潜在的该时刻，即误差可以创建一个同步反应而nonerrors将异步。承诺甚至将JS异常转换为异步行为，从而大大降低了竞争条件的机会。

但是如果实现了一个承诺，那么在观察过程中会出现一个JS异常错误（在`然后（…）`注册回调函数）？即使那些并没有丢失，但你可能会发现它们的处理方式有点让人吃惊，直到你深入挖掘：

```js
var p = new Promise( function(resolve,reject){
	resolve( 42 );
} );

p.then(
	function fulfilled(msg){
		foo.bar();
		console.log( msg );	// never gets here :(
	},
	function rejected(err){
		// never gets here either :(
	}
);
```

等等，这看起来像是一个例外`bar() foo。`真的被吞下去了。不要害怕，它没有，但更深层次的东西是错误的，那就是我们没有倾听它。这个`p.then（..）`调用本身返回另一个承诺，它是_那个_承诺将被拒绝`TypeError`例外。

为什么不能调用我们在那里定义的错误处理程序呢？表面上似乎是一种合乎逻辑的行为。但这将违背承诺的基本原则。**不可改变的**一旦解决了。`P`已经实现了价值`四十二`所以不能因为观察上有错误就把它改为拒绝。`P`决议。

除了原则上的违反，这种行为可能会造成破坏，如果说有多重的话。`然后（…）`注册回调的承诺`P`因为有些人会被打电话，而另一些人不会打电话，而且为什么会很不透明。

### 可信的承诺吗？

有一个最后的细节要检查，以建立基于承诺模式的信任。

毫无疑问你会发现承诺不摆脱回调都。它们只是将回调传递到。而不是将回调传递给`富（…）`，我们得到_某物_（表面上是真正的承诺）`富（…）`我们把回调传递给那个_某物_相反。

但为什么这是任何只是回调更可信？我们怎么能确定_某物_我们回来实际上是一个可信的承诺吗？难道这根本不是一个只有我们信任的地方才能信任的纸牌屋吗？

承诺中最重要但常常被忽视的细节之一是，他们也有解决这个问题的方法。包括与本地ES6`承诺`实现`承诺，决心（…）`。

如果你通过一个直接的，非承诺，非thenable价值`承诺，决心（…）`你得到了一个用这个价值实现的承诺。换句话说，这两个承诺`P1`和`P2`行为基本相同：

```js
var p1 = new Promise( function(resolve,reject){
	resolve( 42 );
} );

var p2 = Promise.resolve( 42 );
```

但如果你真的答应了`承诺，决心（…）`你只是得到同样的承诺：

```js
var p1 = Promise.resolve( 42 );

var p2 = Promise.resolve( p1 );

p1 === p2; // true
```

更重要的是，如果你通过一个非承诺thenable价值`承诺，决心（…）`，它会尝试打开那个价值，并展开将继续直到最后非诺言的价值是具体的提取。

记得我们以前讨论thenables？

考虑：

```js
var p = {
	then: function(cb) {
		cb( 42 );
	}
};

// this works OK, but only by good fortune
p
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// never gets here
	}
);
```

这`P`是一个thenable，但它不是一个真正的承诺。幸运的是，这是合理的。但是如果你回来的话，看起来像什么？：

```js
var p = {
	then: function(cb,errcb) {
		cb( 42 );
		errcb( "evil laugh" );
	}
};

p
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// oops, shouldn't have run
		console.log( err ); // evil laugh
	}
);
```

这`P`是一个thenable但很乖巧的一个承诺。是恶意的吗？或者只是不知道承诺应该如何工作？老实说，这并不重要。在任何情况下，这是不可信的是。

尽管如此，我们可以通过这些版本中的任何一个`P`到`承诺，决心（…）`我们会得到正常、安全的结果：

```js
Promise.resolve( p )
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// never gets here
	}
);
```

`承诺，决心（…）`将接受任何thenable，将打开它的非thenable价值。但你可以从`承诺，决心（…）`一个真正的、真正的承诺，**一个你可以信任的人**。如果你所传递的已经是一个真正的承诺，你就把它立刻收回，这样就没有任何负面影响了。`承诺，决心（…）`获得信任。

所以让我们说我们在打电话`富（…）`效用，我们不知道我们可以信任它的返回值是一个行为的承诺，但我们知道它的至少一个thenable。`承诺，决心（…）`会给我们一个可信的承诺包装链断：

```js
// don't just do this:
foo( 42 )
.then( function(v){
	console.log( v );
} );

// instead, do this:
Promise.resolve( foo( 42 ) )
.then( function(v){
	console.log( v );
} );
```

**注：**包装的另一个有益的副作用`承诺，决心（…）`在任何一个函数的返回值（thenable或不）是它的规范，函数调用到行为的异步任务的一种简单方法。如果`美孚（42）`有时返回即时值，或返回其他时间的承诺，`承诺（解决方案（富（42）））`确保它总是一个承诺的结果。避免Zalgo是更好的代码。

### 信任的建立

希望前面的讨论已经完全“决定

你可以写异步代码JS没有信任吗？当然可以。我们的JS开发者已编码异步只有近二十年的回调。

但是，一旦你开始质疑你可以信任你的建立实际上是可预测和可靠的机制，你开始意识到回调有非常不稳固的信任基础。

承诺是一种模式，增强回调与可信语义，这样的行为更加理性、更可靠。通过uninverting的_控制反转_回调，我们将控制一个可信系统（承诺），是专门为我们的异步带来清醒。

## 供应链管理流程

我们已经暗示过几次了，但承诺不仅仅是一个步骤的机制。_然后，_排序操作。当然，积木，，但我们可以串多承诺一起代表一个序列的异步步骤。

这项工作的关键是建立在承诺的两个固有行为之上：

-   每次你打电话`然后（…）`在承诺上，它创造并返回一个新的承诺，我们可以_链_随着。
-   无论您返回的值是多少`然后（…）`调用的实现回调（第一个参数）将自动设置为_链接_承诺（从第一点开始）。

让我们首先说明这意味着什么，_然后_我们会得到如何帮助我们创建异步序列的流量控制。考虑以下：

```js
var p = Promise.resolve( 21 );

var p2 = p.then( function(v){
	console.log( v );	// 21

	// fulfill `p2` with value `42`
	return v * 2;
} );

// chain off `p2`
p2.then( function(v){
	console.log( v );	// 42
} );
```

通过返回`v * 2`（即，`四十二`我们实现了`P2`答应第一个`然后（…）`创建和返回调用。什么时候`P2`的`然后（…）`调用运行，它接收来自`返回V * 2`声明。当然,`然后（…）`创造另一个承诺，我们可以储存在`P3`变量。

但是要创建中间变量是有点烦人的。`P2`（或`P3`等等）。幸运的是，我们可以很容易地把这些联系起来：

```js
var p = Promise.resolve( 21 );

p
.then( function(v){
	console.log( v );	// 21

	// fulfill the chained promise with value `42`
	return v * 2;
} )
// here's the chained promise
.then( function(v){
	console.log( v );	// 42
} );
```

所以现在第一个`然后（…）`在一个异步序列的第一步，第二`然后（…）`是第二步。只要你需要它，它就会一直持续下去。继续链接以前的链接`然后（…）`每个自动创建的承诺。

但是这里缺少一些东西。如果我们希望步骤2等待步骤1执行异步操作，该怎么办？我们使用的是即时`返回`语句，立即完成链式承诺。

关键是使承诺真正能够在每一步异步序列是回忆`承诺，决心（…）`工作时，你通过这是一个承诺或thenable代替最后的价值。`承诺，决心（…）`直接返回接收到的真正的承诺，也打开了一thenable收到价值--继续递归而不断展开thenables。

如果你进行了同样的解包`返回`一个thenable或承诺履行（或拒绝）处理程序。考虑：

```js
var p = Promise.resolve( 21 );

p.then( function(v){
	console.log( v );	// 21

	// create a promise and return it
	return new Promise( function(resolve,reject){
		// fulfill with value `42`
		resolve( v * 2 );
	} );
} )
.then( function(v){
	console.log( v );	// 42
} );
```

即使我们包裹`四十二`在我们返回的承诺中，它仍然被解开，最终成为了链式承诺的解决方案，比如第二个承诺。`然后（…）`还收到了`四十二`。如果我们将异步引入到包装承诺中，那么一切仍然很好：

```js
var p = Promise.resolve( 21 );

p.then( function(v){
	console.log( v );	// 21

	// create a promise to return
	return new Promise( function(resolve,reject){
		// introduce asynchrony!
		setTimeout( function(){
			// fulfill with value `42`
			resolve( v * 2 );
		}, 100 );
	} );
} )
.then( function(v){
	// runs after the 100ms delay in the previous step
	console.log( v );	// 42
} );
```

难以置信的强大！现在我们可以构造一个序列，然而许多异步步骤，我们希望，每一步都延迟下一步（或不！）必要时。

当然，在这些示例中，一步一步地传递的值是可选的。如果不返回显式值，则隐式`未定义`假设，承诺仍然以同样的方式链在一起。因此，每一个承诺的解决都只是下一步的信号。

为了进一步说明链式说明，让我们将延迟承诺创建（没有解析消息）扩展到实用程序中，我们可以重用多个步骤：

```js
function delay(time) {
	return new Promise( function(resolve,reject){
		setTimeout( resolve, time );
	} );
}

delay( 100 ) // step 1
.then( function STEP2(){
	console.log( "step 2 (after 100ms)" );
	return delay( 200 );
} )
.then( function STEP3(){
	console.log( "step 3 (after another 200ms)" );
} )
.then( function STEP4(){
	console.log( "step 4 (next Job)" );
	return delay( 50 );
} )
.then( function STEP5(){
	console.log( "step 5 (after another 50ms)" );
} )
...
```

打电话`延迟（200）`创建一个承诺，将履行在200ms，然后我们返回从第一`然后（…）`实现回调，导致第二个回调`然后（…）`的承诺等，200ms承诺。

**注：**如前所述，在技术上有交流中的两个承诺：200ms延迟的承诺，在承诺的第二`然后（…）`链。但你可能会发现将这两个承诺结合在一起更容易，因为承诺机制会自动为你合并它们的状态。在这方面，你可以想到`返回延迟（200）`创建一个取代先前返回的链承诺的承诺。

老实说，尽管没有消息传递的延迟序列并不是一个非常有用的承诺流控制示例。让我们来看一个更实际的方案。

我们不考虑定时器，而是考虑制作Ajax请求：

```js
// assume an `ajax( {url}, {callback} )` utility

// Promise-aware ajax
function request(url) {
	return new Promise( function(resolve,reject){
		// the `ajax(..)` callback should be our
		// promise's `resolve(..)` function
		ajax( url, resolve );
	} );
}
```

我们首先定义一个`request(..)`构造一个承诺来代表完成的实用程序。`ajax(..)`呼叫：

```js
request( "http://some.url.1/" )
.then( function(response1){
	return request( "http://some.url.2/?v=" + response1 );
} )
.then( function(response2){
	console.log( response2 );
} );
```

**注：**开发人员经常遇到的情况，他们想与事业本身并不答应知道异步流量控制保证启用（如`ajax（..）`在这里，需要回调）`承诺`机制不会自动为我们解决这个模式，实际上是所有希望的库。_做_。他们通常把这个过程称为“提升”或“promisifying”或其变体。我们稍后再来介绍这个技术。

使用承诺返回`request(..)`我们通过第一个URL调用它来隐式地创建链中的第一步，并将第一个返回的承诺链起来。`然后（…）`。

一旦`response1`返回时，我们使用该值来构造第二个URL，然后生成第二个URL。`request(..)`呼叫。第二`请求（…）`承诺是`返回`ED让我们异步流控制第三步等待Ajax调用完成。最后，我们打印`反应`一旦它回来。

承诺链构建不仅是表达了一种多级异步序列流的控制，但它也作为一个信息渠道传播消息，一步一步。

如果承诺链中的某个步骤出错了怎么办？一个错误/异常是以每个承诺为基础的，这意味着在链中的任何一个点都有可能捕捉到这样的错误，而捕获行为则将“重置”链重新排序为在该点上的正常操作：

```js
// step 1:
request( "http://some.url.1/" )

// step 2:
.then( function(response1){
	foo.bar(); // undefined, error!

	// never gets here
	return request( "http://some.url.2/?v=" + response1 );
} )

// step 3:
.then(
	function fulfilled(response2){
		// never gets here
	},
	// rejection handler to catch the error
	function rejected(err){
		console.log( err );	// `TypeError` from `foo.bar()` error
		return 42;
	}
)

// step 4:
.then( function(msg){
	console.log( msg );		// 42
} );
```

当错误发生在步骤2中时，步骤3中的拒绝处理程序将捕获它。返回值（`四十二`在这个代码段中，如果有的话，从拒绝处理程序完成对下一步（4）的承诺，这样链就回到了满足状态。

**注：**正如我们前面讨论过的，当从一个满足处理程序返回一个承诺时，它会被解包并延迟下一步。返回拒绝处理程序的承诺也是如此，如果`返回42`在步骤3中，返回一个承诺，该承诺可以延迟步骤4。在执行或拒绝处理程序中的抛出异常。`然后（…）`调用导致下一个（链式）承诺将立即被拒绝。

如果你打电话`然后（…）`在承诺上，你只将一个履行处理程序传递给它，一个假设的拒绝处理程序被替换：

```js
var p = new Promise( function(resolve,reject){
	reject( "Oops" );
} );

var p2 = p.then(
	function fulfilled(){
		// never gets here
	}
	// assumed rejection handler, if omitted or
	// any other non-function value passed
	// function(err) {
	//     throw err;
	// }
);
```

你可以看到，假设排斥处理器只是重新抛出错误，最终迫使`P2`（链式承诺）以同样的错误原因拒绝。本质上，这允许错误沿着承诺链继续传播，直到遇到一个显式定义的拒绝处理程序。

**注：**稍后我们会详细讨论错误处理的细节，因为还有其他细致入微的细节需要关注。

如果没有将有效的有效函数作为传递处理程序参数传递给`然后（…）`也有一个默认的处理程序替换：

```js
var p = Promise.resolve( 42 );

p.then(
	// assumed fulfillment handler, if omitted or
	// any other non-function value passed
	// function(v) {
	//     return v;
	// }
	null,
	function rejected(err){
		// never gets here
	}
);
```

正如您所看到的，默认的执行处理程序只是传递它收到的任何值到下一步（承诺）。

**注：**这个`然后（NULL，函数（错误）{…}）`只处理模式——拒绝（如果有）但让实践通过在API的捷径：`catch（函数（错误）{}）`。我们将覆盖`抓住（…）`更充分地在下一节。

让我们简要回顾一下启用链接流控制的承诺的内在行为：

-   一`然后（…）`对一个承诺的呼唤会自动产生一个新的承诺。
-   在满足/拒绝处理，如果你返回一个值或抛出一个异常，新的返回（可）是解决相应的承诺。
-   如果实现或拒绝处理程序返回了一个承诺，则它将被解包，这样它的任何解决方案都将成为从当前返回的链式承诺的解决方案。`然后（…）`。

虽然链接流控制是有帮助的，但它可能最准确地把它看作是承诺如何组合在一起的一个附带好处，而不是主要意图。正如我们已经多次详细讨论过的那样，承诺将异步化为常态并封装时间依赖性的值状态，并且_那个_是什么让我们用这种有用的方式把它们连接在一起？。

当然，外链的顺序表现（这这这…）是在乱糟糟的回调的一大进步我们在2章确定。但仍有相当数量的样板（`然后（…）`和`function() { ..}`跋涉。在下一章中，我们会看到连续的流量控制力明显更好的模式，与发电机。

### 术语：解决、完成和拒绝

在我们对承诺有太多的了解之前，有一些小小的混乱围绕着“决心”、“满足”和“拒绝”这两个术语，我们需要清理。让我们先来考虑一下`许诺（…）`构造函数：

```js
var p = new Promise( function(X,Y){
	// X() for fulfillment
	// Y() for rejection
} );
```

你可以看到，两个回调（这里标记`X`和`Y`提供。第一个是_通常_用以兑现诺言，第二次兑现_总是_将承诺视为拒绝。但是，“通常”是什么意思，准确命名这些参数意味着什么呢？

最终，它只是您的用户代码，标识符名称不被引擎解释为意味着什么，所以它没有。_技术上_物质；`富（…）`和`文学士`功能相同。但是你使用的词汇不仅影响你如何思考代码，而且影响你团队中其他开发人员的思考。思维错误对精心策划的异步代码几乎肯定是要比意大利面回调更糟的选择。

所以它实际上有点像你所说的。

第二个参数很容易决定。几乎所有的文学作品`拒绝（…）`因为它的名字，因为那是准确的（而且只有！）它做什么，这是一个很好的名字选择。我强烈建议你总是使用`拒绝（…）`。

但是在第一个参数中有一些歧义，这在承诺的文献中经常被标记。`决心（…）`。这个词显然与“解决方案”有关，这是整个文学（包括这本书）中用来描述最终价值/状态到承诺的内容。我们已经多次使用“解决承诺”来表示履行或拒绝承诺。

但是，如果这个参数似乎被用来具体履行诺言，为什么我们不称它为`完成（…）`而不是`决心（…）`更准确些吗？为了回答这个问题，让我们看看两个`承诺`API方法：

```js
var fulfilledPr = Promise.resolve( 42 );

var rejectedPr = Promise.reject( "Oops" );
```

`承诺，决心（…）`创造一个被赋予价值的承诺。在这个例子中，`四十二`是正常的，不答应，非thenable价值，所以履行承诺`fulfilledpr`是为价值而创造的`四十二`。`承诺。拒绝（“哎呀”）`创造被拒绝的承诺`rejectedpr`的原因`“哎呀”`。

现在让我们解释一下“决心”这个词的原因（例如`承诺，决心（…）`）如果在上下文中明确地使用，可以实现或拒绝，这是明确且确实更准确的：

```js
var rejectedTh = {
	then: function(resolved,rejected) {
		rejected( "Oops" );
	}
};

var rejectedPr = Promise.resolve( rejectedTh );
```

正如我们在本章前面所讨论的那样，`承诺，决心（…）`将接收到的真正的承诺，或打开收到的thenable。如果thenable展开了拒绝状态，答应回来`承诺，决心（…）`其实是在同一个拒绝状态。

所以`承诺，决心（…）`是API方法的一个好的、准确的名称，因为它实际上可以实现或拒绝。

第一个回调参数`许诺（…）`构造函数将打开一个thenable（相同`承诺，决心（…）`或者一个真正的承诺：

```js
var rejectedPr = new Promise( function(resolve,reject){
	// resolve this promise with a rejected promise
	resolve( Promise.reject( "Oops" ) );
} );

rejectedPr.then(
	function fulfilled(){
		// never gets here
	},
	function rejected(err){
		console.log( err );	// "Oops"
	}
);
```

现在应该清楚了`决心（…）`是第一个回调参数的适当名称。`许诺（…）`构造函数。

**警告：**前面提到的`拒绝（…）`做**不**做解缠`决心（…）`做.如果你通过一个承诺/ thenable价值`拒绝（…）`那个未被触及的值将被设置为拒绝的理由。随后拒绝处理将得到实际的承诺/ thenable你通过了`拒绝（…）`，而不是它的底层即时价值。

现在让我们把注意力转到了回调`然后（…）`。他们应该被称为什么（在文学和代码中）？我会建议`满足（…）`和`拒绝（…）`：

```js
function fulfilled(msg) {
	console.log( msg );
}

function rejected(err) {
	console.error( err );
}

p.then(
	fulfilled,
	rejected
);
```

在第一个参数的情况下`然后（…）`毫无疑问，它始终是满足的情况，因此不需要“解决”术语的对偶性。作为一个方面说明，6规范使用`onfulfilled（..）`和`onrejected（..）`这些标签两个回调，因此准确的术语。

## 错误处理

我们已经看到了几个关于承诺拒绝的例子——不管是有意的还是拒绝的。`拒绝（…）`通过js或意外的例外，允许的误差在异步编程处理。让我们再通过明确的一些细节，我们掩饰。

对于大多数开发人员来说，最自然的错误处理形式是同步的。`试试。赶上`构建。不幸的是，它是同步的，所以它不能帮助异步代码模式：

```js
function foo() {
	setTimeout( function(){
		baz.bar();
	}, 100 );
}

try {
	foo();
	// later throws global error from `baz.bar()`
}
catch (err) {
	// never gets here
}
```

`试试。赶上`当然有好的，但它不工作在异步操作。也就是说，除非有一些额外的环境支持，我们将在第4章回到发电机。

在回调，一些标准的出现为图案的错误处理，最引人注目的是“错误的第一个回调”的风格：

```js
function foo(cb) {
	setTimeout( function(){
		try {
			var x = baz.bar();
			cb( null, x ); // success!
		}
		catch (err) {
			cb( err );
		}
	}, 100 );
}

foo( function(err,val){
	if (err) {
		console.error( err ); // bummer :(
	}
	else {
		console.log( val );
	}
} );
```

**注：**这个`试试。赶上`这里只从`bar()巴兹。`同步调用将成功或失败。如果`bar()巴兹。`本身就是自己的异步完成的功能，任何异步错误里面不会开捕。

我们传给的回调`富（…）`期望通过保留的第一个参数接收错误信号。`犯错`。如果存在，则假定为错误。如果没有，则假定成功。

这种错误处理在技术上是正确的。_异步可_但它一点也写不好。错误的第一个回调交织在一起的这些无处不在的多层次`如果`语句检查不可避免地会导致回调地狱的危险（参见第2章）。

因此，我们返回到错误处理的承诺中，拒绝处理程序传递给`然后（…）`。承诺不使用流行的“错误优先回调”设计风格，而是使用“拆分”。

```js
var p = Promise.reject( "Oops" );

p.then(
	function fulfilled(){
		// never gets here
	},
	function rejected(err){
		console.log( err ); // "Oops"
	}
);
```

虽然这种错误处理模式在表面上有很好的意义，但是允诺错误处理的细微差别通常是很难完全掌握的。

考虑：

```js
var p = Promise.resolve( 42 );

p.then(
	function fulfilled(msg){
		// numbers don't have string functions,
		// so will throw an error
		console.log( msg.toLowerCase() );
	},
	function rejected(err){
		// never gets here
	}
);
```

如果`tolowercase()味精。`合法地抛出一个错误（它确实如此！）为什么我们的错误处理程序没有被通知？正如我们早些时候解释的那样，那是因为_那个_错误处理程序是`P`承诺，已经实现了价值。`四十二`。这个`P`承诺是不可变的，因此唯一可以通知错误的承诺是从返回的承诺。`p.then（..）`在这种情况下，我们不捕获。

这应该清楚地说明为什么错误处理与承诺是容易出错的（双关语意图）。这很容易被错误吞噬，因为这很少是你想要的。

**警告：**如果您以无效的方式使用承诺API，并且发生错误，从而阻止了适当的承诺构造，结果将是立即抛出的异常，**不是被拒绝的承诺**。一些不正确用法的例子：`新承诺（空）`，`all()承诺。`，`承诺，种族（42）`等等。如果你没有足够有效地使用承诺API来真正构建一个承诺，你就不能得到一个被拒绝的承诺！

### 绝望的深渊

Jeff Atwood几年前注意到：编程语言通常是这样设置的，默认情况下，开发人员陷入“绝望的深渊”。<http://blog.codinghorror.com/falling-into-the-pit-of-success/>——在事故受到惩罚的地方，你必须更加努力地把它做好。他恳求我们去创造一个“成功的陷阱”，在这种情况下，你会陷入预期的（成功的）行动中，因此必须努力去失败。

承诺错误处理无疑是“绝望的深渊”设计。默认情况下，它假定你想要的任何错误被承诺国家吞噬，如果你忘了观察到的状态，默默的憔悴的误差/死在默默无闻——通常是绝望。

为了避免在一个被遗忘的/被抛弃的承诺的沉默中丢失一个错误，一些开发人员声称承诺链的“最佳实践”是以一个最终结束你的链。`抓住（…）`，像：

```js
var p = Promise.resolve( 42 );

p.then(
	function fulfilled(msg){
		// numbers don't have string functions,
		// so will throw an error
		console.log( msg.toLowerCase() );
	}
)
.catch( handleErrors );
```

因为我们没有把拒绝处理程序传递给`然后（…）`默认的处理程序被替换，它只将错误传播到链中的下一个承诺。因此，两个错误都会出现。`P`和错误来了_之后_P`在其决议中（如`tolowercase()味精。`一个）过滤到最后。`handleerrors（..）`。`问题解决了，对吗？不这么快。

如果发生什么

handleerrors（..）`本身也有错误吗？谁抓到的？还有另一个无人看管的承诺：一个`抓住（…）`返回，我们不捕获，不注册拒绝处理程序。`你不能只坚持另一个

抓住（…）`在那个链条的末端，因为它也可能失败。在任何承诺链的最后一步，无论是什么，都有可能降低，甚至因此，悬挂一个未被发现的错误被困在一个不可观测的承诺。`听起来像是一个不可能解决的难题？

错误处理

### 这完全不是一个容易解决的问题。还有许多其他方法可以让许多人这么说。

更好的_。_有些许的图书馆已经添加的方法注册类似“全球未处理拒绝”处理，可称为“全球泛起错误。但他们的解决方案，如何识别错误的“错误”是有一个任意长度的定时器，说3秒，从拒绝运行时间。如果一个承诺被拒绝但没有错误处理程序在定时器注册，然后就以为你不会注册一个处理程序，所以它的“捕获”。

实际上，这对许多库都有效，因为大多数使用模式通常不要求在拒绝承诺和观察拒绝之间显著延迟。但这种模式很麻烦，因为3秒是任意的（即使实证），也因为确实有一些情况下，你想要一个承诺，保持它的rejectedness为时间状语，你真的不想让你的“捕获”处理程序中调用这些误报（不然而，办理“未捕获的错误”）。

另一个更常见的建议是，承诺应该有

完成（…）`添加到他们，这基本上标志着承诺链为“完成”。`完成（…）`不创建并返回一个承诺，所以传递给回调函数`完成（…）`显然没有连接到报告问题的连锁承诺不存在。`那么，会发生什么呢？这是作为你通常可能在未被发现的错误条件的期望：在任何异常

完成（…）`拒绝处理程序将被作为一个全球性的未被发现的错误（在开发者控制台，基本上）：`这可能听起来比永无止境的链或任意超时更有吸引力。但最大的问题是，它不是6标准的一部分，所以无论多么好的它的声音，它充其量是更长远地

```js
var p = Promise.resolve( 42 );

p.then(
	function fulfilled(msg){
		// numbers don't have string functions,
		// so will throw an error
		console.log( msg.toLowerCase() );
	}
)
.done( null, handleErrors );

// if `handleErrors(..)` caused its own exception, it would
// be thrown globally here
```

这可能听起来比永无止境的链或任意超时更有吸引力。但最大的问题是，它不是6标准的一部分，所以无论多么好的它的声音，它充其量是一个更长的方式从一个可靠的和无处不在的解决方案。

我们是不是被困住了？不完全。

浏览器有一个独特的功能，我们的代码没有：他们可以跟踪，并知道任何对象被丢弃时，垃圾收集。因此，浏览器可以跟踪承诺的对象，当他们被垃圾收集器收集，如果他们拒绝在他们的浏览器，知道这是一个合法的“未被发现的错误，“因此可以自信地知道应该报告给开发者控制台。

**注：**在写这篇文章的时候，无论是Chrome和Firefox有那种“捕获的拒绝”能力的早期尝试，虽然不完全支持是最好的。

然而，如果一个承诺没有被垃圾收集——这很容易在很多不同的编码模式下发生——浏览器的垃圾收集嗅探并不能帮助你知道和诊断你有一个默默拒绝的承诺。

还有其他选择吗？对.

### 坑的成功

以下只是理论上的承诺_能够_有一天变了行为。我相信它将远远优于我们目前拥有的。我认为这种变化是可能的甚至post-es6因为我不认为它会打破网络兼容ES6承诺。此外，它可以polyfilled / prollyfilled，如果你小心。让我们看一看：

-   在下一个作业或事件循环滴答声中，如果没有任何错误处理程序已被注册，则承诺可能会默认在下一个作业或事件循环报告中报告（对开发控制台）的任何拒绝。
-   如果你想要一个被拒绝的承诺，在观察之前不确定地保留它被拒绝的状态，你可以调用。`defer()`，它抑制对该承诺的自动错误报告。

如果承诺被拒绝，则默认为向开发人员控制台报告该事实（而不是默认为静默）。您可以隐式地退出该报告（通过拒绝之前注册错误处理程序），或者显式地（使用`defer()`）。无论哪种情况，_你_控制假阳性。

考虑：

```js
var p = Promise.reject( "Oops" ).defer();

// `foo(..)` is Promise-aware
foo( 42 )
.then(
	function fulfilled(){
		return p;
	},
	function rejected(err){
		// handle `foo(..)` error
	}
);
...
```

当我们创建`P`我们知道我们将等待一段时间来使用/观察它的拒绝，所以我们调用`defer()`-因此没有全球报告。`defer()`简单地返回相同的承诺，用于链接目的。

诺言从`富（…）`获取附加的错误处理程序。_马上_因此，它隐含地选择退出，也没有对它进行全局报告。

但是诺言从`然后（…）`电话没有`defer()`或附加的错误处理程序，因此如果它拒绝（从任一解析处理器内），那么_它_将报告给开发者控制台作为一个未被发现的错误。

**这个设计是成功的陷阱。**默认情况下，所有错误都是处理或报告的——几乎所有的开发人员几乎所有的情况都会预料到的。您必须注册一个处理程序，或者您必须有意退出，并指示您打算推迟错误处理直到_后来_你只是在特定的情况下选择额外的责任。

这种方法唯一的真正危险是如果你`defer()`一个承诺，但实际上却没有观察到/处理它的拒绝。

但你不得不故意打电话`defer()`选择进入绝望的深渊——默认是成功的陷阱——因此我们没有什么可以做的事情来挽救你自己的错误。

我想还是希望保证错误处理的有（post-es6）。我希望那些大国将重新考虑局势并考虑这种选择。同时，你可以自己实现这个（对读者来说是一个挑战性的练习！），或使用_更聪明的_承诺库为你这样做！

**注：**这种错误处理/报告的精确模型是在我的_asynquence_承诺抽象库，将在本书附录A中讨论。

## 承诺模式

我们已经隐式地看到了带有承诺链的序列模式（接下来是流控制），但是异步模式有很多变化，我们可以在承诺之上构建抽象模式。这些模式可以简化表达异步流控制--这有助于使我们的代码更合理和更容易维护，甚至在我们的节目中最复杂的部分。

两模式编纂直接进入本地ES6`承诺`实现，因此我们免费获取它们，作为其他模式的构建块。

### 承诺。[..]）

在一个异步序列（承诺链），只有一个异步任务正在协调在任何特定的时刻——步骤2严格遵循步骤1和步骤3，严格遵循步骤2。但同时执行两个或多个步骤（又名“并行”）呢？

在经典编程术语中，“门”是一种等待两个或多个并行/ CO的机制。

在承诺API中，我们称这种模式为`全部（[…]]）`。

假设您希望同时编写两个Ajax请求，并在完成第三个Ajax请求之前等待它们完成，不管它们的顺序是什么。考虑：

```js
// `request(..)` is a Promise-aware Ajax utility,
// like we defined earlier in the chapter

var p1 = request( "http://some.url.1/" );
var p2 = request( "http://some.url.2/" );

Promise.all( [p1,p2] )
.then( function(msgs){
	// both `p1` and `p2` fulfill and pass in
	// their messages here
	return request(
		"http://some.url.3/?v=" + msgs.join(",")
	);
} )
.then( function(msg){
	console.log( msg );
} );
```

`承诺（全部）]）`期望一个参数，一个`阵列`一般由允诺的实例组成。诺言从`承诺（全部）]）`呼叫将收到一个履行信息（`短信息`在这个片段中）`阵列`在传递的承诺中的所有完成消息中，按照指定的顺序（不管实现顺序）。

**注：**技术上，该`阵列`传递的值`承诺（全部）]）`包括承诺，thenables，甚至立即值。列表中的每个值基本上都是通过的。`承诺，决心（…）`为了确保它是一个真正的承诺，等待，所以一个即时的价值将被规范成一个承诺的价值。如果`阵列`是空的，主承诺马上兑现。

主要承诺从`承诺（全部）]）`只有当所有的承诺都兑现了，才能兑现。如果这些承诺中的任何一个被拒绝，主`承诺（全部）]）`承诺立即被拒绝，抛弃任何其他承诺的结果。

记住，总是要在每个承诺中附加一个拒绝/错误处理程序，甚至特别是从后面返回的承诺。`承诺（全部）]）`。

### 承诺，比赛。[..]）

而`承诺（全部）]）`同时协调多个承诺，假设一切都需要履行，有时你只想回应“越过终点线的第一个承诺”，让其他承诺消失。

这种模式被经典地称为“闩锁”，但在承诺中，它被称为“种族”。

**警告：**虽然“只有第一个终点线获胜”的比喻很适合这一行为，不幸的是“种族”是一个加载术语，因为“竞赛条件”通常被视为程序中的错误（参见第1章）。不要混淆`承诺（赛跑）]）`有“比赛条件”。

`承诺（赛跑）]）`也期待单身`阵列`的说法，含有一个或更多的承诺，thenables，或立即值。有一个直接价值观的比赛是没有多大实际意义的，因为第一个被列入比赛的人显然会赢，比如一个赛跑选手在终点线开始的赛跑！

类似`承诺（全部）]）`，`承诺（赛跑）]）`如果任何承诺的解决都是一种实现，那么它将完成，并且它将拒绝，如果和何时任何承诺解决是一个拒绝。

**警告：**“比赛”要求至少有一个“跑步者”，所以如果你传球无效。`阵列`而不是立即解决，主要`种族（[…]）`诺言永不解决。这是一个footgun！6应该指定其履行，拒绝，或只是抛出一些同步误差。不幸的是，由于在保证图书馆早6优先`承诺`他们离开了，在那里，所以要小心，不要把一个空`阵列`。

让我们重新访问我们以前的Ajax示例，但在`P1`和`P2`：

```js
// `request(..)` is a Promise-aware Ajax utility,
// like we defined earlier in the chapter

var p1 = request( "http://some.url.1/" );
var p2 = request( "http://some.url.2/" );

Promise.race( [p1,p2] )
.then( function(msg){
	// either `p1` or `p2` will win the race
	return request(
		"http://some.url.3/?v=" + msg
	);
} )
.then( function(msg){
	console.log( msg );
} );
```

因为只有一个承诺获胜，实现值是一个单一的消息，而不是一个。`阵列`就像是为了`承诺（全部）]）`。

#### 暂停比赛

我们早些时候看到了这个例子，说明了如何`承诺（赛跑）]）`可以用来表示“允诺超时”模式：

```js
// `foo()` is a Promise-aware function

// `timeoutPromise(..)`, defined ealier, returns
// a Promise that rejects after a specified delay

// setup a timeout for `foo()`
Promise.race( [
	foo(),					// attempt `foo()`
	timeoutPromise( 3000 )	// give it 3 seconds
] )
.then(
	function(){
		// `foo(..)` fulfilled in time!
	},
	function(err){
		// either `foo()` rejected, or it just
		// didn't finish in time, so inspect
		// `err` to know which
	}
);
```

这种超时模式在大多数情况下效果良好。但也有一些细微差别需要考虑，坦率地说，它们都适用于两者。`承诺（赛跑）]）`和`承诺（全部）]）`同样地.

#### “最后”

要问的关键问题是：“被丢弃/忽视的承诺会发生什么？”我们并不是从性能的角度来问这个问题——它们通常会最终成为符合条件的垃圾收集——但是从行为的角度来看（副作用等）。承诺不能被取消，不应该是那些会破坏外部性讨论的“信任承诺uncancelable”部分，在本章的后面，所以他们只能默默地忽视。

但如果`foo()`在前一个示例中，保留了某种资源以供使用，但超时首先触发并导致该承诺被忽略。这种模式中有没有什么东西在超时后主动释放保留资源，或者以其他方式取消它可能有的任何副作用？如果你想要的只是记录事实`foo()`超时？

一些开发人员已经提出承诺需要一个`最后（…）`回调注册，它总是在承诺解析时调用，并允许您指定可能需要的任何清理。这并不存在于规范的时刻，但它会在ES7 +。我们得等着瞧。

可能看起来像：

```js
var p = Promise.resolve( 42 );

p.then( something )
.finally( cleanup )
.then( another )
.finally( cleanup );
```

**注：**在各种希望库中，`最后（…）`仍然创建并返回一个新的承诺（保持链）。如果`清理（…）`函数返回一个承诺，它将连接成链，这意味着你可以

在此期间，我们可以创建一个静态助手实用程序，让我们观察（不干扰）承诺的解决方案：

```js
// polyfill-safe guard check
if (!Promise.observe) {
	Promise.observe = function(pr,cb) {
		// side-observe `pr`'s resolution
		pr.then(
			function fulfilled(msg){
				// schedule callback async (as Job)
				Promise.resolve( msg ).then( cb );
			},
			function rejected(err){
				// schedule callback async (as Job)
				Promise.resolve( err ).then( cb );
			}
		);

		// return original promise
		return pr;
	};
}
```

下面是我们如何在超时示例中使用它：

```js
Promise.race( [
	Promise.observe(
		foo(),					// attempt `foo()`
		function cleanup(msg){
			// clean up after `foo()`, even if it
			// didn't finish before the timeout
		}
	),
	timeoutPromise( 3000 )	// give it 3 seconds
] )
```

这`承诺，遵守（…）`助手只是一个例子，说明你如何观察承诺的完成而不干扰他们。其他承诺库有自己的解决方案。不管你怎么做，你可能会有一些地方，你想确保你的承诺不是。_只是_默默地忽略了意外。

### 所有的变体（[..]和种族（[..]）

而本土ES6承诺都内置`承诺（全部）]）`和`承诺（赛跑）]）`还有几种常用的模式，这些语义上有不同的变体：

-   `没有[…]]）`就像`全部（[…]]）`，但实践和拒绝调换。所有的承诺都需要被拒绝——拒绝成为实现价值，反之亦然。
-   `任何（[…]]）`就像`全部（[…]]）`但它忽略了任何拒绝，所以只有一个需要完成，而不是_全部的_他们。
-   `首先（…]）`就像是一场赛跑`任何（[…]]）`也就是说，一旦第一个承诺实现，它就会忽略任何拒绝和履行。
-   `最后[…]）`就像`首先（…]）`但只有最新的成就才是胜利。

一些承诺抽象库提供这些，但您也可以使用承诺机制来定义它们，`赛跑[…]）`和`全部（[…]]）`。

例如，以下是我们如何定义`首先（…]）`：

```js
// polyfill-safe guard check
if (!Promise.first) {
	Promise.first = function(prs) {
		return new Promise( function(resolve,reject){
			// loop through all promises
			prs.forEach( function(pr){
				// normalize the value
				Promise.resolve( pr )
				// whichever one fulfills first wins, and
				// gets to resolve the main promise
				.then( resolve );
			} );
		} );
	};
}
```

**注：**本文实现的`首先（…）`不拒绝，如果所有的承诺拒绝，它只是悬挂，很像`承诺（赛跑）`做.如果需要，您可以添加额外的逻辑来跟踪每个承诺拒绝，如果所有拒绝，调用`reject()`论主要承诺。我们将把它作为读者的练习。

### 并行迭代

有时你想迭代一个承诺列表，并对所有的任务执行一些任务，就像你可以用同步做的那样。`阵列`S（例如，`foreach（..）`，`地图（…）`，`一些（…）`，和`每（…）`）。如果对每个承诺执行的任务基本上是同步的，那么这些工作很好，就像我们使用的那样。`foreach（..）`在前一段代码中。

但如果任务基本上都是异步的，或可以/应该执行的同时，您可以使用这些工具的异步版本的许多图书馆提供。

例如，让我们考虑异步。`地图（…）`实用工具`阵列`值（可能是承诺或其他任何事情），加上一个函数（任务）来执行对每个。`地图（…）`本身返回的履行价值是一个承诺。`阵列`认为（在相同的映射顺序）从每个任务的异步实现价值：

```js
if (!Promise.map) {
	Promise.map = function(vals,cb) {
		// new promise that waits for all mapped promises
		return Promise.all(
			// note: regular array `map(..)`, turns
			// the array of values into an array of
			// promises
			vals.map( function(val){
				// replace `val` with a new promise that
				// resolves after `val` is async mapped
				return new Promise( function(resolve){
					cb( val, resolve );
				} );
			} )
		);
	};
}
```

**注：**在这个实现中`地图（…）`，你不能拒绝的信号同步，但同步异常/错误发生在回调（映射`CB（..）`），主要`承诺。地图（…）`退回的诺言会拒绝。

让我们举例说明`地图（…）`有一系列的承诺（而不是简单的价值观）：

```js
var p1 = Promise.resolve( 21 );
var p2 = Promise.resolve( 42 );
var p3 = Promise.reject( "Oops" );

// double values in list even if they're in
// Promises
Promise.map( [p1,p2,p3], function(pr,done){
	// make sure the item itself is a Promise
	Promise.resolve( pr )
	.then(
		// extract value as `v`
		function(v){
			// map fulfillment `v` to new value
			done( v * 2 );
		},
		// or, map to promise rejection message
		done
	);
} )
.then( function(vals){
	console.log( vals );	// [42,84,"Oops"]
} );
```

## 保证API概述

让我们回顾6`承诺`我们已经看到的API在本章中以零碎的形式展开。

**注：**以下仅为6 API是土生土长的，但也有符合规范的polyfills（不只是延长保证图书馆）可以定义`承诺`和所有相关的行为，你甚至可以在pre-es6浏览器使用本地的承诺。其中一个是“本地承诺只polyfill”（<http://github.com/getify/native-promise-only>），我写的！

### 新的承诺（..）构造函数

这个_揭示构造函数_许诺（…）`必须与`新的`并且必须提供同步/立即调用的函数回调。这个功能是通过两个函数回调作为承诺的分辨能力。我们通常给这些东西贴上标签。`决心（…）`和`拒绝（…）`：`拒绝（…）

```js
var p = new Promise( function(resolve,reject){
	// `resolve(..)` to resolve/fulfill the promise
	// `reject(..)` to reject the promise
} );
```

`只是拒绝承诺，但`决心（…）`要么履行诺言，要么拒绝它，取决于它通过了什么。如果`决心（…）`通过直接的，不答应，非thenable价值，并承诺与价值实现。`但如果

决心（…）`通过一个真正的承诺或thenable价值，价值是展开递归，无论其最终决议/状态将由承诺采取。`承诺。决心（…）和承诺。拒绝（…）

### 创建一个已经被拒绝的承诺的捷径是

承诺，拒绝（…）`所以这两个承诺是等价的：`承诺，决心（…）

```js
var p1 = new Promise( function(resolve,reject){
	reject( "Oops" );
} );

var p2 = Promise.reject( "Oops" );
```

`通常是用类似的方法来创造一个已经实现的承诺。`承诺，拒绝（…）`。然而,`承诺，决心（…）`同时打开thenable值（讨论好几次了）。在这种情况下，采用的thenable承诺返回你通过的最后决议，这可能是履行或拒绝：`记住，

```js
var fulfilledTh = {
	then: function(cb) { cb( 42 ); }
};
var rejectedTh = {
	then: function(cb,errCb) {
		errCb( "Oops" );
	}
};

var p1 = Promise.resolve( fulfilledTh );
var p2 = Promise.resolve( rejectedTh );

// `p1` will be a fulfilled promise
// `p2` will be a rejected promise
```

承诺，决心（…）`如果你所传递的已经是一个真正的承诺，它不会做任何事情，它只是直接返回值。所以通话没有开销。`承诺，决心（…）`价值观：你不知道的人`如果你的价值观是一个真正的承诺，你就不知道它的本质。

### 然后（…）抓住（…）

每个承诺实例（**不**这个`承诺`api命名空间）`然后（…）`和`抓住（…）`方法，允许注册实现和拒绝处理程序的承诺。一旦承诺得到解决，将调用一个或另一个这些处理程序，但不是同时调用，并且将异步调用它（参见第1章中的“作业”）。

`然后（…）`接受一个或两个参数，第一个用于执行回调，第二个用于拒绝回调。如果省略或作为非函数值传递，则默认回调分别被替换。默认实现回调只是简单地传递消息，而默认的拒绝回调只是重新抛出（传播）收到错误的原因。

`抓住（…）`只接受拒绝回调作为参数，并自动替换默认实现回调，正如刚才讨论的那样。换句话说，它相当于`然后（NULL，..）`：

```js
p.then( fulfilled );

p.then( fulfilled, rejected );

p.catch( rejected ); // or `p.then( null, rejected )`
```

`然后（…）`和`抓住（…）`也可以创建和返回一个新的承诺，它可以用来表示承诺链流控制。如果履行或拒绝回调有抛出一个异常，返回的承诺被拒绝。如果回调函数返回一个直接的，非承诺，非thenable值，值设置为返回的承诺履行。如果实现处理器专门返回一个承诺或thenable价值，价值是打开成为返回的承诺解决。

### 承诺。[..]承诺，比赛。[..]）

静态的帮手`承诺（全部）]）`和`承诺（赛跑）]）`在6`承诺`API都创建一个承诺作为它们的返回值。这一承诺的解决完全取决于你通过的一系列承诺。

对于`承诺（全部）]）`你所传递的所有承诺都必须兑现兑现的诺言。如果任何承诺被拒绝，主回承诺也立即被拒绝（丢弃任何其他承诺的结果）。为了实现，你得到一个`阵列`所有兑现承诺的实现价值。对于拒绝，你收到的只是第一个拒绝承诺的理由值。这个模式被经典地称为“门”：所有必须在门打开之前到达。

对于`承诺（赛跑）]）`只有第一个解决（履行或拒绝）的诺言“赢了”，不管那个决心是什么，都变成了回报承诺的解决。这种模式被经典地称为“锁存器”：第一个打开锁存器通过。考虑：

```js
var p1 = Promise.resolve( 42 );
var p2 = Promise.resolve( "Hello World" );
var p3 = Promise.reject( "Oops" );

Promise.race( [p1,p2,p3] )
.then( function(msg){
	console.log( msg );		// 42
} );

Promise.all( [p1,p2,p3] )
.catch( function(err){
	console.error( err );	// "Oops"
} );

Promise.all( [p1,p2] )
.then( function(msgs){
	console.log( msgs );	// [42,"Hello World"]
} );
```

**警告：**小心!如果一个空`阵列`通过对`承诺（全部）]）`它会立即完成，但是`承诺（赛跑）]）`将永远挂起永不解决。

6`承诺`API是非常简单和直接的。服务最基本的异步情况下它至少足够好，是一种开始时，重新安排你的代码从回调地狱更好的东西的好地方。

但有很多复杂的应用往往需要异步承诺自己将被限制在解决。在下一节中，我们将深入了解这些局限性，作为希望库获益的动机。

## 承诺的局限性

本节中我们将讨论的许多细节已经在本章中提到过，但我们只需具体回顾这些局限性。

### 序列的错误处理

我们在本章前面详细介绍了承诺错误处理。承诺设计的局限性——它们如何连锁，特别是创建一个非常容易的陷阱，其中一个承诺链中的错误可以被悄悄地忽略。

但还有一些其他的事情要考虑承诺错误。因为承诺链不过是连接在一起的组织承诺，没有实体将整个链称为单个链。_事情_这意味着没有外部的方法来观察可能发生的任何错误。

如果构造一个没有错误处理的承诺链，那么链中的任何错误都会无限地传播到链中，直到被观察到（通过在某个步骤注册拒绝处理程序）。所以，在那个特定的情况下，引用_最后的_链条上的承诺就足够了。`P`在下面的代码段中，因为您可以在那里注册拒绝处理程序，它将被通知任何已传播的错误：

```js
// `foo(..)`, `STEP2(..)` and `STEP3(..)` are
// all promise-aware utilities

var p = foo( 42 )
.then( STEP2 )
.then( STEP3 );
```

虽然它可能似乎微妙的困惑，`P`这里没有指向链中的第一个承诺。`美孚（42）`打电话来，而不是从最后一个承诺，一个来自`然后（第）`呼叫。

同时，在保证链没有步显著做自己的错误处理。这意味着您可以注册一个拒绝错误处理程序。`P`如果链中的任何地方出现错误，都会得到通知：

    p.catch( handleErrors );

但是，如果链中的任何一个步骤确实执行了自己的错误处理（也许隐藏了/从您所能看到的抽象），您的`韩`不会被通知。这可能是你想要的，毕竟，这是一个“处理拒绝”，但它也可能。_不_做你想做的。完全缺乏通知（已经处理过的）拒绝错误的能力是限制某些用例中能力的限制。

它基本上与一个`试试。赶上`它可以捕获异常并简单地吞下它。所以这不是一个限制**唯一的承诺**，但它_是_我们希望有一个解决方法。

不幸的是，很多时候都没有保证承诺链序列中的中间步骤，所以如果没有这样的引用，就不能附加错误处理程序来可靠地观察错误。

### 单值

定义上的承诺只有一个实现价值或一个拒绝理由。在简单的例子中，这不是一个大问题，但在更复杂的场景中，您可能会发现这种限制。

典型的建议是构造一个值包装器（例如`对象`或`阵列`）包含这些多个消息。这种解决方案，但它可以是相当尴尬和包，打开你的信息与你的诺言链每一环节繁琐。

#### 分裂的价值观

有时你可以把这个作为一个信号，你可以/应该把问题分解成两个或更多的承诺。

假设你有一个实用程序`富（…）`产生两个值（`X`和`Y`）异步：

```js
function getY(x) {
	return new Promise( function(resolve,reject){
		setTimeout( function(){
			resolve( (3 * x) - 1 );
		}, 100 );
	} );
}

function foo(bar,baz) {
	var x = bar * baz;

	return getY( x )
	.then( function(y){
		// wrap both values into container
		return [x,y];
	} );
}

foo( 10, 20 )
.then( function(msgs){
	var x = msgs[0];
	var y = msgs[1];

	console.log( x, y );	// 200 599
} );
```

首先，让我们重新安排什么`富（…）`退货，这样我们就不用包装了。`X`和`Y`为一个单一的`阵列`运输价值。相反，我们可以将每个值包装到自己的承诺中：

```js
function foo(bar,baz) {
	var x = bar * baz;

	// return both promises
	return [
		Promise.resolve( x ),
		getY( x )
	];
}

Promise.all(
	foo( 10, 20 )
)
.then( function(msgs){
	var x = msgs[0];
	var y = msgs[1];

	console.log( x, y );
} );
```

是一个`阵列`承诺真的比一个更好`阵列`通过一个承诺的价值观？在语法上，这是不是一个很大的改进。

但这种方法更接近承诺设计理论。它现在更容易在未来重构分裂计算`X`和`Y`分成不同的函数。它更清洁，更灵活，让呼叫代码决定如何编排这两个承诺——使用`承诺（全部）]）`在这里，但肯定不是唯一的选择——而不是把这些细节抽象出来。`富（…）`。

#### 打开/展开争论

这个`变量=…`和`变量为…`任务仍然是笨拙的开销。我们可以使用一些功能的诡计（感谢Reginald Braithwaite，@ raganwald在推特）在辅助工具：

```js
function spread(fn) {
	return Function.apply.bind( fn, null );
}

Promise.all(
	foo( 10, 20 )
)
.then(
	spread( function(x,y){
		console.log( x, y );	// 200 599
	} )
)
```

那有点好！当然，您可以内联功能魔术以避免额外的助手：

```js
Promise.all(
	foo( 10, 20 )
)
.then( Function.apply.bind(
	function(x,y){
		console.log( x, y );	// 200 599
	},
	null
) );
```

这些技巧可能是整洁的，但6为我们更好的回答：解构。该阵列将分配形式看起来像这样：

```js
Promise.all(
	foo( 10, 20 )
)
.then( function(msgs){
	var [x,y] = msgs;

	console.log( x, y );	// 200 599
} );
```

但最重要的是，6提供数组参数解构形式：

```js
Promise.all(
	foo( 10, 20 )
)
.then( function([x,y]){
	console.log( x, y );	// 200 599
} );
```

我们现在已经接受了一个值的每个承诺的咒语，但一直支持我们的样板到最小！

**注：**在6解构形式的更多信息，参见_6与超越_本系列的标题。

### 单分辨率

承诺的最本质的行为之一是，诺言只有一次解决（履行或拒绝）。许多异步用例，你只检索一个值一次，所以这工作很好。

但也有很多异步例融入一个不同的模式，更类似于事件和/或数据流。表面上还不清楚承诺能在这种用例中应用得多好，如果有的话。如果没有在承诺之上的重要抽象，它们将完全无法处理多个值解析。

想象这样一个场景，你可能要发生一系列刺激措施（如异步事件），事实上可以发生多次，如单击按钮。

这可能不会像你想要的那样工作：

```js
// `click(..)` binds the `"click"` event to a DOM element
// `request(..)` is the previously defined Promise-aware Ajax

var p = new Promise( function(resolve,reject){
	click( "#mybtn", resolve );
} );

p.then( function(evt){
	var btnID = evt.currentTarget.id;
	return request( "http://some.url.1/?id=" + btnID );
} )
.then( function(text){
	console.log( text );
} );
```

如果您的应用程序只需要单击一次按钮，那么这里的行为只起作用。如果第二次单击按钮，则`P`诺言已经解决，所以第二个`决心（…）`呼叫将被忽略。

相反，您可能需要颠倒范例，为每个事件触发创建一个完整的新的承诺链：

```js
click( "#mybtn", function(evt){
	var btnID = evt.currentTarget.id;

	request( "http://some.url.1/?id=" + btnID )
	.then( function(text){
		console.log( text );
	} );
} );
```

这种方法将_工作_在这一个全新的承诺序列将被解雇为每一个`“点击”`按钮上的事件。

但除了在事件处理程序内部定义整个承诺链的丑陋之外，这种设计在某些方面违反了关注/功能分离（SOC）的思想。您很可能希望在代码中的不同位置定义事件处理程序，并在其中定义_响应_对事件（承诺链）。在这种模式下，没有辅助机制，这是相当尴尬的。

**注：**阐明这种限制的另一种方法是，如果我们能够构造某种“观察到的”，我们就可以订阅一个承诺链。有了这些抽象概念（如rxjs --图书馆<http://rxjs.codeplex.com/>但是，抽象的东西看起来太重了，你甚至看不到承诺的本质了。如此沉重的抽象带来了重要的问题，例如_可信赖的_正如承诺本身被设计成。我们将回顾附录B中的“可观察”模式。

### 惯性

在自己的代码中开始使用承诺的一个具体障碍是当前存在的所有代码，这些代码还没有实现承诺。如果您有许多基于回调的代码，那么只需保持相同样式的编码就容易得多。

“运动中的代码库（用回调函数）将保持运动（有回调）除非是按一个聪明，知道开发商的承诺。”

承诺提供了一种不同的范式，因此，代码的方法可以从一点点不同，在某些情况下，根本不同。你必须对它有意，因为承诺不会自然而然地从同样的“做代码”的方式中摆脱出来。

考虑一个基于回调的场景，如下所示：

```js
function foo(x,y,cb) {
	ajax(
		"http://some.url.1/?x=" + x + "&y=" + y,
		cb
	);
}

foo( 11, 31, function(err,text) {
	if (err) {
		console.error( err );
	}
	else {
		console.log( text );
	}
} );
```

第一步是将基于回调的代码转换为有保证的代码吗？取决于你的经验。你练习的越多，感觉就越自然。但是，当然，承诺不仅仅是在广告上做广告——没有一个合适的答案——所以责任由你自己决定。

正如我们前面提到过的，我们确实需要一个Ajax应用程序，它是基于承诺感知的，而不是基于回调的，我们可以调用它。`请求（…）`。你可以自己做，就像我们已经做的一样。但有手动定义承诺意识到包装每回调基于效用的开销使得它不太可能你会选择重构承诺意识的编码在所有。

承诺没有对这个限制作出直接的回答。然而，大多数承诺库确实提供了一个助手。但即使没有图书馆，想象这样的帮手：

```js
// polyfill-safe guard check
if (!Promise.wrap) {
	Promise.wrap = function(fn) {
		return function() {
			var args = [].slice.call( arguments );

			return new Promise( function(resolve,reject){
				fn.apply(
					null,
					args.concat( function(err,v){
						if (err) {
							reject( err );
						}
						else {
							resolve( v );
						}
					} )
				);
			} );
		};
	};
}
```

好吧，这不仅仅是一个极小的实用程序。然而，虽然看起来有点吓人，但并不像你想象的那么糟糕。它需要一个函数，它期望一个错误的第一样式回调作为它的最后一个参数，并返回一个新的，它自动创建一个返回的承诺，并为您替换回调，连接到承诺实现/拒绝。

与其浪费太多的时间谈论_怎样_这`承诺，包装（…）`辅助程序，让我们看看如何使用它：

```js
var request = Promise.wrap( ajax );

request( "http://some.url.1/" )
.then( .. )
..
```

哇，那很容易！

`承诺，包装（…）`做**不**作出承诺。它产生一个能产生承诺的功能。从某种意义上说，一个承诺生产函数可以被视为一个“厂承诺。“我提出“promisory”为名称这样的东西（“承诺”+“工厂”）。

将一个回调等功能是一个承诺感知功能的行为有时也被称为“提升”或“promisifying”。但似乎没有一个标准的术语，什么叫合力作用比其他“解禁”功能，所以我喜欢“promisory”更好，我认为这是更具描述性的。

**注：**promisory不是由项。这是一个真正的词，它的定义意味着包含或传递诺言。这正是这些函数所做的，因此它是一个非常完美的术语匹配！

所以，`承诺（ajax）`产生一个`ajax（..）`promisory我们称`request(..)`，这promisory生成Ajax响应承诺。

如果所有的功能都已经promisories，我们不需要自己制造的，所以额外的步骤是一个耻辱的点。但至少包装图案是（通常）可重复的，所以我们可以把它放进一个`承诺，包装（…）`帮助显示我们的承诺编码。

所以回到我们先前的例子，我们需要一个promisory两`ajax（..）`和`富（…）`：

```js
// make a promisory for `ajax(..)`
var request = Promise.wrap( ajax );

// refactor `foo(..)`, but keep it externally
// callback-based for compatibility with other
// parts of the code for now -- only use
// `request(..)`'s promise internally.
function foo(x,y,cb) {
	request(
		"http://some.url.1/?x=" + x + "&y=" + y
	)
	.then(
		function fulfilled(text){
			cb( null, text );
		},
		cb
	);
}

// now, for this code's purposes, make a
// promisory for `foo(..)`
var betterFoo = Promise.wrap( foo );

// and use the promisory
betterFoo( 11, 31 )
.then(
	function fulfilled(text){
		console.log( text );
	},
	function rejected(err){
		console.error( err );
	}
);
```

当然，我们正在进行重构`富（…）`使用我们的新`请求（…）`promisory，我们可以使`富（…）`一个promisory本身，而不是保持基于回调的需要制作和使用后续`betterfoo（..）`promisory。这个决定取决于是否`富（…）`需要保持回调为基础，与代码库的其他部分兼容。

考虑：

```js
// `foo(..)` is now also a promisory because it
// delegates to the `request(..)` promisory
function foo(x,y) {
	return request(
		"http://some.url.1/?x=" + x + "&y=" + y
	);
}

foo( 11, 31 )
.then( .. )
..
```

而6承诺不来船等promisory包装助手，大多数图书馆提供，或者你可以做你自己。无论哪种方式，这种特殊的承诺限制是没有太多痛苦（当然比地狱的痛苦！）。

### 承诺uncancelable

一旦你创建了一个承诺，并为它注册了一个实现和/或拒绝处理程序，如果发生了其他的事情使这个任务变得毫无意义，那么没有什么可以阻止这个进程。

**注：**许多承诺抽象库提供了取消承诺的便利，但这是一个可怕的想法！许多开发商希望许诺本身是由外部的消除能力，但问题是，它会让一个承诺一个消费者/观察者影响其他一些消费者的观察能力同样的承诺。这违反了未来价值的信任（外部性），而且是“在距离“反模式作用的体现（[http://en.wikipedia.org/wiki/action_at_a_distance_% 28computer_pr](http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29)）。无论多么有用看来，它会引导你回到相同的噩梦为回调。

考虑我们的承诺超时场景从早期：

```js
var p = foo( 42 );

Promise.race( [
	p,
	timeoutPromise( 3000 )
] )
.then(
	doSomething,
	handleError
);

p.then( function(){
	// still happens even in the timeout case :(
} );
```

“超时”是承诺的外在内容。`P`，所以`P`自己一直在走，我们可能不想要。

一种选择是创回调定义你的决议：

```js
var OK = true;

var p = foo( 42 );

Promise.race( [
	p,
	timeoutPromise( 3000 )
	.catch( function(err){
		OK = false;
		throw err;
	} )
] )
.then(
	doSomething,
	handleError
);

p.then( function(){
	if (OK) {
		// only happens if no timeout! :)
	}
} );
```

这是丑陋的。它有效，但远非理想。一般来说，你应该尽量避免这种情况。

但是如果你不能，这个解决方案的丑陋应该是一个线索。_取消_是一个功能，属于更高层次的抽象之上的承诺。我建议您希望向抽象库提供帮助，而不是自己动手。

**注：**我的_asynquence_承诺抽象库提供了这样一个抽象和`abort()`序列的能力，所有这些将在附录A中讨论。

单一的承诺并不是真正的流量控制机制（至少不是非常有意义的），这正是什么？_取消_指的是；这就是为什么承诺取消会觉得很尴尬。

相比之下，一连串的承诺被集体地结合在一起——我喜欢称之为“序列”——_是_流量控制的表达，因此它适合取消是在那个级别的抽象定义。

没有个人的承诺应该是可撤销的，但这一明智的_序列_要取消，因为你不传一个序列作为一个单一的不变的价值就像你做一个承诺。

### 保证性能

这种特殊的限制既简单又复杂。

比较多少件采用异步任务链与承诺链基本回调运动，它是明确的承诺有一个公平一点的事情，这意味着他们天生就至少慢了一点。回想起刚刚的信任保证承诺提供简单的列表，而特设的解决方案代码你要的层上的回调来达到同样的保护。

更多的工作要做，更多的警卫来保护，意味着承诺。_是_慢相比赤裸裸的、不可信任的回调。这是显而易见的，而且很简单的包装你的大脑。

但是要慢多少呢？好...事实证明，这是一个绝对难以回答的问题。

坦白地说，这是一种苹果对橙子的比较，所以这可能是一个错误的问题。实际上，您应该比较一个手动分层的自动回调系统是否比承诺实现更快。

如果承诺有一个合法的性能限制，它更多的是，他们真的不提供一项选择，信任保护你想要/需要与否，你让他们，永远。

然而，如果我们承认诺言一般是_稍微慢_比其非承诺，不可信的回调当量--假设有地方你觉得你可以证明信任的缺乏，这就意味着承诺应避免一刀切，好像你的整个应用程序是由什么但必须绝对最快的代码可能吗？

理智检查：如果您的代码是合法的，**JavaScript是这样的任务的正确语言吗？**JavaScript可以优化运行应用程序非常performantly（见5章和6章）。但过于关注承诺小性能的权衡，在所有的好处他们提供光，_真正地_合适吗？

另一个微妙的问题是承诺。_一切_异步，这意味着一些立即（同步）完成步骤还是推迟到工作的下一步进展（见1章）。这意味着，它可能是一个序列的任务可以完成承诺永远比同序列接上回调稍慢。

当然，这里的问题是：这些潜在的失误在性能的细微部分吗？_值得的_我们在这一章所阐述的承诺的所有其他利益？

我的看法是，在几乎所有的情况下，你可能会认为保证性能足够慢以而言，它实际上是一个反模式优化掉承诺的可信性和可组合性的好处，避免它们。

相反，您应该默认在代码库中使用它们，然后配置和分析应用程序的热（关键）路径。是承诺_真正地_是一个瓶颈，还是仅仅是理论上的减速？只有_然后_有实际有效的基准（见第6章），有责任和谨慎地在刚刚确定的关键领域内作出承诺吗？。

承诺慢一点，但是作为交换你得到很多信任，不该预测，和组合性建。也许限制实际上不是他们的表现，而是你对他们利益的缺乏感知？

## 回顾

承诺是可怕的。使用它们。他们解决_控制反转_问题困扰着我们的回调代码。

他们不会摆脱

保证连锁店也开始地址（当然不是绝对）以连续的方式更好的表达方式异步流，这有助于我们的大脑计划保持异步js代码更好。我们将看到一个更好的解决方案。_那个_下一章的问题！
