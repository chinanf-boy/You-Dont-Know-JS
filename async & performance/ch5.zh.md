
# 你不知道JS：异步性能

# 第5章程序性能

到目前为止，这本书都是关于如何更有效地利用异步模式的。但是我们还没有直接讨论为什么异步对JS很重要。最明显的原因是**性能**。

例如，如果您有两个Ajax请求，并且它们是独立的，但是您需要等待它们在完成下一项任务之前完成，您有两个选项用于建模该交互：串行和并发。

您可以完成第一个请求并等待启动第二个请求直到第一次完成。或者，正如我们已经看到的两个承诺和生成器，您可以使两个请求“并行”，并表示“门”，等待他们两个，然后继续前进。

显然，后者通常要比前者更高性能。更好的性能通常会带来更好的用户体验。

异步（交错并发）甚至可以改善性能感知，即使整个程序仍然需要相同的时间完成。用户对性能的感知是每一点——如果不是更多的话！——和实际可测量的性能一样重要。

现在我们想超越本地化的异步模式，在程序级别上讨论一些更大的图片性能细节。

**注：**您可能会对微性能问题感到好奇，比如`+ +`或`+ +`快。我们将在下一章“基准测试和调优”中查看这些性能细节。

## 网络工作者

如果您有处理密集型任务，但不希望它们在主线程上运行（这可能会减慢浏览器/ UI），您可能希望JavaScript可以以多线程方式运行。

在第1章中，我们详细讨论了JavaScript是如何单线程的。这仍然是真的。但是一个线程并不是组织程序执行的唯一方法。

想象把你的程序分成两部分，在主UI线程上运行其中的一块，然后在完全独立的线程上运行另一块。

这样的架构会带来什么样的关注？

首先，您想知道在单独的线程上运行是否意味着它并行运行（在多个CPU /内核系统上），这样第二个线程上的长时间运行进程就可以了。**不**阻止主程序线程。否则，“虚拟线程”不会超过我们已经在JS异步并发多效益。

你想知道这两个程序是否能访问相同的共享范围/资源。如果他们这样做，那么你所有的问题，多线程的语言（java、C++等）处理，如需合作或抢先锁（互斥，等）。那是一件额外的工作，不应该轻易地承担。

或者，如果不能共享范围/资源，则希望知道这两个部分如何“通信”。

所有这些都是值得考虑的问题，因为我们探索了一个添加到Web平台上的特性，HTML5被称为“Web工作者”，这是浏览器（又名主机环境）的一个特性，实际上与JS语言本身几乎没有关系。也就是说，JavaScript没有_目前_有支持线程执行的特性。

但是像您的浏览器这样的环境可以轻松地提供JavaScript引擎的多个实例，每个实例都在自己的线程上，并允许您在每个线程中运行不同的程序。程序中的每一个单独的线程部分称为“（Web）”。这种类型的并行称为“任务并行”，重点是将程序块分割为并行运行。

从您的主js程序（或另一个工人），实例化一个这样的工人：

```js
var w1 = new Worker( "http://some.url.1/mycoolworker.js" );
```

URL应该指向js文件的位置（不是HTML页面！）它打算装进一个工人身上。然后，浏览器将旋转一个单独的线程，并让该文件作为该线程中的独立程序运行。

**注：**使用这种URL创建的工人称为“专用工人”，但不提供一个外部文件的URL，您还可以通过提供一个URL（另一个HTML5特性）创建一个“内联工人”；本质上它是一个存储在一个（二进制）值中的内联文件。然而，斑点超出了我们将在这里讨论的范围。

工作人员不共享任何范围或资源与对方或主程序-这将导致所有的噩梦线程编程的前沿-而是有一个基本的事件消息传递机制连接他们。

这个`W1`“工作对象”是一个事件侦听器和触发器，它允许您订阅由工人发送的事件以及向工人发送事件。

下面是如何监听事件（实际上是固定的）`“消息”`事件）：

```js
w1.addEventListener( "message", function(evt){
	// evt.data
} );
```

你可以发送`“消息”`事件给工人：

```js
w1.postMessage( "something cool to say" );
```

在内部，消息传递是完全对称的：

```js
// "mycoolworker.js"

addEventListener( "message", function(evt){
	// evt.data
} );

postMessage( "a really cool reply" );
```

注意，一个专用的工作者与创建它的程序是一对一的关系。T`“消息”`事件不需要任何消歧义，因为我们确信它只能来自这一对一的关系，无论是来自工人还是主页。

通常主网页应用程序创建的工人，但工人可以实例化自己的童工（S）-被称为subworkers --是必要的。有时这是代表这样的细节，一种“主人”的工人，会产生其他工人处理任务有用的部分。不幸的是，在写这篇文章的时候，浏览器还不支持subworkers，而火狐也。

要立即从创建它的程序中杀掉一个工人，请调用`terminate()`关于工人对象（比如`W1`在前一段中）。突然终止一个工作线程不会给它任何机会完成工作或清理任何资源。它类似于关闭一个浏览器选项卡来杀死一个页面。

如果您有两个或多个页面（或多个同页的选项卡）！在试图从同一个文件URL中创建一个工人的浏览器中，这些浏览器实际上将成为完全独立的工作人员。不久，我们将讨论一种“分享”一个工人的方法。

**注：**它看起来像是一个恶意的或无知的js程序，它可以通过生成成百上千的工人来完成对系统的拒绝服务攻击，看起来每个人都有自己的线程。虽然这确实是一个保证，一个工人将结束在一个单独的线程，这个保证不是无限的。系统可以自由决定它真正想要创建多少实际的线程/ CPU /核心。无法预测或保证有多少用户可以访问，尽管许多人认为它至少与可用的CPU /内核数量一样多。我认为最安全的假设是除了主UI线程之外至少还有一个线程，但这就是它。

### 工作环境

在工作人员内部，您不能访问主程序的任何资源。这意味着您不能访问它的任何全局变量，也不能访问页面的DOM或其他资源。记住：这是一个完全不同的线程。

你可以，但是，执行网络操作（Ajax，WebSockets）并设置定时器。此外，该人员还可以访问几个重要的全局变量/特性的自身副本，包括`领航员`，`位置`，`JSON`，和`应用程序缓存`。

您还可以将额外的js脚本加载到您的工作人员中，使用`importscripts（..）`：

```js
// inside the Worker
importScripts( "foo.js", "bar.js" );
```

这些脚本是同步加载的，这意味着`importscripts（..）`调用将阻塞其他执行器的执行，直到文件完成加载和执行为止。

**注：**也有一些关于曝光的讨论。`<canvas>`API的工人，并结合具有油画是transferables（见“数据传输”一节），允许工人执行更复杂的螺纹图形处理，可为高性能游戏是有用的（WebGL）和其他类似的应用。尽管这种情况在任何浏览器中都不存在，但它很可能在不久的将来发生。

网络工作者有哪些常见的用途？

-   处理密集的数学计算
-   大数据集排序
-   数据操作（压缩、音频分析、图像像素操作等）
-   高话务网络通信

### 数据传输

您可能注意到其中大多数用途的一个共同特点，即它们需要大量的信息通过事件机制在线程之间的屏障间传输，可能是在两个方向上。

在工作初期，将所有数据到一个字符串的值是唯一的选择。除了对双向序列化的速度损失，其他主要负，数据被复制，这意味着内存使用增加一倍（和垃圾收集的后续流失）。

谢天谢地，我们现在有几个更好的选择。

如果你传递一个对象，一个所谓的“结构化克隆算法”（[https://developer.mozilla.org/en-us/docs/web/guide/api/dom/the_structured_clone_algorithm](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm)用于复制/复制另一端的对象。该算法相当复杂，甚至可以处理带有循环引用的复制对象。对字符串/字符串的性能惩罚没有支付，但是我们仍然使用这种方法复制内存。这是因为在IE10和上面的支持，以及其他所有主要浏览器。

一个更好的选择，特别是对于较大的数据集，是“可转移对象”（[http://updates.html5rocks.com/2011/12/transferable-objects-lightning-fast](http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast)）。发生的情况是对象的“所有权”被转移，但数据本身并没有移动。一旦将对象转移给一个工作者，它在起始位置是空的或无法访问的——这消除了在共享范围上线程编程的危害。当然，所有权转移可以双向进行。

实际上，您不需要做太多的工作来选择可转移对象；任何实现可转换接口的数据结构（[HTTPS](https://developer.mozilla.org/en-US/docs/Web/API/Transferable)）将自动以这种方式传输（支持Firefox和Chrome）。

例如，类型数组如下`uint8array`（见_6与超越_这个系列的标题是“transferables）。“这是你要发送一个转让对象的使用`PostMessage（..）`：

```js
// `foo` is a `Uint8Array` for instance

postMessage( foo.buffer, [ foo.buffer ] );
```

第一个参数是原始缓冲区，第二个参数是一个转移列表。

不支持可转移对象的浏览器简单地降级为结构化克隆，这意味着降低性能，而不是彻底的功能破坏。

### 共享的工人

如果你的网站或应用程序允许加载多个标签相同的页面（共同的特征），你很可能想通过防止重复的献身者减少他们的系统资源的使用情况；在这方面，最常见的有限的资源是一个socket的网络连接、浏览器限制同时连接数为单主机。当然，限制客户端的多个连接也简化了服务器资源需求。

在这种情况下，创建一个单一的集中式工作人员，您的站点或应用程序的所有页面实例都可以_分享_很有用。

那叫A`sharedworker`像这样创建（支持此项仅限于Firefox和Chrome）：

```js
var w1 = new SharedWorker( "http://some.url.1/mycoolworker.js" );
```

因为一个共享的工作人员可以连接到或来自你站点上的多个程序实例或页面，所以工作人员需要一种方法来知道消息来自哪个程序。这种独特的标识称为“端口”——思考网络套接字端口。因此调用程序必须使用`港口`通信工作者的对象：

```js
w1.port.addEventListener( "message", handleMessages );

// ..

w1.port.postMessage( "something cool" );
```

此外，端口连接必须初始化为：

```js
w1.port.start();
```

在共享的工作人员内部，必须处理一个额外事件：`“连接”`。此事件提供端口。`对象`对于那个特殊的连接。保持多个连接独立的最方便的方法是使用闭包（参见_范围和关闭_本系列的标题）`港口`如下图所示，该事件为处理器中定义的连接侦听和传输`“连接”`事件：

```js
// inside the shared Worker
addEventListener( "connect", function(evt){
	// the assigned port for this connection
	var port = evt.ports[0];

	port.addEventListener( "message", function(evt){
		// ..

		port.postMessage( .. );

		// ..
	} );

	// initialize the port connection
	port.start();
} );
```

除了这种区别之外，共享和专用的工作人员具有相同的能力和语义。

**注：**如果其他端口连接仍然存在，共享端口在端口连接终止时幸存，而专用的工作者在终止连接到其启动程序时终止。

### polyfilling网络工作者

Web工作者对于并行运行js程序是非常有吸引力的性能。然而，您可能处于一个需要在缺少支持的旧浏览器中运行代码的位置。因为工人是一个API而不是语法，他们可以polyfilled，某种程度上。

如果浏览器不支持工作人员，那么就很难从性能角度伪造多线程。iframe是常见的思想提供了一个并行环境，但在所有现代浏览器实际上运行在同一线程的主网页，所以他们没有足够的伪造的并行性。

正如我们在1章详细，js的异步性（不平行）来自事件循环队列，这样可以迫使伪造工人要异步定时器使用（`setTimeout（..）`等等）。然后你只需要提供一个polyfill为工人的API。这里列出了一些（[http：/ / GitHub。COM / Modernizr / Modernizr /维基/ HTML5跨浏览器polyfills #网络工作者](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers)）但坦率地说，没有一个看上去很棒。

我已经写了一个polyfill草图`工人`在这里（<https://gist.github.com/getify/1b26accb1a09aa53ad25>）。这是基本的，但它应该完成简单的工作。`工人`支持，因为双向消息传递工作正常，以及`“误差”`处理。您可能还可以用更多的特性扩展它，例如`terminate()`或伪造的共享工人，如你所见。

**注：**你不能假同步阻塞，所以这就不允许使用polyfill`importscripts（..）`。另一个选项可能是解析和转换工作人员的代码（Ajax加载一次），以处理对某个异步形式的重写。`importscripts（..）`polyfill，也许与承诺感知接口。

## SIMD

单指令多数据（SIMD）是一种形式的“数据并行，”与“任务并行”的网络工作者，因为重要的不是程序的逻辑块是并行的，而是多个比特被并行处理数据。

对于SIMD，线程不提供并行性。取而代之的是，现代CPU用数字的“向量”提供SIMD能力——想想：键入专门的数组——以及可以并行操作所有数字的指令；这些都是利用指令级并行性的低级操作。

向JavaScript公开SIMD能力的努力主要是由英特尔发起的。<https://01.org/node/1495>），即Mohammad Haghighat（在撰写本文时），在Firefox和Chrome团队合作。SIMD在一个很好的机会，让它变成一个JavaScript的未来修订早期标准轨道，在ES7的时间表可能。

SIMD JavaScript

这样的并行数学处理对数据密集型应用程序（信号分析、矩阵操作等）的性能好处是显而易见的！

在撰写本文时，SIMD API的早期建议形式如下所示：

```js
var v1 = SIMD.float32x4( 3.14159, 21.0, 32.3, 55.55 );
var v2 = SIMD.float32x4( 2.1, 3.2, 4.3, 5.4 );

var v3 = SIMD.int32x4( 10, 101, 1001, 10001 );
var v4 = SIMD.int32x4( 10, 20, 30, 40 );

SIMD.float32x4.mul( v1, v2 );	// [ 6.597339, 67.2, 138.89, 299.97 ]
SIMD.int32x4.add( v3, v4 );		// [ 20, 121, 1031, 10041 ]
```

这里显示了两种不同的向量数据类型：32位浮点数和32位整数。您可以看到，这些向量的大小精确到四个32位元素，因为这与大多数现代CPU中可用的SIMD向量大小（128位）相匹配。我们也有可能看到`x8`（或更大的！）未来这些API的版本。

除了`mul()`和`（）`许多其他操作可能包括在内，例如`sub()`，`div()`，`abs()`，`neg()`，`sqrt()`，`reciprocal()`，`reciprocalsqrt()`（算术），`shuffle()`（重新排列向量元素），`and()`，`or()`，`xor()`，`not()`（逻辑），`equal()`，`greaterthan()`，`lessthan()`（比较），`shiftleft()`，`shiftrightlogical()`，`shiftrightarithmetic()`（轮班），`fromfloat32x4()`，和`fromint32x4()`（转换）。

**注：**有一个官方的“prollyfill”（希望，期待，未来靠polyfill）为SIMD功能可用（<https://github.com/johnmccutchan/ecmascript_simd>）这说明了计划中的SIMD能力比我们在本节中所演示的要多得多。

## asm.js

“ASM”<http://asmjs.org/>）是一个高度优化的JavaScript语言的子集的一个标签。通过谨慎地避免某些机制和模式_坚硬的_优化（垃圾收集、胁迫等），asm.js-styled代码可以通过JS引擎认可并给予特别的关注和积极的低级别的优化。

不同于其他的程序性能的机制，在本章中讨论，asm.js并不一定需要采用JS语言规范。那里_是_一个asm.js规范（<http://asmjs.org/spec/latest/>）但它主要用于跟踪一组商定的优化候选推断，而不是JS引擎的一组需求。

目前没有任何新语法正在被提议。相反，asm.js建议认识到现有标准的js的语法，符合asm.js规则让引擎实现自己相应的优化方法。

有一些分歧的浏览器厂商如何asm.js应该在程序激活。早期版本的asm.js实验要求`“使用ASM”；`pragma（类似于严格的模式`“严格使用”；`）帮助线索的JS引擎来找asm.js优化机会和提示。有人断言，asm.js应该只是一套启发式引擎自动识别没有作者做任何额外的费用，这意味着现有的程序在理论上可以不做任何特殊的asm.js-style优化效益。

### 如何优化与asm.js

了解asm.js优化的第一件事是在类型和强制（见_类型与语法_本系列的标题）。如果JS引擎跟踪多个不同类型的变量中的值通过各种操作，这样就可以根据需要处理的强制类型之间，有很多额外的工作，使程序优化的次优。

**注：**我们要在这里用asm.js-style代码演示的目的，但要知道，这不是普遍预计你会作者这样的代码用手。asm.js更打算从其他工具编译的目标，如Emscripten（<https://github.com/kripken/emscripten/wiki>）。它当然可以写你自己的asm.js代码，但这通常是一个坏主意，因为代码是非常低的水平和管理可以是非常耗时和容易出错的。然而，有可能的情况下，你想手动调整你的代码asm.js优化的目的。

有一些“技巧”，你可以使用提示一个asm.js-aware JS引擎变量/操作的类型是什么，这样就可以跳过这些强制跟踪步骤。

例如:

```js
var a = 42;

// ..

var b = a;
```

在那个节目中，`B =一个`赋值使变量的类型散度敞开。然而，它可以写成：

```js
var a = 42;

// ..

var b = a | 0;
```

在这里，我们使用了`|`（二进制或“）带值`零`除了确定它是32位整数之外，它对值没有任何影响。代码运行在一个正常的JS引擎工作得很好，但是当运行在一个asm.js-aware JS引擎_可以_信号`B`应始终被视为32位整数，因此可以跳过强制跟踪。

同样，两变量间的加法运算可以被限制到一个更高性能的整数加法（代替浮点数）：

```js
(a + b) | 0
```

再次，在asm.js-aware JS引擎可以看到提示和推断`+`操作应该是32位整数相加，因为整个表达式的最终结果将自动为32位整数。

### asm.js模块

js中最大的缺点之一是内存分配、垃圾收集。_6与超越_本系列的标题。

一个asm.js模块，你需要明确地传递一个严格符合命名空间--这是指在规格为`标准库`，因为它代表标准库需要进口必要的符号，而不是仅仅使用全局变量通过词法范围。在基本情况下，`窗口`对象是可接受的。`标准库`asm.js模块为目的的对象，但你可以或许应该构建一个更受限制。

你也必须申报“堆”--这是一个梦幻的保留点内存变量已经可以使用没有要求更多的内存或释放先前使用的内存，和传递，使asm.js模块不需要做任何会造成记忆流失；它可以用预留空间。

“堆”很可能是类型化的。`ArrayBuffer`，例如：

```js
var heap = new ArrayBuffer( 0x10000 );	// 64k heap
```

使用预留的64K的二进制空间，一个asm.js模块可以存储和检索值，缓冲区没有任何内存分配和垃圾收集的处罚。例如，`堆`缓冲区可以在模块内使用，以支持像这样的64位浮点值数组：

```js
var arr = new Float64Array( heap );
```

好吧，让我们做一个快速的，一个asm.js-styled模块来说明如何将这些碎片拼凑在一起可笑的例子。我们将定义一个`富（…）`那就开始了。`X`和结束（`Y`范围的整数，并计算范围内值的所有内部相邻乘法，然后最后将这些值平均相加：

```js
function fooASM(stdlib,foreign,heap) {
	"use asm";

	var arr = new stdlib.Int32Array( heap );

	function foo(x,y) {
		x = x | 0;
		y = y | 0;

		var i = 0;
		var p = 0;
		var sum = 0;
		var count = ((y|0) - (x|0)) | 0;

		// calculate all the inner adjacent multiplications
		for (i = x | 0;
			(i | 0) < (y | 0);
			p = (p + 8) | 0, i = (i + 1) | 0
		) {
			// store result
			arr[ p >> 3 ] = (i * (i + 1)) | 0;
		}

		// calculate average of all intermediate values
		for (i = 0, p = 0;
			(i | 0) < (count | 0);
			p = (p + 8) | 0, i = (i + 1) | 0
		) {
			sum = (sum + arr[ p >> 3 ]) | 0;
		}

		return +(sum / count);
	}

	return {
		foo: foo
	};
}

var heap = new ArrayBuffer( 0x1000 );
var foo = fooASM( window, null, heap ).foo;

foo( 10, 20 );		// 233
```

**注：**这asm.js例子是手工创作的例证，所以这并不代表将从目标asm.js编译工具产生相同的代码。但它确实表明了asm.js代码的典型性，尤其是类型提示和使用的`堆`临时变量存储缓冲器。

第一次打电话给`fooasm（..）`让我们asm.js模块与`堆`分配.结果是`富（…）`函数，我们可以多次调用必要的。那些`富（…）`电话应该由asm.js-aware JS引擎专门优化。重要的是，前面的代码是完全标准的JS会运行得很好（没有特殊优化）在non-asm.js引擎。

显然，限制，使asm.js代码优化降低这样的代码可能使用显著性。asm.js未必是通用的优化设置为任何给定的JS程序。相反，它的目的是提供一种优化的方法来处理专门的任务，如密集的数学运算（例如，用于图形处理的游戏）。

## 回顾

这本书的前四章是基于异步编码模式给你写代码的能力更高性能的前提下，这是一个非常重要的改进。但异步行为只能到此为止了，因为它从根本上仍然绑定到一个单一的事件循环线。

因此，在本章中，我们讨论了几个程序级机制，以进一步提高性能。

网站工作人员让你运行一个js文件（即程序）在使用异步事件的线程之间的消息一个单独的线程。他们长期或资源密集型任务卸载到不同的线程中的精彩，留下主UI线程更敏感。

SIMD建议将CPU级并行数学操作映射到高性能数据并行操作的JavaScript API，如大数据集上的数字处理。

最后，asm.js介绍JavaScript代码，避免了优化部分JS的努力的一个小的子集（如垃圾收集和胁迫），让JS引擎识别和运行这些代码通过激进的优化。asm.js可以撰写的，但这是非常繁琐和容易出错的，类似于手工编写的汇编语言（因此得名）。相反，主要的意图是asm.js将是一个很好的目标，交叉编译其他高度优化的程序语言——例如，Emscripten（<https://github.com/kripken/emscripten/wiki>）transpiling C / C++ JavaScript。

虽然在本章中没有详细讨论，但在JavaScript的早期讨论中，甚至包括直接线程功能的近似（甚至不仅仅隐藏在数据结构API中）还有更激进的想法。这是否真的发生了，或者我们看到更多的并行性在幕后悄悄地进入JS，js中优化的程序级性能的未来看起来真的是真的。_有前途的_。
