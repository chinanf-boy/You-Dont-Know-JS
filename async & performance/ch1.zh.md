
# 你不知道JS: 异步性能

# 第1章: 异步: 现在和以后

像JavaScript这样的编程语言中最重要也是经常被误解的部分之一是如何在一段时间内表达和操作程序行为ㄢ

这不仅仅是从一开始就发生了什么ㄢ`对于`循环到一个`对于`循环,这当然需要_一些时间_(微秒至毫秒)完成ㄢ它是关于当程序的一部分运行时会发生什么ㄢ_现在_另外,程序的另一部分运行_后来_-之间有差距_现在_和_后来_你的程序没有主动执行的地方ㄢ

实际上,所有编写过的非平凡程序(尤其是js)都必须以某种方式来管理这种间隙,无论是等待用户输入ㄡ请求数据库或文件系统的数据ㄡ在网络上发送数据ㄡ等待响应,或是在固定的时间间隔(如动画)执行重复的任务ㄢ在所有这些不同的方式中,您的程序必须在时间间隔内管理状态ㄢ正如他们在伦敦(地铁门和站台之间的裂缝)所说的那样: "注意差距ℽㄢ

事实上,两者之间的关系_现在_和_后来_程序的一部分是异步编程的核心ㄢ

异步编程从JS开始就已经存在了,这是肯定的ㄢ但大多数JS开发人员从未真正仔细地考虑过如何在程序中生成它,以及如何探索各种各样的程序ㄢ_其他_处理方法ㄢ这个_足够好_方法一直是谦虚的回调函数ㄢ许多在这一天将坚持回调是绰绰有余ㄢ

但JS继续在规模和复杂性的增长,以满足不断扩大的一个一流的编程语言,运行在浏览器和服务器之间和每一个可以想象的装置要求,痛苦使我们管理异步日益削弱,他们哭了,都更有能力ㄡ更有道理ㄢ

虽然现在这一切看起来都很抽象,但我保证我们在继续这本书的过程中会更彻底ㄡ更具体地处理它ㄢ我们将探讨异步JavaScript编程在接下来的几章,各种新兴技术ㄢ

但在我们到达那里之前,我们必须更深入地了解异步是什么,以及它是如何在JS中运行的ㄢ

## 大块的程序

你可以把你的js程序写在一个_js_文件,但你的程序几乎肯定是由几个块组成的,其中只有一个是要执行的ㄢ_现在_其余的将执行_后来_ㄢ最常用的单位_块_是的`功能`ㄢ

对于JS来说,大多数开发人员的问题似乎是_后来_不严格且立即发生ㄢ_现在_ㄢ换句话说,不能完成的任务_现在_根据定义,将异步完成,因此我们不会像您直觉地期望或希望的那样具有阻塞行为ㄢ

考虑: 

```js
// ajax(..) is some arbitrary Ajax function given by a library
var data = ajax( "http://some.url.1" );

console.log( data );
// Oops! `data` generally won't have the Ajax results
```

您可能已经意识到标准Ajax请求并不是同步完成的,这意味着`ajax(..)`函数还没有返回赋给的任何值ㄢ`数据`变量ㄢ如果`ajax(..)` _能够_阻止直到反应回来,然后`数据= ..`作业会很好ㄢ

但我们不是这样做Ajax的ㄢ我们进行异步Ajax请求ㄢ_现在_我们将不会得到结果,直到_后来_ㄢ

最简单(但绝对不但是,甚至绝对最好)!"等待ℽ的方式_现在_直到_后来_是使用一个函数,通常称为回调函数: 

```js
// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", function myCallbackFunction(data){

	console.log( data ); // Yay, I gots me some `data`!

} );
```

**警告: **您可能听说过,同步Ajax请求是可能的ㄢ虽然这在技术上是正确的,但在任何情况下都不应该这样做,因为它会锁定浏览器UI(按钮ㄡ菜单ㄡ滚动等),并阻止任何用户交互ㄢ这是一个可怕的想法,应该永远避免ㄢ

在你抗议的分歧,不,你想避免回调的混乱_不_阻塞的理由,同步ajaxㄢ

例如,考虑这个代码: 

```js
function now() {
	return 21;
}

function later() {
	answer = answer * 2;
	console.log( "Meaning of life:", answer );
}

var answer = now();

setTimeout( later, 1000 ); // Meaning of life: 42
```

这个程序有两个块: 要运行的东西_现在_以及那些将要运行的东西_后来_ㄢ很明显,这两个块是什么,但是我们要超级显式: 

现在:

```js
function now() {
	return 21;
}

function later() { .. }

var answer = now();

setTimeout( later, 1000 );
```

后来: 

```js
answer = answer * 2;
console.log( "Meaning of life:", answer );
```

这个_现在_块立即运行,一旦你执行你的程序ㄢ但`setTimeout(..)`还设置一个事件(超时)发生ㄢ_后来_所以,内容`later()`函数将在稍后时间执行(从现在起1000毫秒)ㄢ

任何时候把一段代码包装成一个`功能`并指定它应该响应某个事件执行(定时器ㄡ鼠标单击ㄡAjax响应等),您正在创建一个_后来_您的代码块,从而引入异步到您的程序ㄢ

### 异步机

周围没有规范或要求ㄢ`*控制台ㄢ`方法工作ℴℴ它们不是JavaScript的正式组成部分,而是由T添加到JS中ㄢ_宿主环境_(见_类型与语法_这本书系列的标题)ㄢ

因此,不同的浏览器和js环境可以随心所欲地运行,有时会导致混乱的行为ㄢ

特别是,有一些浏览器和一些条件`控制台(ⅆ)`实际上不会立即输出给定的内容ㄢ这可能发生的主要原因是因为I/O是许多程序的一个非常慢和阻塞的部分(不仅仅是js)ㄢ因此,对于浏览器来说,它可能表现得更好(从页面/ UI角度)ㄢ`慰问`异步I/O在后台,没有您,甚至可能不知道发生了什么ㄢ

不是很常见,但可能的情况下,这可能是_观察_(不是来自代码本身,而是来自外部): 

```js
var a = {
	index: 1
};

// later
console.log( a ); // ??

// even later
a.index++;
```

我们通常希望看到`一`对象是快照在精确的时刻`控制台(ⅆ)`语句,打印类似的内容`{索引: 1 }`在下一次声明中`a.index + +`发生时,它修改了不同于,或严格地,之后的输出ㄢ`一`ㄢ

大多数情况下,前面的代码可能会在开发工具控制台中生成一个对象表示,这是您所期望的ㄢ但是,在浏览器认为它需要将控制台I/O延迟到后台的情况下,可能会出现同样的代码,在这种情况下,它是_可能的_当对象在浏览器控制台中表示时,`a.index + +`已经发生了,而且它显示了`{索引: 2 }`ㄢ

它是在什么条件下移动的目标`慰问`I/O将被推迟,甚至是否会被观察到ㄢ要意识到这个可能的异步I/O的情况下,你碰到的问题在调试对象被修改_之后_一`控制台(ⅆ)`语句,但是您看到意外的修改出现了ㄢ

**注: **如果遇到这种罕见的场景,最好的选择是在js调试器中使用断点,而不是依赖于`慰问`输出ㄢ下一个最好的选择是受力对象的"快照ℽ问题被序列化到一个`一串`,像`JSONㄢstringify(..)`ㄢ

## 事件循环

让我们做一个(或许触目惊心)声称: 尽管允许异步js代码(如超时,我们只是看着),直到最近(6),JavaScript本身实际上没有任何直接的概念,同步建成ㄢ

**什么!?**这似乎是个疯狂的要求,对吧?事实上,这是千真万确的ㄢjs引擎本身从来没有做过什么,只需要在给定的时刻执行一个程序块ㄢ

问: "是谁做的?ℽ这是重要的部分!

js引擎不是孤立运行的ㄢ它在内部运行ㄢ_宿主环境_对于大多数开发人员来说,典型的Web浏览器ㄢ在过去的几年中(但不完全),JS已经超出浏览器到其他环境中,比如服务器,通过像Node.jsㄢ事实上,JavaScript被嵌入到各种设备,这些天,从机器人到灯泡ㄢ

但是,在所有这些环境中,一个常见的"线程ℽ(这不是一个非常微妙的异步笑话)值得一提的是,它们中有一个机制来处理多个程序块ㄢ_随着时间的推移_在调用JS引擎的每一时刻,都调用"事件循环ℽㄢ

换句话说,js引擎并没有天生的意义ㄢ_时间_但它已经成为任意任意JS片段的按需执行环境ㄢ周围的环境一直都是这样ㄢ_预定_事件(JS代码执行)ㄢ

例如,当你的js程序发出一个Ajax请求从服务器获取一些数据时,你在函数中设置了"响应ℽ代码(通常称为"回调ℽ),js引擎告诉主机环境,"嘿,我现在要暂停执行,但是当你完成那个网络请求时,你有一些数据,请_呼叫_这个函数_后面_ℽㄢ

然后,浏览器设置为侦听来自网络的响应,当它有东西给您时,它将要执行的回调函数插入到_事件循环_ㄢ

那么什么是_事件循环_?

让我们先通过一些伪代码概念化它: 

```js
// `eventLoop` is an array that acts as a queue (first-in, first-out)
var eventLoop = [ ];
var event;

// keep going "forever"
while (true) {
	// perform a "tick"
	if (eventLoop.length > 0) {
		// get the next event in the queue
		event = eventLoop.shift();

		// now, execute the next event
		try {
			event();
		}
		catch (err) {
			reportError(err);
		}
	}
}
```

这是,当然,大大简化的伪代码说明的概念ㄢ但这应该足以帮助人们更好地理解ㄢ

如您所见,有一个连续运行的循环,由`虽然`循环,这个循环的每一次迭代都称为"滴答ℽ,对于每一个刻度,如果一个事件在队列中等待,它就会被关闭并执行ㄢ这些事件是你的函数回调ㄢ

值得注意的是`setTimeout(..)`不将回调放在事件循环队列上ㄢ它所做的是设置一个计时器;当计时器过期时,环境将回调放置到事件循环中,这样将来的一些滴答会将它拾取并执行它ㄢ

如果此时事件循环中已经有20个项目呢?回调等待ㄢ它排在其他人后面,没有也没有ㄢ`setTimeout(..)`计时器不能以完美的时间精度开火ㄢ粗略地说,你保证你的回调不会开火ㄢ_之前_您指定的时间间隔,但可以在该时间之后或之后发生,这取决于事件队列的状态ㄢ

换句话说,你的程序通常被分成许多小的块,这在事件循环队列中一个接一个地发生ㄢ从技术上讲,与程序无关的其他事件也可以在队列中进行交叉ㄢ

**注: **我们所说的"直到最近ℽ关系到6改变自然的事件循环队列管理ㄢ它主要是一个正式的学术性,但6现在指定事件循环的工作,这意味着在技术上这是在JS引擎的权限,而不是_宿主环境_ㄢ这种变化的一个主要原因是6承诺的介绍,我们将讨论在第3章,因为他们需要有直接的能力,细粒度控制在事件循环队列调度操作(见讨论`setTimeout(ㄢ0)`在"合作ℽ部分ㄢ

## 并行多线程

这是很常见的混淆术语"异步ℽ和"平行ℽ,但实际上它们是完全不同的ㄢ记住,什么是差距_现在_和_后来_ㄢ但平行是指事物能够同时发生ㄢ

最常见的并行计算工具是进程和线程ㄢ进程和线程独立执行,可以同时执行: 在单独的处理器上,甚至是独立的计算机上,但是多个线程可以共享单个进程的内存ㄢ

相反,一个事件循环,,打破了其工作任务和执行串行,不允许并行访问和更改共享内存ㄢ并行和"序列音乐ℽ可以在合作事件循环在单独的线程方式并存ㄢ

并行执行线程的交织和异步事件的交织发生在非常不同的粒度级别上ㄢ

例如:

```js
function later() {
	answer = answer * 2;
	console.log( "Meaning of life:", answer );
}
```

而整个内容`later()`将被视为一个单事件循环队列条目,当考虑该代码运行的线程时,实际上可能有十几种不同的低级操作ㄢ例如,`答案= 2`首先需要加载当前值`回答`,然后把`二`在某处,然后执行乘法运算,然后取结果并将其存储回`回答`ㄢ

在单线程环境中,线程队列中的项是低级别的操作实际上并不重要,因为没有任何东西可以中断线程ㄢ但是如果你有一个并行系统,其中两个不同的线程在同一个程序中运行,你很可能会有不可预知的行为ㄢ

考虑: 

```js
var a = 20;

function foo() {
	a = a + 1;
}

function bar() {
	a = a * 2;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

在JavaScript的单线程行为中,如果`foo()`跑前`bar()`结果是`一`有`四十二`,但如果`bar()`跑前`foo()`结果在`一`将`四十一`ㄢ

如果JS事件并行执行相同的数据,问题会更加微妙ㄢ考虑到这两个列表的代码任务作为线程分别运行代码`foo()`和`bar()`并考虑它们在同一时间运行会发生什么: 

线程1(`X`和`Y`是临时内存位置): 

    foo():
      a. load value of `a` in `X`
      b. store `1` in `Y`
      c. add `X` and `Y`, store result in `X`
      d. store value of `X` in `a`

线程2(`X`和`Y`是临时内存位置): 

    bar():
      a. load value of `a` in `X`
      b. store `2` in `Y`
      c. multiply `X` and `Y`, store result in `X`
      d. store value of `X` in `a`

现在,让我们假设这两个线程是并行运行的ㄢ你可能会发现问题所在,对吧?它们使用共享内存位置ㄢ`X`和`Y`为他们的临时步骤ㄢ

最终结果是什么?`一`如果是这样的话?

    1a  (load value of `a` in `X`   ==> `20`)
    2a  (load value of `a` in `X`   ==> `20`)
    1b  (store `1` in `Y`   ==> `1`)
    2b  (store `2` in `Y`   ==> `2`)
    1c  (add `X` and `Y`, store result in `X`   ==> `22`)
    1d  (store value of `X` in `a`   ==> `22`)
    2c  (multiply `X` and `Y`, store result in `X`   ==> `44`)
    2d  (store value of `X` in `a`   ==> `44`)

结果在`一`将`四十四`ㄢ但是这种排序呢?

    1a  (load value of `a` in `X`   ==> `20`)
    2a  (load value of `a` in `X`   ==> `20`)
    2b  (store `2` in `Y`   ==> `2`)
    1b  (store `1` in `Y`   ==> `1`)
    2c  (multiply `X` and `Y`, store result in `X`   ==> `20`)
    1c  (add `X` and `Y`, store result in `X`   ==> `21`)
    1d  (store value of `X` in `a`   ==> `21`)
    2d  (store value of `X` in `a`   ==> `21`)

结果在`一`将`二十一`ㄢ

因此,线程编程非常棘手,因为如果你不采取特殊的步骤来防止这种中断/交织的发生,你会得到非常令人惊讶的ㄡ不确定的行为,经常导致头痛ㄢ

JavaScript从不在线程之间共享数据,这意味着_那个_的不确定性是水平不关心ㄢ但这并不意味着JS总是坚定的ㄢ记住前面的顺序`foo()`和`bar()`产生两个不同的结果(`四十一`或`四十二`)?

**注: **它可能不是很明显,但不是所有的不确定性是坏的ㄢ有时这是无关紧要的,有时是有意的ㄢ我们将在这一章和接下来的几章中看到更多的例子ㄢ

### 运行完成

由于JavaScript的单线程,所以代码在`foo()`(和`bar()`是原子的,这意味着曾经`foo()`开始运行时,它的全部代码将在任何代码中完成ㄢ`bar()`可以运行,反之亦然ㄢ这称为"运行到完成ℽ行为ㄢ

事实上,运行到完成语义更为明显ㄢ`foo()`和`bar()`在它们中有更多的代码,例如: 

```js
var a = 1;
var b = 2;

function foo() {
	a++;
	b = b * a;
	a = b + 3;
}

function bar() {
	b--;
	a = 8 + b;
	b = a * 2;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

因为`foo()`不能被打断`bar()`,和`bar()`不能被打断`foo()`这个程序只有两种可能的结果,取决于它首先运行哪一个ℴℴ如果`foo()`和`bar()`可以交错,可能的结果的数量将大大增加!

第1块是同步的(发生)_现在_)但块2和3是异步的(发生)_后来_这意味着他们的执行将被时间间隔分开ㄢ

块1: 

```js
var a = 1;
var b = 2;
```

块2(`foo()`): 

```js
a++;
b = b * a;
a = b + 3;
```

块3(`bar()`): 

```js
b--;
a = 8 + b;
b = a * 2;
```

块2和5月3日发生在第一顺序,所以有两个可能的结果,这一计划,如图所示: 

结果1: 

```js
var a = 1;
var b = 2;

// foo()
a++;
b = b * a;
a = b + 3;

// bar()
b--;
a = 8 + b;
b = a * 2;

a; // 11
b; // 22
```

结果2: 

```js
var a = 1;
var b = 2;

// bar()
b--;
a = 8 + b;
b = a * 2;

// foo()
a++;
b = b * a;
a = b + 3;

a; // 183
b; // 180
```

从相同的代码两种结果意味着我们还有不确定性!但它是在函数(事件)排序级别,而不是在语句排序级别(或者实际上是表达式操作排序级别),与线程一样ㄢ换句话说,它是_更确定_比线程要多ㄢ

适用于JavaScript的行为,常见的术语"竞争状态这一功能排序的不确定性,ℽ`foo()`和`bar()`互相竞争看谁先跑ㄢ具体来说,这是一个"竞争条件ℽ,因为你不能可靠地预测ㄢ`一`和`B`将转出ㄢ

**注: **如果js中有一个函数没有运行到完成的行为,我们可能会有更多可能的结果,对吗?原来只是6介绍了这样一件事(见4章"发电机ℽ),但不要担心,现在,我们会回来!

## 并发

让我们想象一个站点,它显示一个状态更新列表(就像一个社交网络新闻提要),当用户向下滚动列表时,逐步加载该站点ㄢ要使这一特性正常工作,至少需要执行两个独立的"进程ℽㄢ_同时_(即,在同一时间窗内,但不一定在同一时刻)ㄢ

**注: **我们在这里引用了"过程ℽ,因为它们不是计算机科学意义上的真正的操作系统级过程ㄢ它们是表示逻辑连接的ㄡ连续的一系列操作的虚拟过程或任务ㄢ我们将简单地选择"过程ℽ而不是"任务ℽ,因为术语是明智的,它将与我们正在探索的概念的定义相匹配ㄢ

第一个"过程ℽ将响应`onscroll`事件(使Ajax请求新内容)他们火当用户滚动页面进一步下降ㄢ第二个"进程ℽ将接收Ajax响应(将内容呈现到页面上)ㄢ

显然,如果用户滚动得足够快,您可能会看到两个或更多ㄢ`onscroll`在获取第一个响应和处理过程所需的时间内触发的事件,因此您将拥有`onscroll`事件和Ajax响应事件快速开火,相互交错ㄢ

并发性是指两个或多个进程在同一个时期同时执行,而不管它们各自的组成操作是否发生ㄢ_在并行_(在同一时刻在独立的处理器或核心上)与否ㄢ您可以把并发性看作是"进程ℽ级(或任务级)并行,而不是操作级并行(独立处理器线程)ㄢ

**注: **并发性还引入了一个可选的概念,这些"进程ℽ相互作用ㄢ我们稍后再谈ㄢ

对于给定的时间窗口(用户滚动几秒钟),让我们将每个独立的"进程ℽ可视化为一系列事件/操作: 

"过程ℽ1(`onscroll`事件): 

    onscroll, request 1
    onscroll, request 2
    onscroll, request 3
    onscroll, request 4
    onscroll, request 5
    onscroll, request 6
    onscroll, request 7

"过程ℽ2(ajax响应事件): 

    response 1
    response 2
    response 3
    response 4
    response 5
    response 6
    response 7

很有可能`onscroll`事件和Ajax响应事件可以以完全相同的方式进行处理ㄢ_瞬间_ㄢ例如,让我们在一个时间轴中可视化这些事件: 

    onscroll, request 1
    onscroll, request 2          response 1
    onscroll, request 3          response 2
    response 3
    onscroll, request 4
    onscroll, request 5
    onscroll, request 6          response 4
    onscroll, request 7
    response 6
    response 5
    response 7

但是,回到本章前面的事件循环的概念,js只能够一次处理一个事件,所以也可以ㄢ`onscroll,请求2`将首先发生或`反应1`将首先发生,但它们不能在同一时刻发生ㄢ就像学校食堂里的孩子们一样,不管他们在门外形成什么样的人群,他们都得排成单行来吃午饭!

让我们将所有这些事件的交织可视化到事件循环队列中ㄢ

事件循环队列: 

    onscroll, request 1   <--- Process 1 starts
    onscroll, request 2
    response 1            <--- Process 2 starts
    onscroll, request 3
    response 2
    response 3
    onscroll, request 4
    onscroll, request 5
    onscroll, request 6
    response 4
    onscroll, request 7   <--- Process 1 finishes
    response 6
    response 5
    response 7            <--- Process 2 finishes

"进程1ℽ和"进程2ℽ同时运行(任务级并行),但它们的单个事件在事件循环队列中顺序运行ㄢ

顺便问一下,注意`反应6`和`反应5`从预期的秩序中回来了吗?

单线程事件循环是并发的一种表达式(当然还有其他的,稍后我们将返回)ㄢ

### 无相互作用

当两个或多个进程同时在同一个程序中交织它们的步骤/事件时,如果任务不相关,它们不一定需要相互交互ㄢ**如果他们不相互影响,不确定性是完全可以接受的ㄢ**

例如:

```js
var res = {};

function foo(results) {
	res.foo = results;
}

function bar(results) {
	res.bar = results;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

`foo()`和`bar()`两并行ℽ的过程,"这是nondeterminate命令他们将发射ㄢ但是我们已经构建了这个程序,所以不管他们顺序是什么,因为它们独立运行,因此不需要交互ㄢ

这不是一个"竞争条件ℽ错误,因为代码总是

### 相互作用

更常见的是,并发的"过程ℽ将不可避免地通过范围和/或DOM进行交互ㄢ当这种交互发生时,您需要协调这些交互以防止前面描述的"竞争条件ℽㄢ

下面是一个简单的例子,这两个并发的"进程ℽ相互作用,因为隐含的顺序,这是唯一的_有时破碎_: 

```js
var res = [];

function response(data) {
	res.push( data );
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

并发的"进程ℽ是两个`response()`将用于处理Ajax响应的调用ㄢ它们可以以一阶的方式发生ㄢ

让我们假设预期的行为是`RES [ 0 ]`有结果的`"1ℽ`电话,和`RES [ 1 ]`有结果的`"2ℽ`呼叫ㄢ有时会出现这种情况,但有时他们会被翻转,这取决于哪一个调用首先完成ㄢ有一个很好的可能性,这种不确定性是一个"种族ℽ状态的bugㄢ

**注: **对你在这些情况下可能会做出的假设非常警惕ㄢ例如,开发人员观察到这种情况并不少见ㄢ`"2ℽ`总是比反应慢得多`"1ℽ`,也许是由于他们正在做的任务(例如,执行一个数据库任务,另一个只是获取一个静态文件),因此所观察到的顺序似乎总是像预期的那样ㄢ即使两个请求都在同一个服务器上,并且_它_故意按一定的顺序回应,没有_真实的_保证响应在浏览器中返回的顺序ㄢ

因此,为了处理这样的竞争条件,可以协调排序交互: 

```js
var res = [];

function response(data) {
	if (data.url == "http://some.url.1") {
		res[0] = data;
	}
	else if (data.url == "http://some.url.2") {
		res[1] = data;
	}
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

不管哪个Ajax响应首先返回,我们检查`data.url`(假设一个是从服务器返回的,当然!)计算响应数据应该位于哪个位置`物件`阵列ㄢ`RES [ 0 ]`将永远持有`"1ℽ`结果`RES [ 1 ]`将永远持有`"2ℽ`结果.通过简单的协调,我们消除了"种族ℽ条件的不确定性ㄢ

如果多个并发函数调用通过共享DOM交互,如更新一个`<DIV>`另一个则更新样式或属性ㄢ`<DIV>`(例如,使DOM元素在有内容后可见)ㄢ您可能不希望在内容出现之前显示DOM元素,因此协调必须确保适当的顺序交互ㄢ

一些并发场景如下_总是破碎_(不只是_有时_)没有协调的相互作用ㄢ考虑: 

```js
var a, b;

function foo(x) {
	a = x * 2;
	baz();
}

function bar(y) {
	b = y * 2;
	baz();
}

function baz() {
	console.log(a + b);
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

在这个例子中,是否`foo()`或`bar()`先开火,它总会引起`baz()`跑得太早`一`或`B`仍然会`未定义`),但第二次调用`baz()`将工作,因为两者`一`和`B`将可用ㄢ

解决这种情况有不同的方法ㄢ这里有一个简单的方法: 

```js
var a, b;

function foo(x) {
	a = x * 2;
	if (a && b) {
		baz();
	}
}

function bar(y) {
	b = y * 2;
	if (a && b) {
		baz();
	}
}

function baz() {
	console.log( a + b );
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

这个`如果(A和B)`有条件的在`baz()`呼叫传统上被称为"门ℽ,因为我们不知道什么命令ㄢ`一`和`B`将到达,但我们等待他们到达那里,然后我们开始打开大门(呼叫)ㄢ`baz()`)ㄢ

您可能遇到的另一个并发交互条件有时被称为"竞争ℽ,但更正确地称为"锁ℽ,它的特征是"只有第一个赢ℽ的行为ㄢ在这里,不确定性是可以接受的,在你明确地说这是好的"种族ℽ的终点线,只有一个赢家ㄢ

考虑这个坏代码: 

```js
var a;

function foo(x) {
	a = x * 2;
	baz();
}

function bar(x) {
	a = x / 2;
	baz();
}

function baz() {
	console.log( a );
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

哪一个(`foo()`或`bar()`最后一次开火不会覆盖指定的任务ㄢ`一`值从另一个,但它也将重复调用`baz()`(可能不受欢迎的)ㄢ

因此,我们可以用一个简单的闩锁来协调交互,只允许第一个通过: 

```js
var a;

function foo(x) {
	if (a == undefined) {
		a = x * 2;
		baz();
	}
}

function bar(x) {
	if (a == undefined) {
		a = x / 2;
		baz();
	}
}

function baz() {
	console.log( a );
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

这个`如果(a =未定义)`条件允许只允许`foo()`或`bar()`通过,第二个(实际上是任何后续的)调用都会被忽略ㄢ排在第二位是没有什么好处的!

**注: **在所有这些场景中,我们一直在使用全局变量进行简单的说明,但是我们的推理没有什么需要它的ㄢ只要有问题的函数能够访问变量(通过作用域),它们就可以按照预期的方式工作ㄢ依赖变量(参见_范围和关闭_这本书系列的标题,实际上是这些例子中的全局变量,是这些并发协调形式的一个明显的缺点ㄢ在接下来的几章中,我们将看到在这方面更为清洁的其他协调方式ㄢ

### 合作

并发协调的另一个表达式称为"协作并发ℽ,这里的重点不是通过范围内的值共享来交互(尽管这显然是允许的)ㄢ我们的目标是接受一个长时间的"过程ℽ,并将其分解为步骤或批处理,以便其他并发的"进程ℽ有机会将它们的操作交织到事件循环队列中ㄢ

例如,考虑需要运行的Ajax响应处理程序ㄢ`阵列#地图(..)`保持代码更短: 

```js
var res = [];

// `response(..)` receives array of results from the Ajax call
function response(data) {
	// add onto existing `res` array
	res = res.concat(
		// make a new transformed array with all `data` values doubled
		data.map( function(val){
			return val * 2;
		} )
	);
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

如果`"1ℽ`首先返回它的结果,整个列表将被映射到`物件`一下子ㄢ如果是几千或更少的记录,这通常不是一个大问题ㄢ但如果说是1000万条记录,那就需要一段时间才能运行(在功能强大的笔记本上几秒钟,移动设备上的时间更长)ㄢ

虽然这样的"过程ℽ正在运行,但页面中没有其他内容可以发生,包括其他的ㄢ`响应(..)`调用,没有UI更新,甚至连滚动ㄡ打字ㄡ按钮点击之类的用户事件都没有ㄢ那是相当痛苦的ㄢ

因此,为了创建一个更为协作的并发系统,一个更友好且不影响事件循环队列的系统,您可以将这些结果处理为异步批处理,在每一个"返回ℽ到事件循环之后,让其他等待事件发生ㄢ

这里有一个非常简单的方法: 

```js
var res = [];

// `response(..)` receives array of results from the Ajax call
function response(data) {
	// let's just do 1000 at a time
	var chunk = data.splice( 0, 1000 );

	// add onto existing `res` array
	res = res.concat(
		// make a new transformed array with all `chunk` values doubled
		chunk.map( function(val){
			return val * 2;
		} )
	);

	// anything left to process?
	if (data.length > 0) {
		// async schedule next batch
		setTimeout( function(){
			response( data );
		}, 0 );
	}
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

我们以1000个项目的最大大小块处理数据集ㄢ通过这样做,我们确保短期运行ℽ的过程,"即使这意味着更多的后续ℽ的过程,"作为交织在事件循环队列会给我们一个更为敏感(性能)的网站/应用程序ㄢ

当然,我们不是交互协调这些过程的排序,所以结果的顺序是`物件`不可预测ㄢ如果需要排序,您需要使用我们前面讨论过的交互技术,或者我们将在本书后面的章节中讨论这些技术ㄢ

我们使用`setTimeout(ㄢ0)`(黑客)异步调度,这基本上就意味着"把这个功能在当前的事件循环队列的末尾ㄢℽ

**注: ** `setTimeout(ㄢ0)`技术上不直接将事件插入事件循环队列ㄢ计时器将在下一次机会中插入事件ㄢ例如,两个后续`setTimeout(ㄢ0)`呼叫不会严格保证按呼叫顺序进行处理,因此_是_可能会看到各种各样的条件,如计时器漂移,这些事件的排序是不可预测的ㄢ在Node.js,一个类似的方法`的过程ㄢnexttick(..)`ㄢ尽管如何方便(通常更高性能的)的那样,有没有一个直接的方式(至少现在)在所有的环境中保证异步事件排序ㄢ我们将在下一节中更详细地讨论这个主题ㄢ

## 乔布斯

截至6,上方有事件循环队列分层的一个新的概念,叫做"作业队列ℽㄢ最有可能暴露你是诺言的异步行为(见3章)ㄢ

不幸的是,目前它是一个没有暴露API的机制,从而证明它有点复杂ㄢ所以我们要只是描述它的概念,这样,当我们讨论3章异步行为的承诺,你就会理解这些行为被调度处理ㄢ

因此,我认为最好的方法是,"作业队列ℽ是挂在事件循环队列中每一个结束点的队列ㄢ一定的异步行为,蜱隐含的事件循环时不会造成一个全新的事件被添加到事件循环队列,而是增加一项(即工作)到当前滴答的工作队列的末尾ㄢ

这就像说,"哦,这是我需要做的另外一件事_后来_但要确保它在发生任何事情之前马上发生ㄢℽ

或者,使用一个比喻: 事件循环队列就像是一个游乐园,一旦你完成了旅程,你就必须回到后面去骑ㄢ但是工作队列就像完成旅程一样,但然后插队,然后马上返回ㄢ

一个作业还可以导致更多的作业添加到同一队列的末端ㄢ因此,从理论上讲,一个工作"循环ℽ(一个不断增加另一份工作的工作等)可以无限期地旋转,从而使程序无法继续进入下一个事件循环ㄢ这在概念上几乎与只表达长时间循环或无限循环(如`然而(真的)`)在你的代码中ㄢ

乔布斯有点像`setTimeout(ㄢ0)`黑客,但实现了这样一种方式,有一个更明确的和有保证的秩序: **稍后,但尽快**ㄢ

让我们设想一个调度作业的API(直接,没有黑客),并调用它ㄢ`附表(ⅆ)`ㄢ考虑: 

```js
console.log( "A" );

setTimeout( function(){
	console.log( "B" );
}, 0 );

// theoretical "Job API"
schedule( function(){
	console.log( "C" );

	schedule( function(){
		console.log( "D" );
	} );
} );
```

您可能希望打印出来ㄢ`甲丙氨丁`但它会打印出来`D B`因为作业是在当前事件循环结束时发生的,并且定时器触发调度_下一个_事件循环蜱(如果可用)!ㄢ

在第3章中,我们将看到承诺的异步行为是基于作业的,因此,重要的是要清楚地了解如何与事件循环行为相关联ㄢ

## 语句排序

我们在代码中表达语句的顺序不一定与js引擎将执行它们的顺序相同ㄢ这似乎是一个非常奇怪的断言,所以我们将简要地探究它ㄢ

但是在我们做之前,我们应该清楚地了解一些东西: 语言的规则/语法ㄢ_类型与语法_这本书系列的标题)从程序的角度规定了一种非常可预测和可靠的语句排序行为ㄢ所以我们要讨论的是**不是你应该能观察到的东西**在你的js程序中ㄢ

**警告: **如果你能_观察_像我们即将要说明的那样,编译器语句重新排序,这显然违反了规范,毫无疑问,这是由于JS引擎中存在一个bugℴℴ一个应该及时报告并修复的错误!但它更常见的是你_犯罪嫌疑人_在JS引擎中发生了一些疯狂的事情,事实上它只是一个bug(可能是"竞争条件ℽ!)在你自己的代码里,先看一遍,再看一遍ㄢjs调试器,使用断点和逐行逐行扫描代码,将是您嗅出此类错误的最强大工具ㄢ_你的代码_ㄢ

考虑: 

```js
var a, b;

a = 10;
b = 30;

a = a + 1;
b = b + 1;

console.log( a + b ); // 42
```

此代码没有表示异步(除了罕见的)ㄢ`慰问`异步I/O之前讨论的!)因此,最有可能的假设是,它将以自上而下的方式逐行处理ㄢ

但它的_可能的_js引擎在编译了这个代码之后(是的,js是编译的)_范围和关闭_这本书系列的标题!)通过重新排列(安全地)这些语句的顺序,可以找到更快运行代码的机会ㄢ本质上,只要你不能观察排序,任何事情都是公平的游戏ㄢ

例如,引擎可能会发现更快地执行这样的代码: 

```js
var a, b;

a = 10;
a++;

b = 30;
b++;

console.log( a + b ); // 42
```

或这: 

```js
var a, b;

a = 11;
b = 31;

console.log( a + b ); // 42
```

甚至: 

```js
// because `a` and `b` aren't used anymore, we can
// inline and don't even need them!
console.log( 42 ); // 42
```

在所有这些情况下,js引擎在编译过程中都会进行安全优化ㄢ_观察_结果是一样的ㄢ

但是这里有一个场景,这些特定的优化是不安全的,因此不能被允许(当然,并不是说它根本没有优化): 

```js
var a, b;

a = 10;
b = 30;

// we need `a` and `b` in their preincremented state!
console.log( a * b ); // 300

a = a + 1;
b = b + 1;

console.log( a + b ); // 42
```

其它的例子可以创建编译器重新观察副作用(因此必须禁止)将包括任何函数调用的副作用(特别是吸气功能),或6代理对象(见_6与超越_这本书系列的标题)ㄢ

考虑: 

```js
function foo() {
	console.log( b );
	return 1;
}

var a, b, c;

// ES5.1 getter literal syntax
c = {
	get bar() {
		console.log( a );
		return 1;
	}
};

a = 10;
b = 30;

a += foo();				// 30
b += c.bar;				// 11

console.log( a + b );	// 42
```

如果不是为了`控制台(ⅆ)`这个片段中的语句(只是作为一种方便的可观察到的副作用形式的例子),js引擎很可能是免费的,如果它想要的话(谁知道它是否会)!将代码重新排序为: 

```js
// ...

a = 10 + foo();
b = 30 + c.bar;

// ...
```

js的语义感激地保护我们免受_观察_编译语句重新排序似乎是有危险的噩梦,理解源代码编写方式(自上而下的方式)和编译后运行的方式之间的脆弱性仍然很重要ㄢ

编译器语句重新排序几乎是对并发性和交互的微观隐喻ㄢ作为一个总的概念,这种意识可以帮助你更好的理解异步js代码流问题ㄢ

## 回顾

JavaScript程序(实际上)总是分成两个或多个块,其中第一个块运行ㄢ_现在_下一个块运行_后来_,作为对事件的回应ㄢ尽管程序是按块执行的,但它们都与程序范围和状态共享相同的访问权限,因此每个对状态的修改都是在前一个状态之上进行的ㄢ

每当有事件要运行时,_事件循环_运行到队列为空为止ㄢ每一次迭代的循环事件是一个"滴答ℽㄢ用户交互,IO,定时器队列的事件在事件队列ㄢ

在任何给定的时刻,每次只能从队列中处理一个事件ㄢ当事件正在执行时,它可以直接或间接导致一个或多个后续事件ㄢ

并发性是指两个或多个事件链随着时间的推移交织在一起,从高层的角度来看,它们似乎正在运行ㄢ_同时_(即使在任何给定的时刻,只有一个事件正在处理中)ㄢ

通常需要在这些并发进程之间进行某种形式的交互协调(不同于操作系统进程),例如确保排序或防止"竞争条件ℽㄢ_合作_通过将自己分成更小的块并允许其他"进程ℽ交错ㄢ
