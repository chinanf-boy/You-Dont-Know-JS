
# 你不知道JS：异步性能

# 2章：回调

在第1章中，我们探讨了JavaScript中异步编程的术语和概念。我们的重点是了解单线程（之一）事件循环队列驱动所有的“事件”（异步函数调用）。我们还探索了并发模式解释关系的各种方法（如果有的话）之间_同时_事件的运行链，或“进程”（任务，函数调用，等等）。

我们在第1章中的所有例子都使用函数作为独立的、不可分割的操作单元，在函数内部，语句以可预见的顺序运行（在编译器级别之上）！，但在功能有序化的程度，事件（又名异步函数调用）可以在各种订单发生。

在所有这些情况下，函数都充当“回调”，因为当队列中的项被处理时，它充当事件循环的目标来“调用”程序。

你毫无疑问已经观察到，回调是迄今为止，JS程序同步表达和管理的最常见的方式。事实上，回调是语言中最基本的异步模式。

无数的JS程序，即使是非常复杂的，已写在没有其他异步基础比回调（当然并发交互模式研究1章）。回调函数是JavaScript异步工作的马，和它的工作体面。

除了…回调也不是没有缺点。许多开发人员对此感到兴奋。_承诺_（双关语是有意的！）更好的异步模式。但是如果你不理解它的抽象，为什么不能够有效地使用任何抽象，为什么？。

在这一章中，我们将探讨一些在深度、动机为什么更复杂的异步模式（在本书后面的章节探讨）是必要的和期望的。

## 延续

让我们回到异步回调的例子，我们开始在1章，但让我稍微修改，来说明这一点：

```js
// A
ajax( "..", function(..){
	// C
} );
// B
```

`/ /`和`/ / B`表示程序的前半部分（又名_现在_），和`/ / C`标志着程序的下半部分（又名_后来_）。前半部分立即执行，然后有一个不确定长度的“暂停”。在将来的某一时刻，如果ajax调用完成，程序将拾取它停止的位置，然后_持续_下半场。

换句话说，回调函数包装或封装_延续_程序的。

让我们把代码变得更简单：

```js
// A
setTimeout( function(){
	// C
}, 1000 );
// B
```

停一下，问问自己你是如何描述（对其他不了解JS工作的人）程序的行为方式。去吧，试试看。这是一个很好的锻炼，有助于我的下一个观点更有意义。

现在大多数读者可能想到或说了些什么：“做一个，然后设置一个暂停等待1000毫秒，然后一旦开火，C.”你的表演有多接近？

您可能已经捕获自己并自我编辑为：“做一个，设置超时1000毫秒，然后做B，然后在超时火灾，做C.”，这比第一个版本更准确。你能找出区别吗？

尽管第二个版本更准确，但两个版本都不足以解释这段代码的方式，它与我们的大脑对代码的匹配，以及对js引擎的代码。断开是微妙而不朽，并在理解回调函数的缺点异步表达和管理的核心。

只要我们引入一个延续（或者像很多程序一样多打几次）！以回调函数的形式，我们允许在我们的大脑工作方式和代码运行方式之间形成一个散度。任何时候，这两个分歧（这是不是唯一发生的地方，我敢肯定，你知道！）我们遇到了一个不可避免的事实，即我们的代码变得难以理解、推理、调试和维护。

## 连续的脑

我敢肯定，你们中的大多数读者都听到有人说（甚至你自己的说法），“我身兼数职。”试图作为幽默的身兼数职范围的影响（例如，愚蠢的拍脑袋揉肚子的孩子的游戏）世俗（口香糖一边走到非常危险的（）开车时发短信）。

但我们是人吗？我们真的能同时做两个有意识的、有意识的行动吗？我们最高级别的大脑功能有并行多线程进行吗？

答案可能会让你大吃一惊：**可能不是。**

这并不是我们的大脑是如何建立起来的。我们比许多人更多的单任务执行者（尤其是A型性格的人！）愿意承认。在任何特定的时刻，我们只能思考一件事。

我不是在谈论我们所有的无意识、潜意识、自动的大脑功能，例如心脏跳动、呼吸和眼睑闪烁。这些都是O的重要任务。

相反，我们现在谈论的是我们头脑中最重要的任务。对我来说，它现在正在写这本书中的文字。我是否在同一时刻做任何其他更高级的大脑功能？不，不是真的。在这最后几段中，我很容易很容易分心！

当我们_伪造的_多任务处理，如想打一些东西的同时，我们在电话交谈的朋友或家人，其实我们最有可能做的是作为快速上下文切换。换句话说，我们在两个或多个任务之间快速交替地来回切换，_同时_在微小的、快速的小块中完成每一项任务。我们做得如此之快，以至于外界似乎都在做这些事情。_在并行_。

不象异步事件并发（像是在JS发生）吗？如果没有，回去读第1章！

事实上，一种简化（即滥用）大规模复杂的神经学世界的方法，我可以远程讨论的是，我们的大脑工作起来就像事件循环队列。

如果你认为每一个字母（或文字）I型作为一个单一的异步事件，只是这句话就有我的大脑被一些其他事件中断了几十个机会，比如我的感觉，或者只是我的想法。

我不会被每一个可能的机会打断，拖到另一个“过程”（谢天谢地，否则这本书永远也不会写！）但这种情况经常发生，我觉得自己的大脑几乎在不断地切换到各种不同的环境（又名“过程”）。这非常像js引擎可能会感觉到的那样。

### 做与规划

好的，所以我们的大脑可以被看作是像单线程事件循环队列那样运行，js引擎也可以这样做。听起来像是一场精彩的比赛。

但我们需要比我们的分析更加细致入微。我们如何规划各种任务，以及我们的大脑是如何执行这些任务的，两者之间存在着巨大的、可观察到的差异。

再次，回到这篇文章的写作，作为我的隐喻。我粗略的头脑大纲是为了保持写作和写作，依次按顺序排列在我的思想中。我不打算在写作中有任何干扰或非线性活动。但是，我的大脑却一直在转来转去。

即使在操作层面上我们的大脑是异步事件，我们似乎计划在一个连续的、同步的任务。”我需要去商店，然后买些牛奶，然后把我的干洗掉下来。

你会发现这个高层次思维（规划）似乎不太异步事件在其制定。事实上，对我们来说，单纯地考虑事件是很罕见的。相反，我们仔细地按顺序规划事物（A，B，然后C），我们在某种程度上假设一种时间阻塞，迫使B在A上等待，C在B上等待。

当开发人员编写代码时，他们正在计划一组要发生的操作。如果他们善于成为一个开发者，他们就是**仔细规划**它出来了。”我需要设置`Z`价值`X`，然后`X`价值`Y`等等。

当我们写出同步代码，语句语句时，它就像我们的差事清单一样：

```js
// swap `x` and `y` (via temp variable `z`)
z = x;
x = y;
y = z;
```

这三个赋值语句是同步的，所以`x = y`等待`z = x`完成，以及`y = z`in turn waits for`x = y`完成。另一种说法是，这三种说法在时间上必然以某种先后顺序执行，一个接着一个。值得庆幸的是，我们不需要去任何异步事件的细节在这里。如果我们这样做了，代码就会变得更加复杂、迅速！

因此，如果同步大脑规划与同步代码语句映射得很好，那么我们的大脑在规划异步代码时有多好呢？

原来，我们如何表达不同步（有回调）在我们的代码中没有地图都非常好，同步脑规划行为。

你真的能想象有这样的想法，像这样安排你的差事吗？

> “我要去商店，但我确定我会得到一个电话的方式，所以，“嗨，﻿妈妈，当她开始说话的时候，我会看到GPS的存储地址，但这需要一个第二负载，所以我会把收音机等我听到妈妈好，然后我就意识到我忘了穿外套，外面很冷，但是不管，继续开车和﻿妈妈交谈，然后带丁提醒我扣上，所以，是的，﻿妈妈，我穿着我的安全带，我总是这样做的！”啊，终于GPS找到了方向，现在……

这听起来很荒谬，就像是我们如何计划我们的一天，思考什么该做什么，什么样的顺序，然而，这正是我们的大脑在功能层面上的运作方式。记住，这不是多任务处理，它只是快速的上下文切换。

原因我们很难作为开发者编写异步事件

我们在一步一步的思考，但是工具（回调）的代码提供给我们的不表达在一步一步地一旦我们从同步到异步。

和**那个**所以很难准确的作者和原因有关异步js代码与回调：因为这不是我们的大脑如何规划工作。

**注：**唯一比不知道某些代码中断的原因更糟糕的是，不知道为什么它首先起作用！这是经典的“纸牌屋”思想：“它有效，但不确定为什么，所以没有人碰它！”你可能听说过，“他人就是地狱”（Sartre），和程序员因扭曲，“他人即地狱的代码。“我真正相信：“地狱是不理解自己的代码。“回调是一个主要的罪魁祸首。

### 嵌套/环比回调

考虑：

```js
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );
```

有一个很好的机会，这样的代码可以识别你。我们有一组三个函数嵌套在一起，每一个代表一个异步系列（任务，过程）中的一个步骤。

这种代码通常被称为“回调地狱”，有时也称为“末日金字塔”（因嵌套缩进而面临三角形）。

但是“回调地狱”实际上与嵌套/缩进几乎没有关系。这是一个比那个更深的问题。我们将在本章余下的章节中继续讨论如何以及为什么。

首先，我们在等待“点击”事件，然后我们等待计时器开火，然后我们等待Ajax响应返回，此时它可能再次完成。

乍一看，这段代码似乎将其异步性映射为顺序脑规划。

第一（_现在_），我们：

```js
listen( "..", function handler(..){
	// ..
} );
```

然后_后来_，我们：

```js
setTimeout( function request(..){
	// ..
}, 500) ;
```

然后还_后来_，我们：

```js
ajax( "..", function response(..){
	// ..
} );
```

最后（大多数）_后来_），我们：

```js
if ( .. ) {
	// ..
}
else ..
```

但是，用这种方式线性地对这段代码进行推理有几个问题。

首先，这是一个例子，我们的步骤是在随后的线路（1, 2, 3和4…）。在真正的异步js程序，会有更多的噪音塞满东西，噪声，我们巧妙地机动过去在我们的大脑中我们从一个跳到下一个函数。了解这种回调拉登代码异步流是不可能的，但它肯定不是自然的或容易的，即使有大量的练习。

但是，还有一些更深层次的错误，这在代码示例中并不明显。让我做了另一个场景（伪ISH）说明：

```js
doA( function(){
	doB();

	doC( function(){
		doD();
	} )

	doE();
} );

doF();
```

虽然你们中有经验的人会正确地识别出操作的真实顺序，但我敢打赌，乍看起来，它会有点混乱，需要一些一致的心理周期才能到达。操作将按此顺序进行：

-   `doa()`
-   `dof()`
-   `dob()`
-   `doc()`
-   `doe()`
-   `dod()`

你第一次看代码的时候是不是得到了正确的答案？

好吧，你们中有些人认为我在功能命名上不公平，故意把你们引入歧途。我发誓我只是用自上而下的外观命名。但让我再试一次：

```js
doA( function(){
	doC();

	doD( function(){
		doF();
	} )

	doE();
} );

doB();
```

现在，我按照实际执行顺序按字母顺序命名它们。但我仍然敢打赌，即使在这种场景中有经验，也可以通过`a→b→c→d→e→f`如果读者中的任何一位，订单并不自然。当然，你的眼睛在代码片段上做了大量的跳转，对吗？

但是即使这一切都是自然的，你还有一个可能会造成灾难的危险。你能认出它是什么吗？

如果…怎么办`波达方向（…）`或`国防部（…）`实际上并没有同步，我们认为的那样吗？哦，现在订货不一样了。如果两者都是同步的（有时可能只是有时，这取决于程序当时的条件），那么现在的顺序是`a > C→D→F→B`。

你在背景中隐约听到的声音是数以千计的JS开发人员的叹息，他们手中只有一张面孔。

问题是嵌套吗？是什么使它很难跟踪异步流？当然，这是它的一部分。

但是，让我重写以前的嵌套事件/ ajax / Ajax示例而不使用嵌套：

```js
listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
```

这种代码的制定并不像以前的形式那样具有嵌套/缩进的缺点，但它却容易受到“回调地狱”的影响。

当我们对代码进行线性（顺序）推理时，我们必须从一个函数跳到下一个函数，再跳到下一个函数，并在代码基周围跳来“查看”序列流。记住，这是按最佳情况排序的简化代码。我们都知道，真正的异步的JavaScript程序代码库往往非常更冗杂，使幅度更难这样的推理顺序。

另一件要注意的事：把步骤2, 3和4连接在一起，所以他们接连发生，唯一性回调单独给了我们是硬编码的步骤2到步骤1，步骤3到步骤2，步骤4到步骤3，等等。硬编码并不一定是坏事，如果它真的是一个固定的情况下，2步应该总是导致步骤3。

但硬编码的绝对会让代码更脆弱，因为它没有考虑什么W

所有这些问题都是你_可以_手工硬编码到每一个步骤，但代码往往是非常重复性和不可重复使用在其他步骤或其他异步流动在你的程序。

即使我们的大脑可能会计划在一连续型的一系列任务（这个，然后这个，然后这个），我们大脑运作的事件性质使得回收/重试/分叉控制流量几乎不费吹灰之力。如果你外出办事，而且你意识到你在家里留下了购物清单，它不会结束一天，因为你没有提前计划。你的大脑很容易绕过这个打嗝：你回家，拿到清单，然后直接返回商店。

但脆性性质的手工硬编码的回调（甚至是硬编码的错误处理）往往是远远不够优雅。一旦你最终指定（又名预规划）的各种可能性/路径，代码变得如此费解，永远保持或更新它很难。

**那**“回调地狱”是指什么？！嵌套/缩进基本上是一个侧面展示，一个红鲱鱼。

似乎这还不够，我们还没有碰到什么发生在两个或两个以上的链这些回调延续发生_同时_，或当第三步分出“门或锁存器并行”的回调，或…天哪，我的大脑很痛，你的呢？！？

你抓的概念，这里的顺序，阻断大脑规划行为只是不映射到回调的异步代码？这是第一个阐述关于回调的重大缺陷：他们表达不同步的代码在我们大脑的战斗只是为了保持同步的方式（双关语！）。

## 信任问题

连续脑计划和回调之间的不匹配驱动的异步js代码仅仅是问题的一部分，与回调。还有更深层的事情需要关注。

让我们再次回顾回调函数的概念，作为我们程序的延续（又名下半部分）：

```js
// A
ajax( "..", function(..){
	// C
} );
// B
```

`/ /`和`/ / B`发生_现在_在主js程序的直接控制下。但`/ / C`推迟发生_后来_在另一方的控制下，在这种情况下，`ajax(..)`功能。从基本意义上说，那种失控的行为通常不会给程序带来很多问题。

但是不要当控制开关，这不是个大问题了。事实上，这是回调驱动设计中最糟糕（但也是最微妙的）问题之一。它围绕着这个想法，有时`ajax（..）`（即，您将回调延续到的“方”）不是您编写的函数，也不是直接控制的函数。很多时候，它是由第三方提供的实用程序。

我们称之为“反转控制”，当你参与你的程序并把它的执行权控制给另一个第三方时。您的代码与第三方实用程序之间存在一个不言而喻的“契约”——一组您希望维护的东西。

### 五回调的故事

为什么这么大的交易可能不是很明显。让我构建一个夸张的场景来说明游戏中信任的危害。

假设你是一个开发人员，负责建立一个销售昂贵电视的网站的电子商务结帐系统。你已经完成了所有的结帐系统的各个页面。在最后一页，当用户点击“确认”购买电视时，你需要调用第三方功能（由某个分析跟踪公司提供），这样就可以跟踪销售情况。

你注意到他们已经提供了什么看起来像一个异步跟踪程序，可能表现为最佳实践的缘故，这意味着你需要在一个回调函数传递。在您传递的这个延续中，您将拥有对客户信用卡进行收费并显示感谢页面的最终代码。

这个代码可能看起来像：

```js
analytics.trackPurchase( purchaseData, function(){
	chargeCreditCard();
	displayThankyouPage();
} );
```

很容易，对吧？您编写代码，测试它，一切工作，并部署到生产中。每个人都快乐！

六个月过去了，没有问题。你几乎忘记了你甚至写了代码。一天早上，你在工作前在咖啡店里，漫不经心地享用你的拿铁咖啡，当你接到老板的一个惊慌失措的电话时，要求你立刻放下咖啡，立即投入工作。

当你到达时，你会发现一个高知名度的顾客在同一台电视上收取了五次信用卡费用，这是可以理解的。客户服务部已经道歉并办理退款手续。但你的老板要求知道这可能是怎么发生的。”难道我们没有像这样的测试吗？！？”

你甚至不记得你写的代码。但是你要重新开始，试图找出什么可能出错。

在挖掘了一些日志之后，您得出的结论是，唯一的解释是，解析工具由于某种原因，将回调函数称为五次而不是一次。他们的文件中没有提到这件事。

失意，你联系客户支持，谁

显然，分析公司的开发人员一直在研究一些实验性的代码，在一定的条件下，每秒重试一次所提供的回调五秒，然后超时。他们从来没有打算把它投入生产，但不知怎么回事，他们完全尴尬和道歉。他们深入了解他们如何识别故障，以及他们将如何确保它不再发生。等等，等等。

下一步呢？

你和你的老板讨论过，但他对事情的状况感到不太舒服。他坚持说，你勉强同意，你不能信任。_他们_不再（这就是您的问题），您需要了解如何保护结帐代码不受此漏洞再次影响。

经过一些修修补补之后，您实现了一些简单的特殊代码，如下所示，团队对此似乎很满意：

```js
var tracked = false;

analytics.trackPurchase( purchaseData, function(){
	if (!tracked) {
		tracked = true;
		chargeCreditCard();
		displayThankyouPage();
	}
} );
```

**注：**这个要看你1章熟悉的，因为我们主要是创造一个锁存，如果碰巧有多个并发的回调调用处理。

但是你的一个QA工程师问：“如果他们从来不调用回调，会发生什么？”哎呀.你们俩谁也没想到。

你开始追逐兔子洞，想想他们打电话给你的所有可能出错的事情。这里是大致列出你想出办法的分析工具可以胡作非为：

-   调用回调太早（在跟踪之前）
-   调用回调太晚（或从未）
-   调用回调次数太少或太多次（比如遇到的问题）！
-   未能将任何必需的环境/参数传递给回调函数
-   吞咽可能发生的任何错误/异常
-   …

这应该是一个麻烦的清单，因为它是。你可能开始慢慢意识到，你将不得不发明大量的特殊逻辑。**在每一次回调中**这被传递给一个你不能信任的实用程序。

现在你知道一点完全是多么的地狱般的“回调地狱”。

### 不只是别人的代码

你们中的一些人可能会怀疑这一点是否这是一个大交易，正如我所说的那样。也许您根本不与真正的第三方公用事业交互。也许你使用的版本的API或自行举办这样的图书馆，这样的行为是不可改变的从下面你。

所以，想想看：你能吗？_真正地_您在理论上控制的信任实用程序（在您自己的代码库中）？

这样想：我们大多数人都同意，至少在某种程度上，我们应该建立自己的内部功能，对输入参数进行一些防御性检查，以减少/防止意料之外的问题。

过分信任输入：

```js
function addNumbers(x,y) {
	// + is overloaded with coercion to also be
	// string concatenation, so this operation
	// isn't strictly safe depending on what's
	// passed in.
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// "2121"
```

防御不可信输入：

```js
function addNumbers(x,y) {
	// ensure numerical input
	if (typeof x != "number" || typeof y != "number") {
		throw Error( "Bad parameters" );
	}

	// if we get here, + will safely do numeric addition
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// Error: "Bad parameters"
```

或者也许仍然安全但友好：

```js
function addNumbers(x,y) {
	// ensure numerical input
	x = Number( x );
	y = Number( y );

	// + will safely do numeric addition
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// 42
```

但是你去的话，这些各种各样的检查/正火是相当普遍的功能的输入，即使我们在理论上完全信任代码。在某种程度上，这就像是“信任但核实”的地缘政治原则的编程。

所以，没有立场的原因，我们应该如何异步函数回调成分相同的东西，不是真正的外码，但即使我们知道代码一般是“我们自己的控制下？**当然，我们应该。**

但回调真的不提供任何协助我们。我们要构建所有机械自己，它经常会被大量的样板/开销，为每一个异步回调我们重复。

而回调的最棘手的问题是_控制反转_导致所有这些信任线的彻底崩溃。

如果你有使用回调函数的代码，特别是但不限于与第三方工具，你不是已经将一些缓解所有这些逻辑_控制反转_信任问题，代码_有_尽管它可能还没有咬过你，但现在它已经有了虫子。潜在的bug仍然是bug。

地狱确实。

## 试图保存回调

有几种回调设计试图解决一些问题（不是所有的）！我们刚才看到的信任问题。这是一个勇敢的，但注定，努力挽救回调格局崩溃本身。

例如，对于更优美的错误处理，分回调提供一些API的设计（一个成功的通知，一个用于错误通知）：

```js
function success(data) {
	console.log( data );
}

function failure(err) {
	console.error( err );
}

ajax( "http://some.url.1", success, failure );
```

在这种设计的api中，通常`failure()`错误处理程序是可选的，如果没有提供，它将被假定为希望错误被吞噬。啊。

**注：**这种分裂的回收设计是什么6保证API使用。我们将在下一章中更详细的ES6承诺。

另一个常见的回调模式被称为“错误第一式”（有时称为“节点样式，“这也是在几乎所有的会议使用Node.js API），在一个单一的回调方法的第一个参数是一个错误的对象（如果有）。如果成功，这种说法会空/ falsy（和任何

```js
function response(err,data) {
	// error?
	if (err) {
		console.error( err );
	}
	// otherwise, assume success
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", response );
```

在这两种情况下，应该观察几件事情。

首先，它并没有真正解决像它可能出现的大多数信任问题。有关于防止不必要的重复回调或过滤器调用什么。而且，现在情况更糟了，因为你可能会获得成功和错误信号，或者两者都没有，而且你仍然需要围绕这些条件中的任何一个来编码。

另外，不要忽略了这样的事实：虽然这是一个标准的模式可以使用，绝对是更冗长的样板ISH没有重用，所以你会厌倦打字了这一切为您的应用程序中的每一个回调。

没有被告知的信任问题怎么办？如果这是一个问题（也许它应该是！）您可能需要设置一个取消事件的超时时间。你可以做一个实用程序（只显示概念的证明）来帮助你做到这一点：

```js
function timeoutify(fn,delay) {
	var intv = setTimeout( function(){
			intv = null;
			fn( new Error( "Timeout!" ) );
		}, delay )
	;

	return function() {
		// timeout hasn't happened yet?
		if (intv) {
			clearTimeout( intv );
			fn.apply( this, [ null ].concat( [].slice.call( arguments ) ) );
		}
	};
}
```

以下是你如何使用它：

```js
// using "error-first style" callback design
function foo(err,data) {
	if (err) {
		console.error( err );
	}
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", timeoutify( foo, 500 ) );
```

另一个信任问题被称为“为时过早”。在特定于应用程序的术语中，这可能实际上涉及到在某些关键任务完成之前调用。但更普遍的问题是，公用事业中的问题很明显，可以调用您提供的回调。_现在_（同步），或_后来_（异步）。

这种不确定性在同步或异步行为几乎总是会导致很难跟踪错误。在某些圈子里，诱导怪物命名该虚构的疯狂是用来描述同步/异步的噩梦。”不要释放Zalgo！”是一种常见的哭，这导致了很中肯的意见：总是调用回调函数是异步的，即使是“马上”的事件循环的下一轮，这样可以异步回调。

**注：**在该的更多信息，见Oren Golan“不释放Zalgo！”（<https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md>）和Isaac Z. Schlueter的“设计的API不同步”（<http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony>）。

考虑：

```js
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", result );
a++;
```

这个代码会打印吗？`零`（同步回调调用）或`一`（异步回调调用）？取决于…关于条件。

你能看到的只是如何快速Zalgo的不可预测性可以威胁任何JS程序。这样听起来很傻的“不释放Zalgo”实际上是非常常见的和可靠的建议。永远asyncing。

如果你不知道问题的API将永远执行异步？你可以发明这样的工具`asyncify（..）`概念证明：

```js
function asyncify(fn) {
	var orig_fn = fn,
		intv = setTimeout( function(){
			intv = null;
			if (fn) fn();
		}, 0 )
	;

	fn = null;

	return function() {
		// firing too quickly, before `intv` timer has fired to
		// indicate async turn has passed?
		if (intv) {
			fn = orig_fn.bind.apply(
				orig_fn,
				// add the wrapper's `this` to the `bind(..)`
				// call parameters, as well as currying any
				// passed in parameters
				[this].concat( [].slice.call( arguments ) )
			);
		}
		// already async
		else {
			// invoke original function
			orig_fn.apply( this, arguments );
		}
	};
}
```

你用`asyncify（..）`这样地:

```js
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", asyncify( result ) );
a++;
```

Ajax请求是否在缓存中，并决定立即调用回调，或者必须通过导线获取，从而异步完成，该代码将始终输出。`一`而不是`零`——`结果（…）`不能异步调用，这意味着`+ +`有机会跑之前`结果（…）`做.

是的，另一个信托发行“解决”！但它是低效的，而衡量你的项目下来更臃肿的样板。

这只是个故事，一遍又一遍，而回调。他们可以做你想做的任何事情，但是你必须愿意努力去得到它，而且通常这种努力远远超出你可以或应该花在这种代码推理上的花费。

您可能会发现自己希望内置API或其他语言机制来解决这些问题。最后6已经赶到现场与一些伟大的答案，所以继续阅读！

## 回顾

回调异步JS的基本单位。但他们没有足够的异步编程的不断变化的景观为JS的成熟。

首先，我们的大脑做计划的顺序，阻塞，单线程语义方面，但回调表示异步流而在非线性、非顺序的方式，使得推理正确这样的代码更难。对代码不好的原因是导致坏错误的坏代码。

我们需要一种以同步、连续、阻塞的方式来表达异步的方法，就像我们的大脑所做的那样。

其次，更重要的是，回调遭受_控制反转_他们含蓄地控制另一方（通常是第三方效用，而不是你的控制！）调用_延续_你的程序。这种控制转移给我们带来了一系列麻烦的信任问题，比如回调的调用次数是否比我们期望的要多。

发明特设逻辑解决信任问题是可能的，但它是更加困难比它应该的，它产生的更难维护的代码，以及代码可能不够受这些危险直到你得到明显的虫子咬伤。

我们需要一个广义解。**所有的信任问题**，一个可重复使用的回调为我们创造的所有额外开销没有样板。

我们需要更好的东西比回调。他们已经很好地为我们服务了，但_未来_JavaScript的要求更复杂的和有能力的异步模式。本书后面的章节将深入到这些新兴的进化中。
