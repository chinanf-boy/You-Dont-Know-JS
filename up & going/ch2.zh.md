
# 你不知道JS：向上走

# 第2章：JavaScript

在前面的章节中，我介绍了编程的基本构建块，如变量、循环、条件和功能。当然，所有显示的代码都是JavaScript的。但是在这一章中，我们要特别关注JavaScript作为一个js开发人员需要去做的事情。

我们将在本章介绍相当多的概念，直到以后才充分探讨。_ydkjs_书.您可以将本章看作是本系列其余部分中详细讨论的主题的概述。

特别是如果您是JavaScript新手，您应该花相当多的时间在这里多次回顾概念和代码示例。任何好的基础都是砖砌的，所以不要指望你第一次通过就可以立刻理解它。

您深入学习JavaScript的旅程从这里开始。

**注：**正如我在第1章中所说的，您应该在阅读并完成本章的过程中亲自尝试所有这些代码。注意，这里的一些代码假定了在撰写本文时，JavaScript的最新版本的功能（通常被称为“6”为ECMAScript第六版——JS规范的正式名称）。如果你碰巧使用的是旧的，pre-es6浏览器，代码可能不工作。最新更新的现代浏览器（如Chrome浏览器、火狐浏览器或IE浏览器）应该被使用。

## 值和类型

正如我们在第1章中断言的那样，JavaScript具有类型化的值，而不是类型变量。以下内置类型可用：

-   `一串`
-   `数`
-   `布尔`
-   `无效的`和`未定义`
-   `对象`
-   `符号`（新6）

JavaScript提供了一个`类型`运算符，它可以检查一个值并告诉您它是什么类型：

```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```

的返回值`类型`运营商是六（七为ES6！-“符号”类型）字符串值。这是，`类型的“ABC”`返回`“字符串”`，不`一串`。

注意在这个片段中`一`变量持有各种不同类型的价值，而不管外表如何，`种类`不是要求“类型”`一`“，而不是当前值的类型`一`“只有JavaScript中有值类型，变量只是这些值的简单容器。

`类型的空`是一个有趣的案例，因为它错误地返回`“对象”`当你期待它回来的时候`“空”`。

**警告：**这是js中的一个由来已久的bug，但很可能永远不会被修复。网络上过多的代码依赖于bug，因此修复它会导致更多的bug！

同时，注意`一个未定义的`。我们明确设置`一`到`未定义`值，但那是行为变量，但没有价值没有不同，喜欢用`VaR；`在代码片段顶部的行。变量可以以几种不同的方式到达这个“未定义”值状态，包括返回值的函数和`无效`算子。

### 物体

这个`对象`类型指的是一个复合值，您可以在其中设置属性（命名位置），每个属性都保存自己的任何类型的值。这可能是所有JavaScript中最有用的值类型之一。

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

想到这个也许会有帮助。`obj`价值的视觉：

<img src=“图4. PNG”>

属性可以访问_点符号_（即，`一个目标。`）或_括号记法_（即，`OBJ [”]`）。点记法较短，通常更容易阅读，因此在可能的情况下是首选的。

括号符号是有用的，如果你有一个属性名称，其中有特殊字符，如`OBJ [“Hello World！”]`-这些属性通常被称为_钥匙_当通过括号符号访问时。这个`[ ]`符号需要一个变量（解释下一个）或`一串`字面意义的_（需要裹在里面）_“..”`或`“..”`）。`当然，如果您希望访问属性/键，但名称存储在另一个变量中，括号表示法也很有用，例如：

注：

```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```

**有关JavaScript的更多信息**对象`s，参见`对象原型_本系列的标题，特别是第3章。_JavaScript程序中通常会有两种其他的值类型相互作用：

阵列_和_功能_。但是，与其说是适当的内置类型，不如说它们更像是子类型——特定版本的_对象`型。`阵列

#### 数组是

对象`它保存值（任何类型），特别是在命名的属性/键中，而不是在数值索引位置。例如:`注：

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```

**开始计算零的语言，像js那样，使用**零`作为数组中第一个元素的索引。`考虑一下也许会有帮助。

ARR`视觉上:`&lt;img src=“图5。png”>

因为数组是特殊对象（如

类型`意味着，它们也可以拥有属性，包括自动更新。`长度`财产。`理论上，您可以使用自己命名的属性使用数组作为普通对象，也可以使用

对象`但只给它数字属性（`零`，`一`类似于数组。然而，这个我`类似于数组。然而，这通常被认为是不恰当地使用各自的类型。

最好和最自然的方法是使用数组进行数值定位的值和使用。`对象`命名属性的。

#### 功能

其他的`对象`在js程序中使用的子类型是一个函数：

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

同样，函数是`物体`——`类型`返回`“功能”`, which implies that a`功能`是一种主要类型——因此可以拥有属性，但通常只使用函数对象属性（如`foo.bar`在有限的情况下。

**注：**有关JS值及其类型的更多信息，请参见_类型与语法_本系列的标题。

### 内建类型方法

我们刚才讨论的内置类型和子类型的行为暴露为属性和方法，这些功能和方法非常强大和有用。

例如:

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

能打电话的“背后”`A. touppercase()`比在价值上存在的方法更复杂。

简单地说，有一个`字符串`（资本`S`对象包装器表单，通常称为“原生”，与原语配对。`一串`类型；这个对象包装器定义`touppercase()`原型法。

当使用原始值时`“你好，世界”`作为一个`对象`通过引用属性或方法（例如，`A. touppercase()`在前一段代码中，js自动将“值”框对象包装器对应（隐藏在封面下）。

一`一串`值可以由a包装`字符串`一个对象，`数`可以被一个`数`对象，以及`布尔`可以被一个`布尔`对象。在大多数情况下，您不必担心或直接使用这些对象包装器的值形式——实际上在所有情况下都更喜欢原始值表单，JavaScript会为您处理剩下的部分。

**注：**有关JS本地人和“拳击”的更多信息，请参阅第3章_类型与语法_本系列的标题。为了更好地理解一个对象的原型，请参阅第5章_对象原型_本系列的标题。

### 比较值

在js程序中需要进行两种主要的比较：_平等_和_不平等_。任何比较的结果都是严格的。`布尔`价值（`真正的`或`假`），不管什么类型的值比较。

#### 强制

我们在第1章中简单地谈到了胁迫，但是让我们在这里重新讨论一下。

强制在JavaScript中有两种形式：_明确的_和_隐性的_。显式强制只是简单地从代码中看到从一种类型到另一种类型的转换会发生，而隐式强制是当类型转换发生在其他操作的非明显的副作用时。

你可能听过这样的说法：“强迫是邪恶的”，因为有明显的地方强迫可以产生一些令人吃惊的结果。也许没有什么比语言让他们感到惊讶更让开发者感到沮丧了。

胁迫不是罪恶，也不必令人惊讶。事实上，可以用类型强制构建的大多数情况是相当明智和可理解的，甚至可以用于_改善_代码的可读性。但我们不会再深入讨论那场辩论——第4章_类型与语法_本系列的标题涵盖所有方面。

下面是一个例子_明确的_强制：

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

下面是一个例子_隐性的_强制：

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#### 真相与falsy

在1章中，我们简要地提到了“真相”和“falsy”属性值：当一个非—`布尔`值被强制为`布尔`它变成了吗？`真正的`或`假`，分别？

具体名单“falsy”价值观在JavaScript如下：

-   `“”`（空字符串）
-   `零`，`- 0`，`南`（无效`数`）
-   `无效的`，`未定义`
-   `假`

任何的价值，不在这个“falsy”列表中的“真相”。这里是一些例子的：

-   `“你好”`
-   `四十二`
-   `真正的`
-   `[ ]`，`[ 1，“2”，3）`（阵）
-   `{ }`，`{ A：42 }`（对象）
-   `功能foo() { ..}`（功能）

记住一个不重要的是很重要的—`布尔`价值只有遵循这一“真相”/“falsy“强制如果真是强迫一个`布尔`。给自己一个局面，似乎强迫值到迷惑是不是所有的困难`布尔`如果不是。

#### 平等

有四个相等运算符：`= =`，`= = =`，`！=`，和`！= =`。这个`！`表单当然是它们对应的对称的“不相等”的版本；_不平等_不应混淆_不平等_。

之间的差异`= =`和`= = =`通常的特点是`= =`检查价值平等和`= = =`检查值和类型相等。然而，这是不准确的。描述它们的正确方法是`= =`允许使用强制检查值相等，并且`= = =`不允许强制检查价值平等；`= = =`之所以被称为“严格平等”，是因为这个原因。

考虑一下允许的隐式强制。`= =`松散的平等比较和不允许的`= = =`严格的平等：

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

在`a = b`比较，js注意到类型不匹配，所以它经过一系列有序的步骤来强制一个或两个值到不同类型，直到类型匹配，然后可以检查一个简单的值相等。

如果你考虑一下，有两种可能的方法`a = b`可以给`真正的`通过强制。或者，比较结果可能是`42 = 42`或者它可能是`“42”=“42”`。那是哪一个？

答案：`“42”`成为`四十二`进行比较`42 = 42`。在这样一个简单的例子中，流程的执行方式并不重要，因为最终的结果是一样的。更复杂的情况下，问题不仅仅是比较的最终结果，而是_怎样_你到那里去。

这个`a = b`生产`假`因为强制是不允许的，所以简单值比较显然失败。许多开发人员觉得`= = =`更容易预测，所以他们主张总是使用这种形式，远离。`= =`。我认为这种观点很短视。我相信`= =`是一个功能强大的工具，可以帮助你的程序，_如果你花时间去学习它是如何工作的。_

我们不去盖如何强制在所有的细节`= =`比较工作在这里。其中大部分是相当明智的，但也有一些重要的角落的情况下要小心。你可以阅读的11.9.3（ES5规格部分<http://www.ecma-international.org/ecma-262/5.1/>）看到确切的规则，你会惊讶于这个机制是多么简单，而不是围绕它的所有负面宣传。

煮了很多细节，简单的几点，帮助你了解是否使用`= =`或`= = =`在各种情况下，以下是我的简单规则：

-   如果比较中的任一值（又名侧）可能是`真正的`或`假`值，避免`= =`和使用`= = =`。
-   如果比较中的任一值可以是这些特定值（`零`，`“”`，或`[ ]`-空数组），避免`= =`和使用`= = =`。
-   在_全部的_其他情况下，你可以安全使用`= =`。它不仅安全，而且在许多情况下简化了代码，提高了可读性。

这些规则归结为要求您对代码进行批判性的思考，并通过比较不同的变量来判断哪些值可以通过。如果你能确定这些值，并且`= =`是安全的，使用它！如果不能确定这些值，请使用`= = =`。就是这么简单。

这个`！=`非相等形式对`= =`，和`！= =`形成对`= = =`。我们刚才讨论的所有规则和意见都是对称的，它们是不平等的比较。

你应该特别注意`= =`和`= = =`比较两个非原始值时，比较规则如下`对象`S（包括`功能`和`阵列`）。因为这些值实际上是通过引用保存的，都是`= =`和`= = =`比较将简单地检查引用是否匹配，而不是关于底层值的任何内容。

例如,`阵列`默认情况下，S被强制`一串`只需用逗号连接所有的值。`，`）两者之间。你可能会认为那是两个`阵列`S的内容相同`= =`平等，但他们不是：

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

**注：**有关更多信息`= =`平等比较规则，看到ES5规范（第11.9.3）并参照4章_类型与语法_本系列的标题；参见第2章，了解关于值与引用的更多信息。

#### 不平等

这个`<`，`>`，`< =`，和`> =`运营商用于不等式，指在规范为“关系比较”。他们通常会用像依次比较值`数`这很容易理解。`3＜4`。

但JavaScript`一串`使用典型的字母规则也可以比较不相等的值。`“bar”< <“”`）。

那胁迫呢？类似的规则`= =`比较（虽然不完全相同）！应用于不等式运算符。值得注意的是，有没有“严格不等式”的运营商，不允许强迫一样`= = =`“严格平等”。

考虑：

```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

这里发生了什么？在11.8.5 ES5规格部分，它说，如果在这两个值`<`比较`一串`S，因为它是`B＜C`，比较了字典（又名字母像一本字典）。但如果一个或两个不是`一串`因为它是`< B`然后，两个值都被强制为`数`以及一个典型的数值比较。

最大的问题你可能会遇到在比较不同类型的潜在价值——记住，没有“严格不等式”形式使用，当一个人的价值观不能制成有效的数字，如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

等等，这三个比较怎么可能是`假`？因为`B`值被强制为“无效数字值”。`南`在`<`和`>`比较，规格说明说`南`既不大于也不小于任何其他值。

这个`= =`比较因不同原因而失败。`a = b`可能失败，如果它被解释为`42 =南`或`“42”=“富”`正如我们前面所解释的，前者就是这种情况。

**注：**关于不等式的比较规则的更多信息，参见的ES5规范第11.8.5也参照4章_类型与语法_本系列的标题。

## 变量

在JavaScript中，变量名（包括函数名）必须是有效的。_标识符_。当考虑非传统字符（如Unicode）时，标识符中有效字符的严格和完整规则有点复杂。如果只考虑典型的ASCII字母数字字符，规则很简单。

标识符必须以`一`—`Z`，`一`—`Z`，`美元`，或`_`。然后它可以包含这些字符中的任何一个，加上数字。`零`—`九`。

一般来说，相同的规则也适用于属性名和变量标识符。但是，某些单词不能用作变量，但可以作为属性名使用。这些单词被称为“保留词”，并包含JS关键字（`对于`，`在里面`，`如果`以及）`无效的`，`真正的`，和`假`。

**注：**有关保留字的更多信息，请参阅附录A_类型与语法_本系列的标题。

### 功能范围

你用`VaR`关键字声明一个变量，该变量将属于当前函数作用域，或全局函数，如果在任何函数之外的最高级别上。

#### 吊装

哪里有`VaR`出现在一个范围内，该声明被视为属于整个范围，并在任何地方都可访问。

打个比方，这种行为称为“_吊装_，当`VaR`声明在概念上“移动”到其封闭范围的顶部。从技术上讲，这个过程更准确地解释代码是如何编译的，但是现在我们可以跳过这些细节。

考虑：

```js
var a = 2;

foo();					// works because `foo()`
						// declaration is "hoisted"

function foo() {
	a = 3;

	console.log( a );	// 3

	var a;				// declaration is "hoisted"
						// to the top of `foo()`
}

console.log( a );	// 2
```

**警告：**依赖变量是不常见的，也不是好主意。_吊装_在其作用域之前使用变量`VaR`声明出现；它可能相当混乱。使用它更为普遍和接受。_悬挂_函数声明，正如我们使用`foo()`正式声明前出现的电话。

#### 嵌套作用域

在声明变量时，它可以在该范围内的任何地方以及任何较低/内部范围内使用。例如:

```js
function foo() {
	var a = 1;

	function bar() {
		var b = 2;

		function baz() {
			var c = 3;

			console.log( a, b, c );	// 1 2 3
		}

		baz();
		console.log( a, b );		// 1 2
	}

	bar();
	console.log( a );				// 1
}

foo();
```

注意：`C`内部不可用`bar()`因为它只在内部声明`baz()`范围，以及`B`不可用`foo()`出于同样的理由。

如果您试图在不可用的范围内访问变量的值，您将得到一个`引用错误`扔。如果您试图设置一个尚未声明的变量，那么您最终将在顶级全局范围内创建一个变量（糟糕！）或根据“严格模式”（见“严格模式”）获取错误。让我们看一看：

```js
function foo() {
	a = 1;	// `a` not formally declared
}

foo();
a;			// 1 -- oops, auto global variable :(
```

这是一次很糟糕的练习。不要这样做！总是正式声明变量。

除了在功能层面创造声明变量，ES6_让_您声明变量属于各个块（对`{ ..}`，使用`让`关键词。除了一些微妙的细节，作用域规则的行为大致相同，只是我们看到的功能：

```js
function foo() {
	var a = 1;

	if (a >= 1) {
		let b = 2;

		while (b < 5) {
			let c = b * 2;
			b++;

			console.log( a + c );
		}
	}
}

foo();
// 5 7 9
```

由于采用`让`而不是`VaR`，`B`只属于`如果`声明而不是全部`foo()`函数作用域。同样，`C`只属于`虽然`环。块作用域在更细粒度的时尚你的变量范围管理是非常有用的，它可以使你的代码更容易维护时间。

**注：**有关范围的更多信息，请参见_范围和关闭_本系列的标题。看到_6与超越_本系列的标题了解更多信息`让`块作用域。

## 条件句

除了`如果`我们在1章简要介绍了声明，JavaScript提供了一些其他条件的机制，我们应该看一看。

有时你会发现自己写了一系列的`如果…如果`这样的陈述：

```js
if (a == 2) {
	// do something
}
else if (a == 10) {
	// do another thing
}
else if (a == 42) {
	// do yet another thing
}
else {
	// fallback to here
}
```

这个结构有效，但它有点冗长，因为您需要指定`一`每个案例的测试。这是另一种选择，`转换`声明：

```js
switch (a) {
	case 2:
		// do something
		break;
	case 10:
		// do another thing
		break;
	case 42:
		// do yet another thing
		break;
	default:
		// fallback to here
}
```

这个`打破`如果只希望语句在一个中，那么这一点很重要。`案例`运行。如果省略`打破`从一个`案例`，，，`案例`匹配或运行，将继续执行下一步。`案例`的陈述，不管那`案例`匹配.这种所谓的“失败”有时是有用的/需要的：

```js
switch (a) {
	case 2:
	case 10:
		// some cool stuff
		break;
	case 42:
		// other stuff
		break;
	default:
		// fallback
}
```

在这里，如果`一`要么是`二`或`十`它将执行“一些很酷的东西”代码语句。

JavaScript中条件的另一种形式是“条件操作符”，通常称为“三元运算符”。`如果..否则`语句，例如：

```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

如果测试表达式（`一> 41`在这里）评估为`真正的`第一句（`“你好”`结果，否则第二条（`“世界”`结果，然后将结果分配给`B`。

条件运算符不必在赋值中使用，但这绝对是最常用的用法。

**注：**有关测试条件和其他模式的更多信息`转换`和`？：`，看到_类型_本系列的标题。

## 严格模式

ES5添加了一个“严格模式”的语言，这使某些行为的规则。一般来说，这些限制被视为将代码保持在更安全、更合适的指导方针中。同时，坚持严格的方式使你的代码更优化的引擎。严格模式是代码的一大胜利，你应该在所有程序中使用它。

你可以选择在严格的方式对个体的功能，或整个文件，这取决于你把严格模式编译：

```js
function foo() {
	"use strict";

	// this code is strict mode

	function bar() {
		// this code is strict mode
	}
}

// this code is not strict mode
```

相比之下：

```js
"use strict";

function foo() {
	// this code is strict mode

	function bar() {
		// this code is strict mode
	}
}

// this code is strict mode
```

一个关键的区别（改进！）以严格的方式是不允许隐式自动全局变量声明省略`VaR`：

```js
function foo() {
	"use strict";	// turn on strict mode
	a = 1;			// `var` missing, ReferenceError
}

foo();
```

如果你在你的代码中打开了严格的模式，并且你犯了错误，或者代码开始运行，你的诱惑可能是避免严格的模式。但是这种本能放纵是个坏主意。如果严格的模式导致程序中的问题，几乎可以肯定这是一个标志，表明程序中有一些东西需要修复。

不仅将严格的方式让你的代码到一个更安全的路径，不仅会使你的代码更优化，但它也体现了语言的未来发展方向。你现在更习惯于严格的模式，而不是不断地拖延它，以后只会变得更难转换！

**注：**有关严格模式的更多信息，请参见第5章_类型与语法_本系列的标题。

## 功能价值

到目前为止，我们已经讨论了作为主要机制的函数。_范围_在JavaScript。你记得典型`功能`声明语法如下：

```js
function foo() {
	// ..
}
```

尽管这个语法似乎不太明显，`Foo`基本上只是一个变量，在外包围范围内，它被引用到`功能`被宣布。也就是说`功能`本身就是一种价值，就像`四十二`或`[1,2,3]`将。

这听起来可能是一个奇怪的概念，所以先花点时间考虑一下。不仅可以传递值（参数）_到_函数，但_函数本身可以是一个值。_它被赋值给变量，或者从其他函数传递到或返回。

因此，函数值应该被看作是一种表达式，类似于任何其他值或表达式。

考虑：

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

分配给该函数的第一个函数表达式。`Foo`变量被称为_匿名_因为它没有`名称`。

第二个函数表达式是_命名_（`酒吧`）即使是对它的引用也被分配给`X`变量。_命名函数表达式_一般来说更可取，不过_匿名函数表达式_仍然非常普遍。

有关更多信息，请参见_范围和关闭_本系列的标题。

### 立即调用函数的表达式（iifes）

在前一段代码中，既不执行函数表达式，也不可能包含`foo()`或`x()`例如。

执行函数表达式还有另一种方法，通常称为_立即调用函数表达式_（生活）：

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```

外`（..）`围绕`（功能iife() { ..}）`函数表达式只是js语法的一个细微差别，它需要防止它被当作正常函数声明。

最后的`（）`表达式的结尾——`}）；`行——实际执行它前面引用的函数表达式。

这似乎有些奇怪，但乍看起来并不陌生。考虑到两者之间的相似之处`Foo`和`生活`在这里:

```js
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

如您所见，列出`（功能iife() { ..}）`在其执行`（）`基本上是相同的，包括`Foo`在其执行`（）`在这两种情况下，函数引用都是用`（）`紧接着。

因为生活是一个函数，并且函数创建变量_范围_，使用生活这种方式通常用于声明变量，不会影响周围的代码之外的生活：

```js
var a = 42;

(function IIFE(){
	var a = 10;
	console.log( a );	// 10
})();

console.log( a );		// 42
```

iifes也可以有返回值：

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

这个`四十二`价值获取`返回`由`生活`命名函数正在执行，然后分配给`X`。

### 关闭

_关闭_是JavaScript中最重要也是最不理解的概念之一。我不会在这里详细介绍，而是请你参考_范围和关闭_本系列的标题。但我想说几点，这样你就明白了一般概念。这将是一个在你的JS技能的最重要的技术。

您可以将闭包视为“记住”并继续访问函数的作用域（其变量）的方法，即使该函数已经完成运行。

考虑：

```js
function makeAdder(x) {
	// parameter `x` is an inner variable

	// inner function `add()` uses `x`, so
	// it has a "closure" over it
	function add(y) {
		return y + x;
	};

	return add;
}
```

内在参照`添加（..）`在每次调用外部时返回的函数。`makeadder（..）`能记住什么`X`值被传递到`makeadder（..）`。现在，让我们使用`makeadder（..）`：

```js
// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );		// 4  <-- 1 + 3
plusOne( 41 );		// 42 <-- 1 + 41

plusTen( 13 );		// 23 <-- 10 + 13
```

更多关于这个代码如何工作：

1.  我们打电话的时候`（1）makeadder`我们得到了它内部的一个参考。`添加（..）`记得`X`作为`一`。我们称之为函数引用。`还有（..）`。
2.  我们打电话的时候`（10）makeadder`我们得到了另一个关于它内部的参考。`添加（..）`记得`X`作为`十`。`plusten（..）`。
3.  我们打电话的时候`还有（3）`，它增加了`三`（其内`Y`）的`一`（记住`X`我们得到`四`作为结果。
4.  我们打电话的时候`（13）plusten`，它增加了`十三`（其内`Y`）的`十`（记住`X`我们得到`二十三`作为结果。

不要担心，如果这看起来很奇怪和混乱的第一-它可以！要充分理解它需要大量的练习。

但是相信我，一旦你这么做了，这是所有编程中最强大和最有用的技术之一。值得一试，让你的大脑冷静一下。在下一节中，我们将得到更多的闭包练习。

#### 模块

在JavaScript中闭包最常用的方式是模块模式。模块让您定义隐藏在外部世界中的私有实现细节（变量、函数），以及公共API。_是_从外面看。

考虑：

```js
function User(){
	var username, password;

	function doLogin(user,pw) {
		username = user;
		password = pw;

		// do the rest of the login work
	}

	var publicAPI = {
		login: doLogin
	};

	return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( "fred", "12Battery34!" );
```

这个`user()`函数充当容纳变量的外部范围。`用户名`和`密码`以及内在的`dologin()`函数；这些都是私有的内部细节。`用户`无法从外部世界访问的模块。

**警告：**我们没有打电话`新的user()`在这里，有意的，尽管这似乎对大多数读者来说都是常见的。`user()`只是一个函数，而不是一个要实例化的类，所以它通常被称为函数。使用`新的`是不恰当的，实际上是浪费资源。

执行`user()`创建一个_实例_的`用户`模块——创建一个全新的范围，从而为每个内部变量/函数提供一个全新的副本。我们将这个实例分配给`弗莱德`。如果我们运行`user()`同样，我们将得到一个完全独立于此的新实例。`弗莱德`。

内`dologin()`函数有一个结束`用户名`和`密码`也就是说，即使在`user()`功能结束运行。

`publicapi`是一个具有一个属性/方法的对象，`登录`这是对内部的一个参考。`dologin()`功能。当我们回来的时候`publicapi`从`user()`它变成了我们调用的实例`弗莱德`。

在这一点上，外面`user()`函数已完成执行。通常，你会认为内部变量是这样的。`用户名`和`密码`已经走了。但在这里他们没有，因为有一个封闭的`login()`使他们活着的功能。

这就是为什么我们可以打电话`弗莱德登录（..）`-和调用内部一样`doLogin（..）`-它仍然可以访问`用户名`和`密码`内部变量。

有一个很好的机会，只需简单地一瞥闭包和模块模式，其中一些仍然有点混乱。没关系!它需要一些工作来包装你的大脑围绕它。

从这里开始读_范围和关闭_本系列的标题是为了更深入的探索。

## `这`标识符

JavaScript中另一个非常常见的误解是`这`标识符。再说一遍，里面有几个章节。_对象原型_这个系列的标题，下面我们简单介绍一下这个概念。

虽然它似乎常常`这`与JS中的“面向对象的模式”相关。`这`是不同的机制。

如果函数有一个`这`参考里面，`这`引用通常指向`对象`。但这`对象`它取决于调用函数的方式。

认识到这点很重要。`这`不_请参考函数本身，这是最常见的误解。_这里有一个快速的例子：

有四条规则

```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

// --------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );		// "obj2"
new foo();			// undefined
```

这`获取并设置在该代码段的最后四行中。`foo()

1.  `最终设置`这`对非严格模式的全局对象——严格模式，`这`将`未定义`而且您在访问`酒吧`财产，所以`“全球”`是找到的值吗？`this.bar`。`foo() obj1。
2.  `集`这`到`obj1`对象。`foo调用（obj2）。
3.  `集`这`到`obj2`对象。`新的foo()
4.  `集`这`一个全新的空物体。`底线：了解什么

这`指向，你必须检查这个函数是如何被调用的。这将是这四种方式中的一种，它将回答什么。`这`是.`注：

**有关更多信息**这`见第1章和第2章`对象原型_本系列的标题。_原型

## JavaScript中的原型机制相当复杂。我们只会在这里浏览一下。你要花很多时间复习第4-6章的内容。

对象原型_本系列的所有细节的标题。_当引用对象上的属性时，如果该属性不存在，JavaScript将自动使用该对象的内部原型引用来查找另一个对象来查找。你可以认为这几乎是一个后备如果缺少财产。

从一个对象到它的回退的内部原型引用链接发生在对象创建时。最简单的说明方法是调用内置的实用工具。

对象创建（..）`。`考虑：

它可以帮助

```js
var foo = {
	a: 42
};

// create `bar` and link it to `foo`
var bar = Object.create( foo );

bar.b = "hello world";

bar.b;		// "hello world"
bar.a;		// 42 <-- delegated to `foo`
```

这可能有助于形象化`Foo`和`酒吧`对象及其关系：

<img src=“图PNG”>

这个`一`属性实际上不存在于`酒吧`对象，但因为`酒吧`原型链接到`Foo`JavaScript自动回落到寻找`一`上`Foo`对象，在它被找到的地方。

这种联系似乎是语言的一个奇怪的特征。使用这个特性最常见的方式——我认为，被滥用——就是试图模仿/伪造带有继承的“类”机制。

但是应用原型的一种更自然的方式是一种称为“行为委托”的模式，在这个模式中，您有意地设计您的链接对象，以便能够_代表_从一个到另一个需要的行为的一部分。

**注：**有关原型和行为委托的更多信息，请参见_对象原型_本系列的标题。

## 新与旧

我们已经涉及到的一些JS特性，当然还有本系列其余部分所涵盖的许多特性，都是新增加的，在旧浏览器中不一定可用。事实上，规范中的一些最新特性甚至没有在任何稳定的浏览器中实现。

那么，你用这些新材料做什么呢？你是否需要等上几年或几十年，让所有旧的浏览器淡出默默无闻？

这就是很多人对这种情况的看法，但对JS来说这并不是一个健康的方法。

目前主要有两种技术可以“带来”新的JavaScript的东西老的浏览器：polyfilling和transpiling。

### polyfilling

“polyfill”是一个发明的术语（Remy Sharp）（<https://remysharp.com/2010/10/08/what-is-a-polyfill>）用于指取新特性的定义并生成与行为相当的代码，但可以在较旧的JS环境中运行。

例如，定义了一个工具叫ES6`数。isnan（..）`提供准确无车支票`南`价值贬的原`isnan（..）`效用。但是很容易polyfill效用以便你可以使用它在您的代码中，无论用户是在一个6浏览器或不。

考虑：

```js
if (!Number.isNaN) {
	Number.isNaN = function isNaN(x) {
		return x !== x;
	};
}
```

这个`如果`声明防应用定义浏览器polyfill ES6那里将已经存在。如果它还没有出现，我们定义`数。isnan（..）`。

**注：**我们在这里做的检查是利用了一个怪癖。`南`值，也就是说，它们是整个语言中唯一不等于自身的值。所以`南`价值观是唯一能创造价值的东西。`X！= = x`是`真正的`。

不是所有的新功能是完全polyfillable。有时，大多数的行为可以polyfilled，但仍有小的偏差。你真的应该在实现自己一个polyfill非常小心，以确保你坚持尽可能严格的规范。

或者更好的是，使用一个已经审核组polyfills可以信任的，如那些由ES5垫片提供（<https://github.com/es-shims/es5-shim>）和垫片（ES6<https://github.com/es-shims/es6-shim>）。

### transpiling

有没有办法polyfill新语法已被添加到语言。新语法将在旧JS引擎中抛出一个不可识别/无效的错误。

更好的选择是使用一种工具，将新代码转换成旧代码等价物。这个过程通常被称为“transpiling，“转化+编译期。

从本质上讲，你的源代码是写在新的语法形式，而是你部署到浏览器是transpiled码在旧的语法形式。通常你将transpiler到您的构建过程，类似于你的代码短绒或缩小镜。

你可能想知道为什么你会去麻烦写新的语法不仅有transpiled去旧的代码--为什么不写旧的代码直接？

你应该关心transpiling的几个重要原因：

-   添加到该语言的新语法是为了使代码更易读和可维护而设计的。较老的对等词通常更为复杂。您应该更喜欢编写更新的、更干净的语法，不仅是为您自己，也是为开发团队的所有其他成员编写的。
-   如果你transpile只有旧的浏览器，但服务新语法的最新的浏览器，你可以利用与新语法浏览器性能优化。这也让浏览器制造商拥有更真实的代码来测试它们的实现和优化。
-   使用新的语法之前允许它被测试在现实世界中的更强劲，可提供早期反馈给JavaScript（TC39委员会）。如果问题被及早发现，在这些语言设计错误变成永久性之前，它们可以被改变/固定。

这是一个简单的例子transpiling。6添加一种称为“默认参数值”。它看起来像这样：

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

很简单，对吧？也很有帮助！但新的语法，pre-es6引擎的无效。所以会有什么transpiler做代码能运行在旧的环境？

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

哟`论点[ 0 ]`值`无效0`（又名`未定义`）如果有，则提供`二`默认值；否则，它分配传递的内容。

除了能够现在即使在旧的浏览器使用良好的语法，看着transpiled代码实际上解释了预期的行为更清晰。

你可能没有看着6版本实现`未定义`是不能得到明确的通过一个默认值的参数的唯一价值，但transpiled代码会更清晰。

的强调transpilers最后一个重要的细节是，他们现在应该被认为是JS开发生态系统和过程的一个标准部分。js将继续发展，比以前更快，所以每隔几个月就会添加新的语法和新特性。

如果你使用一个transpiler默认情况下，你将永远是能够切换到新的语法，只要你觉得有用，而不是总是等待年今天的浏览器淘汰。

有很多伟大的transpilers供您选择。以下是写作时的一些不错的选择：

-   Babel（<https://babeljs.io>）（原名6to5）：transpiles ES6 +为ES5
-   Traceur（<https://github.com/google/traceur-compiler>）：transpiles ES6，ES7，到超越ES5

## 非JavaScript

到目前为止，我们只讨论了js语言本身。事实上，大多数JS都是为了运行和与浏览器这样的环境进行交互而编写的。严格来说，你在代码中编写的大量内容不是直接由JavaScript控制的。听起来可能有点奇怪。

您遇到的最常见的非JavaScript JavaScript是DOM API。例如:

```js
var el = document.getElementById( "foo" );
```

这个`文件`当您的代码在浏览器中运行时，变量作为全局变量存在。它不是js引擎提供的，也不是JavaScript规范特别控制的。它的形式看起来非常像普通的JS。`对象`但事实并非如此。这是特别的`对象，`通常称为“宿主对象”。

此外，该`getElementById（..）`方法`文件`看起来像一个普通的js函数，但它只是一个稀疏的接口，它是DOM从浏览器提供的内置方法。在一些（新一代）的浏览器，这一层也可以在JS，但是传统的DOM及其行为是更像C / C++实现。

另一个例子是输入/输出（I/O）。

大家都喜欢的`警报（…）`在用户的浏览器窗口中弹出一个消息框。`警报（…）`由浏览器提供给js程序，而不是js引擎本身。您所做的调用将消息发送到浏览器内部，并处理消息框的绘制和显示。

同样的道理`控制台（…）`浏览器提供这些机制，并将它们挂在开发人员的工具上。

这本书，以及整个系列，都集中在JavaScript语言上。这就是为什么您没有看到这些非JavaScript JavaScript机制的实质性报道。然而，你需要意识到它们，因为它们在你写的每一个js程序中都会出现！

## 回顾

学习JavaScript编程风格的第一步是对其核心机制（如值、类型、函数闭包）有一个基本的了解，`这`和原型。

当然，这些主题中的每一个都应该比你在这里看到的更为广泛，但这就是为什么他们在本系列的其余部分中有专门的章节和书籍。在你对本章中的概念和代码样本感到相当满意之后，本系列的其余部分就等着你真正深入了解这门语言。

这本书的最后一章将简要地总结本系列中的每一个标题以及它们所涵盖的其他概念，以及我们已经探索过的内容。
