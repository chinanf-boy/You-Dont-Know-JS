
# 你不知道JS: 向上走

# 第2章: JavaScript

在前面的章节中,我介绍了编程的基本构建块,如变量ㄡ循环ㄡ条件和功能ㄢ当然,所有显示的代码都是JavaScript的ㄢ但是在这一章中,我们要特别关注JavaScript作为一个js开发人员需要去做的事情ㄢ

我们将在本章介绍相当多的概念,直到以后才充分探讨ㄢ_ydkjs_书.您可以将本章看作是本系列其余部分中详细讨论的主题的概述ㄢ

特别是如果您是JavaScript新手,您应该花相当多的时间在这里多次回顾概念和代码示例ㄢ任何好的基础都是砖砌的,所以不要指望你第一次通过就可以立刻理解它ㄢ

您深入学习JavaScript的旅程从这里开始ㄢ

**注: **正如我在第1章中所说的,您应该在阅读并完成本章的过程中亲自尝试所有这些代码ㄢ注意,这里的一些代码假定了在撰写本文时,JavaScript的最新版本的功能(通常被称为"6ℽ为ECMAScript第六版ℴℴJS规范的正式名称)ㄢ如果你碰巧使用的是旧的,pre-es6浏览器,代码可能不工作ㄢ最新更新的现代浏览器(如Chrome浏览器ㄡ火狐浏览器或IE浏览器)应该被使用ㄢ

## 值和类型

正如我们在第1章中断言的那样,JavaScript具有类型化的值,而不是类型变量ㄢ以下内置类型可用: 

-   `一串`
-   `数`
-   `布尔`
-   `无效的`和`未定义`
-   `对象`
-   `符号`(新6)

JavaScript提供了一个`类型`运算符,它可以检查一个值并告诉您它是什么类型: 

```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```

的返回值`类型`运营商是六(七为ES6!-"符号ℽ类型)字符串值ㄢ这是,`类型的"ABCℽ`返回`"字符串ℽ`,不`一串`ㄢ

注意在这个片段中`一`变量持有各种不同类型的价值,而不管外表如何,`种类`不是要求"类型ℽ`一`",而不是当前值的类型`一`"只有JavaScript中有值类型,变量只是这些值的简单容器ㄢ

`类型的空`是一个有趣的案例,因为它错误地返回`"对象ℽ`当你期待它回来的时候`"空ℽ`ㄢ

**警告: **这是js中的一个由来已久的bug,但很可能永远不会被修复ㄢ网络上过多的代码依赖于bug,因此修复它会导致更多的bug!

同时,注意`一个未定义的`ㄢ我们明确设置`一`到`未定义`值,但那是行为变量,但没有价值没有不同,喜欢用`VaR;`在代码片段顶部的行ㄢ变量可以以几种不同的方式到达这个"未定义ℽ值状态,包括返回值的函数和`无效`算子ㄢ

### 物体

这个`对象`类型指的是一个复合值,您可以在其中设置属性(命名位置),每个属性都保存自己的任何类型的值ㄢ这可能是所有JavaScript中最有用的值类型之一ㄢ

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

想到这个也许会有帮助ㄢ`obj`价值的视觉: 

<img src="fig4.png">

属性可以访问_点符号_(即,`一个目标ㄢ`)或_括号记法_(即,`OBJ [ℽ]`)ㄢ点记法较短,通常更容易阅读,因此在可能的情况下是首选的ㄢ

括号符号是有用的,如果你有一个属性名称,其中有特殊字符,如`OBJ ["Hello World!ℽ]`-这些属性通常被称为_钥匙_当通过括号符号访问时ㄢ这个`[ ]`符号需要一个变量(解释下一个)或`一串` _字面意义的_(需要裹在里面)`"..ℽ`或`"..ℽ`)ㄢ

当然,如果您希望访问属性/键,但名称存储在另一个变量中,括号表示法也很有用,例如: 

```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```

**注: **有关JavaScript的更多信息`对象`s,参见_对象原型_本系列的标题,特别是第3章ㄢ

JavaScript程序中通常会有两种其他的值类型相互作用: _阵列_和_功能_ㄢ但是,与其说是适当的内置类型,不如说它们更像是子类型ℴℴ特定版本的`对象`型ㄢ

#### 阵列

数组是`对象`它保存值(任何类型),特别是在命名的属性/键中,而不是在数值索引位置ㄢ例如:

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```

**注: **开始计算零的语言,像js那样,使用`零`作为数组中第一个元素的索引ㄢ

考虑一下也许会有帮助ㄢ`ARR`视觉上:

<img src="fig5.png">

因为数组是特殊对象(如`类型`意味着,它们也可以拥有属性,包括自动更新ㄢ`长度`财产ㄢ

理论上,您可以使用自己命名的属性使用数组作为普通对象,也可以使用`对象`但只给它数字属性(`零`,`一`类似于数组ㄢ然而,这通常被认为是不恰当的使用Oㄢ

最好和最自然的方法是使用数组进行数值定位的值和使用ㄢ`对象`命名属性的ㄢ

#### 功能

其他的`对象`在js程序中使用的子类型是一个函数: 

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

同样,函数是`物体`ℴℴ`类型`返回`"功能ℽ`,这意味着`功能`是一种主要类型ℴℴ因此可以拥有属性,但通常只使用函数对象属性(如`foo.bar`在有限的情况下ㄢ

**注: **有关JS值及其类型的更多信息,请参见_类型与语法_本系列的标题ㄢ

### 内建类型方法

我们刚才讨论的内置类型和子类型的行为暴露为属性和方法,这些功能和方法非常强大和有用ㄢ

例如:

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

能打电话的"背后ℽ`A. touppercase()`比在价值上存在的方法更复杂ㄢ

简单地说,有一个`字符串`(资本`S`对象包装器表单,通常称为"原生ℽ,与原语配对ㄢ`一串`类型;这个对象包装器定义`touppercase()`原型法ㄢ

当使用原始值时`"你好,世界ℽ`作为一个`对象`通过引用属性或方法(例如,`A. touppercase()`在前一段代码中,js自动将"值ℽ框对象包装器对应(隐藏在封面下)ㄢ

一`一串`值可以由a包装`字符串`一个对象,`数`可以被一个`数`对象,以及`布尔`可以被一个`布尔`对象ㄢ在大多数情况下,您不必担心或直接使用这些对象包装器的值形式ℴℴ实际上在所有情况下都更喜欢原始值表单,JavaScript会为您处理剩下的部分ㄢ

**注: **有关JS本地人和"拳击ℽ的更多信息,请参阅第3章_类型与语法_本系列的标题ㄢ为了更好地理解一个对象的原型,请参阅第5章_对象原型_本系列的标题ㄢ

### 比较值

在js程序中需要进行两种主要的比较: _平等_和_不平等_ㄢ任何比较的结果都是严格的ㄢ`布尔`价值(`真正的`或`假`),不管什么类型的值比较ㄢ

#### 强制

我们在第1章中简单地谈到了胁迫,但是让我们在这里重新讨论一下ㄢ

强制在JavaScript中有两种形式: _明确的_和_隐性的_ㄢ显式强制只是简单地从代码中看到从一种类型到另一种类型的转换会发生,而隐式强制是当类型转换发生在其他操作的非明显的副作用时ㄢ

你可能听过这样的说法: "强迫是邪恶的ℽ,因为有明显的地方强迫可以产生一些令人吃惊的结果ㄢ也许没有什么比语言让他们感到惊讶更让开发者感到沮丧了ㄢ

胁迫不是罪恶,也不必令人惊讶ㄢ事实上,可以用类型强制构建的大多数情况是相当明智和可理解的,甚至可以用于_改善_代码的可读性ㄢ但我们不会再深入讨论那场辩论ℴℴ第4章_类型与语法_本系列的标题涵盖所有方面ㄢ

下面是一个例子_明确的_强制: 

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

下面是一个例子_隐性的_强制: 

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#### 真相与falsy

在1章中,我们简要地提到了"真相ℽ和"falsyℽ属性值: 当一个非ℴ`布尔`值被强制为`布尔`它变成了吗?`真正的`或`假`,分别?

具体名单"falsyℽ价值观在JavaScript如下: 

-   `"ℽ`(空字符串)
-   `零`,`- 0`,`南`(无效`数`)
-   `无效的`,`未定义`
-   `假`

任何的价值,不在这个"falsyℽ列表中的"真相ℽㄢ这里是一些例子的: 

-   `"你好ℽ`
-   `四十二`
-   `真正的`
-   `[ ]`,`[ 1,"2ℽ,3)`(阵)
-   `{ }`,`{ A: 42 }`(对象)
-   `功能foo() { ..}`(功能)

记住一个不重要的是很重要的ℴ`布尔`价值只有遵循这一"真相ℽ/"falsy"强制如果真是强迫一个`布尔`ㄢ给自己一个局面,似乎强迫值到迷惑是不是所有的困难`布尔`如果不是ㄢ

#### 平等

有四个相等运算符: `= =`,`= = =`,`!=`,和`!= =`ㄢ这个`!`表单当然是它们对应的对称的"不相等ℽ的版本;_不平等_不应混淆_不平等_ㄢ

之间的差异`= =`和`= = =`通常的特点是`= =`检查价值平等和`= = =`检查值和类型相等ㄢ然而,这是不准确的ㄢ描述它们的正确方法是`= =`允许使用强制检查值相等,并且`= = =`不允许强制检查价值平等;`= = =`之所以被称为"严格平等ℽ,是因为这个原因ㄢ

考虑一下允许的隐式强制ㄢ`= =`松散的平等比较和不允许的`= = =`严格的平等: 

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

在`a == b`比较,js注意到类型不匹配,所以它通过一系列有序的步骤ㄢ

如果你考虑一下,有两种可能的方法`a == b`可以给`真正的`通过强制ㄢ或者,比较结果可能是`42 = 42`或者它可能是`"42ℽ="42ℽ`ㄢ那是哪一个?

答案: `"42ℽ`成为`四十二`进行比较`42 = 42`ㄢ在这样一个简单的例子中,流程的执行方式并不重要,因为最终的结果是一样的ㄢ更复杂的情况下,问题不仅仅是比较的最终结果,而是_怎样_你到那里去ㄢ

这个`a = b`生产`假`因为强制是不允许的,所以简单值比较显然失败ㄢ许多开发人员觉得`= = =`更容易预测,所以他们主张总是使用这种形式,远离ㄢ`= =`ㄢ我认为这种观点很短视ㄢ我相信`= =`是一个功能强大的工具,可以帮助你的程序,_如果你花时间去学习它是如何工作的ㄢ_

我们不去盖如何强制在所有的细节`= =`比较工作在这里ㄢ其中大部分是相当明智的,但也有一些重要的角落的情况下要小心ㄢ你可以阅读的11.9.3(ES5规格部分<http://www.ecma-international.org/ecma-262/5.1/>)看到确切的规则,你会惊讶于这个机制是多么简单,而不是围绕它的所有负面宣传ㄢ

煮了很多细节,简单的几点,帮助你了解是否使用`= =`或`= = =`在各种情况下,以下是我的简单规则: 

-   如果比较中的任一值(又名侧)可能是`真正的`或`假`值,避免`= =`和使用`= = =`ㄢ
-   如果比较中的任一值可以是这些特定值(`零`,`"ℽ`,或`[ ]`-空数组),避免`= =`和使用`= = =`ㄢ
-   在_全部的_其他情况下,你可以安全使用`= =`ㄢ它不仅安全,而且在许多情况下简化了代码,提高了可读性ㄢ

这些规则归结为要求您对代码进行批判性的思考,并通过比较不同的变量来判断哪些值可以通过ㄢ如果你能确定这些值,并且`= =`是安全的,使用它!如果不能确定这些值,请使用`= = =`ㄢ就是这么简单ㄢ

这个`!=`非相等形式对`= =`,和`!= =`形成对`= = =`ㄢ我们刚才讨论的所有规则和意见都是对称的,它们是不平等的比较ㄢ

你应该特别注意`= =`和`= = =`比较两个非原始值时,比较规则如下`对象`S(包括`功能`和`阵列`)ㄢ因为这些值实际上是通过引用保存的,都是`= =`和`= = =`比较将简单地检查引用是否匹配,而不是关于底层值的任何内容ㄢ

例如,`阵列`默认情况下,S被强制`一串`只需用逗号连接所有的值ㄢ`,`)两者之间ㄢ你可能会认为那是两个`阵列`S的内容相同`= =`平等,但他们不是: 

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

**注: **有关更多信息`= =`平等比较规则,看到ES5规范(第11.9.3)并参照4章_类型与语法_本系列的标题;参见第2章,了解关于值与引用的更多信息ㄢ

#### 不平等

这个`<`,`>`,`< =`,和`> =`运营商用于不等式,指在规范为"关系比较ℽㄢ他们通常会用像依次比较值`数`这很容易理解ㄢ`3<4`ㄢ

但JavaScript`一串`使用典型的字母规则也可以比较不相等的值ㄢ`"barℽ< <"ℽ`)ㄢ

那胁迫呢?类似的规则`= =`比较(虽然不完全相同)!应用于不等式运算符ㄢ值得注意的是,有没有"严格不等式ℽ的运营商,不允许强迫一样`= = =`"严格平等ℽㄢ

考虑: 

```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

这里发生了什么?在11.8.5 ES5规格部分,它说,如果在这两个值`<`比较`一串`S,因为它是`B<C`,比较了字典(又名字母像一本字典)ㄢ但如果一个或两个不是`一串`因为它是`< B`然后,两个值都被强制为`数`以及一个典型的数值比较ㄢ

最大的问题你可能会遇到在比较不同类型的潜在价值ℴℴ记住,没有"严格不等式ℽ形式使用,当一个人的价值观不能制成有效的数字,如: 

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

等等,这三个比较怎么可能是`假`?因为`B`值被强制为"无效数字值ℽㄢ`南`在`<`和`>`比较,规格说明说`南`既不大于也不小于任何其他值ㄢ

这个`= =`比较因不同原因而失败ㄢ`a == b`可能失败,如果它被解释为`42 =南`或`"42ℽ="富ℽ`正如我们前面所解释的,前者就是这种情况ㄢ

**注: **关于不等式的比较规则的更多信息,参见的ES5规范第11.8.5也参照4章_类型_本系列的标题ㄢ

## 变量

在JavaScript中,变量名(包括函数名)必须是有效的ㄢ_标识符_ㄢ当考虑非传统字符(如Unicode)时,标识符中有效字符的严格和完整规则有点复杂ㄢ如果只考虑典型的ASCII字母数字字符,规则很简单ㄢ

标识符必须以`一`ℴ`Z`,`一`ℴ`Z`,`美元`,或`_`ㄢ然后它可以包含这些字符中的任何一个,加上数字ㄢ`零`ℴ`九`ㄢ

一般来说,相同的规则也适用于属性名和变量标识符ㄢ但是,某些单词不能用作变量,但可以作为属性名使用ㄢ这些单词被称为"保留词ℽ,并包含JS关键字(`对于`,`在里面`,`如果`以及)`无效的`,`真正的`,和`假`ㄢ

**注: **有关保留字的更多信息,请参阅附录A_类型与语法_本系列的标题ㄢ

### 功能范围

你用`VaR`关键字声明一个变量,该变量将属于当前函数作用域,或全局函数,如果在任何函数之外的最高级别上ㄢ

#### 吊装

哪里有`VaR`出现在一个范围内,该声明被视为属于整个范围,并在任何地方都可访问ㄢ

打个比方,这种行为称为"_吊装_,当`VaR`声明在概念上"移动ℽ到其封闭范围的顶部ㄢ从技术上讲,这个过程更准确地解释代码是如何编译的,但是现在我们可以跳过这些细节ㄢ

考虑: 

```js
var a = 2;

foo();					// works because `foo()`
						// declaration is "hoisted"

function foo() {
	a = 3;

	console.log( a );	// 3

	var a;				// declaration is "hoisted"
						// to the top of `foo()`
}

console.log( a );	// 2
```

**警告: **依赖变量是不常见的,也不是好主意ㄢ_吊装_在其作用域之前使用变量`VaR`声明出现;它可能相当混乱ㄢ使用它更为普遍和接受ㄢ_悬挂_函数声明,正如我们使用`foo()`正式声明前出现的电话ㄢ

#### 嵌套作用域

在声明变量时,它可以在该范围内的任何地方以及任何较低/内部范围内使用ㄢ例如:

```js
function foo() {
	var a = 1;

	function bar() {
		var b = 2;

		function baz() {
			var c = 3;

			console.log( a, b, c );	// 1 2 3
		}

		baz();
		console.log( a, b );		// 1 2
	}

	bar();
	console.log( a );				// 1
}

foo();
```

注意: `C`内部不可用`bar()`因为它只在内部声明`baz()`范围,以及`B`不可用`foo()`出于同样的理由ㄢ

如果您试图在不可用的范围内访问变量的值,您将得到一个`引用错误`扔ㄢ如果您试图设置一个尚未声明的变量,那么您最终将在顶级全局范围内创建一个变量(糟糕!)或根据"严格模式ℽ(见"严格模式ℽ)获取错误ㄢ让我们看一看: 

```js
function foo() {
	a = 1;	// `a` not formally declared
}

foo();
a;			// 1 -- oops, auto global variable :(
```

这是一次很糟糕的练习ㄢ不要这样做!总是正式声明变量ㄢ

除了在功能层面创造声明变量,ES6_让_您声明变量属于各个块(对`{ ..}`,使用`让`关键词ㄢ除了一些微妙的细节,作用域规则的行为大致相同,只是我们看到的功能: 

```js
function foo() {
	var a = 1;

	if (a >= 1) {
		let b = 2;

		while (b < 5) {
			let c = b * 2;
			b++;

			console.log( a + c );
		}
	}
}

foo();
// 5 7 9
```

由于采用`让`而不是`VaR`,`B`只属于`如果`声明而不是全部`foo()`函数作用域ㄢ同样,`C`只属于`虽然`环ㄢ块作用域在更细粒度的时尚你的变量范围管理是非常有用的,它可以使你的代码更容易维护时间ㄢ

**注: **有关范围的更多信息,请参见_范围和关闭_本系列的标题ㄢ看到_6与超越_本系列的标题了解更多信息`让`块作用域ㄢ

## 条件句

除了`如果`我们在1章简要介绍了声明,JavaScript提供了一些其他条件的机制,我们应该看一看ㄢ

有时你会发现自己写了一系列的`如果ⅆ如果`这样的陈述: 

```js
if (a == 2) {
	// do something
}
else if (a == 10) {
	// do another thing
}
else if (a == 42) {
	// do yet another thing
}
else {
	// fallback to here
}
```

这个结构有效,但它有点冗长,因为您需要指定`一`每个案例的测试ㄢ这是另一种选择,`转换`声明: 

```js
switch (a) {
	case 2:
		// do something
		break;
	case 10:
		// do another thing
		break;
	case 42:
		// do yet another thing
		break;
	default:
		// fallback to here
}
```

这个`打破`如果只希望语句在一个中,那么这一点很重要ㄢ`案例`运行ㄢ如果省略`打破`从一个`案例`,,,`案例`匹配或运行,将继续执行下一步ㄢ`案例`的陈述,不管那`案例`匹配.这种所谓的"失败ℽ有时是有用的/需要的: 

```js
switch (a) {
	case 2:
	case 10:
		// some cool stuff
		break;
	case 42:
		// other stuff
		break;
	default:
		// fallback
}
```

在这里,如果`一`要么是`二`或`十`它将执行"一些很酷的东西ℽ代码语句ㄢ

JavaScript中条件的另一种形式是"条件操作符ℽ,通常称为"三元运算符ℽㄢ`如果..否则`语句,例如: 

```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

If the test expression (`一> 41`在这里)评估为`真正的`第一句(`"你好ℽ`结果,否则第二条(`"世界ℽ`结果,然后将结果分配给`B`ㄢ

条件运算符不必在赋值中使用,但这绝对是最常用的用法ㄢ

**注: **有关测试条件和其他模式的更多信息`转换`和`?: `,看到_类型与语法_本系列的标题ㄢ

## 严格模式

ES5添加了一个"严格模式ℽ的语言,这使某些行为的规则ㄢ一般来说,这些限制被视为将代码保持在更安全ㄡ更合适的指导方针中ㄢ

你可以选择在严格的方式对个体的功能,或整个文件,这取决于你把严格模式编译: 

```js
function foo() {
	"use strict";

	// this code is strict mode

	function bar() {
		// this code is strict mode
	}
}

// this code is not strict mode
```

相比之下: 

```js
"use strict";

function foo() {
	// this code is strict mode

	function bar() {
		// this code is strict mode
	}
}

// this code is strict mode
```

一个关键的区别(改进!)以严格的方式是不允许隐式自动全局变量声明省略`VaR`: 

```js
function foo() {
	"use strict";	// turn on strict mode
	a = 1;			// `var` missing, ReferenceError
}

foo();
```

如果你在你的代码中打开了严格的模式,并且你犯了错误,或者代码开始运行,你的诱惑可能是避免严格的模式ㄢ但是这种本能放纵是个坏主意ㄢ如果严格的模式导致程序中的问题,几乎可以肯定这是一个标志,表明程序中有一些东西需要修复ㄢ

不仅将严格的方式让你的代码到一个更安全的路径,不仅会使你的代码更优化,但它也体现了语言的未来发展方向ㄢ你现在更习惯于严格的模式,而不是不断地拖延它,以后只会变得更难转换!

**注: **有关严格模式的更多信息,请参见第5章_类型与语法_本系列的标题ㄢ

## 功能价值

到目前为止,我们已经讨论了作为主要机制的函数ㄢ_范围_在JavaScriptㄢ你记得典型`功能`声明语法如下: 

```js
function foo() {
	// ..
}
```

尽管这个语法似乎不太明显,`Foo`基本上只是一个变量,在外包围范围内,它被引用到`功能`被宣布ㄢ也就是说`功能`本身就是一种价值,就像`四十二`或`[1,2,3]`将ㄢ

这听起来可能是一个奇怪的概念,所以先花点时间考虑一下ㄢ不仅可以传递值(参数)_到_函数,但_函数本身可以是一个值ㄢ_它被赋值给变量,或者从其他函数传递到或返回ㄢ

因此,函数值应该被看作是一种表达式,类似于任何其他值或表达式ㄢ

考虑: 

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

分配给该函数的第一个函数表达式ㄢ`Foo`变量被称为_匿名_因为它没有`名称`ㄢ

第二个函数表达式是_命名_(`酒吧`)即使是对它的引用也被分配给`X`变量ㄢ_命名函数表达式_一般来说更可取,不过_匿名函数表达式_仍然非常普遍ㄢ

有关更多信息,请参见_范围和关闭_本系列的标题ㄢ

### 立即调用函数的表达式(iifes)

在前一段代码中,既不执行函数表达式,也不可能包含`foo()`或`x()`例如ㄢ

执行函数表达式还有另一种方法,通常称为_立即调用函数表达式_(生活): 

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```

外`(..)`围绕`(功能iife() { ..})`函数表达式只是js语法的一个细微差别,它需要防止它被当作正常函数声明ㄢ

最后的`()`表达式的结尾ℴℴ`});`行ℴℴ实际执行它前面引用的函数表达式ㄢ

这似乎有些奇怪,但乍看起来并不陌生ㄢ考虑到两者之间的相似之处`Foo`和`生活`在这里:

```js
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

如您所见,列出`(功能iife() { ..})`在其执行`()`基本上是相同的,包括`Foo`在其执行`()`在这两种情况下,函数引用都是用`()`紧接着ㄢ

因为生活是一个函数,并且函数创建变量_范围_,使用生活这种方式通常用于声明变量,不会影响周围的代码之外的生活: 

```js
var a = 42;

(function IIFE(){
	var a = 10;
	console.log( a );	// 10
})();

console.log( a );		// 42
```

iifes也可以有返回值: 

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

这个`四十二`价值获取`返回`由`生活`命名函数正在执行,然后分配给`X`ㄢ

### 关闭

_关闭_是JavaScript中最重要也是最不理解的概念之一ㄢ我不会在这里详细介绍,而是请你参考_范围和关闭_本系列的标题ㄢ但我想说几点,这样你就明白了一般概念ㄢ这将是一个在你的JS技能的最重要的技术ㄢ

您可以将闭包视为"记住ℽ并继续访问函数的作用域(其变量)的方法,即使该函数已经完成运行ㄢ

考虑: 

```js
function makeAdder(x) {
	// parameter `x` is an inner variable

	// inner function `add()` uses `x`, so
	// it has a "closure" over it
	function add(y) {
		return y + x;
	};

	return add;
}
```

内在参照`添加(..)`在每次调用外部时返回的函数ㄢ`makeadder(..)`能记住什么`X`值被传递到`makeadder(..)`ㄢ现在,让我们使用`makeadder(..)`: 

```js
// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );		// 4  <-- 1 + 3
plusOne( 41 );		// 42 <-- 1 + 41

plusTen( 13 );		// 23 <-- 10 + 13
```

更多关于这个代码如何工作: 

1.  我们打电话的时候`makeAdder(1)`我们得到了它内部的一个参考ㄢ`添加(..)`记得`X`作为`一`ㄢ我们称之为函数引用ㄢ`还有(..)`ㄢ
2.  我们打电话的时候`(10)makeadder`我们得到了另一个关于它内部的参考ㄢ`添加(..)`记得`X`作为`十`ㄢ我们称之为函数引用ㄢ`plusten(..)`ㄢ
3.  我们打电话的时候`还有(3)`,它增加了`三`(其内`Y`)的`一`(记住`X`我们得到`四`作为结果ㄢ
4.  我们打电话的时候`(13)plusten`,它增加了`十三`(其内`Y`)的`十`(记住`X`), and we get`二十三`作为结果ㄢ

不要担心,如果这看起来很奇怪和混乱的第一-它可以!要理解它需要大量的练习ㄢ

但是相信我,一旦你这么做了,这是所有编程中最强大和最有用的技术之一ㄢ值得一试,让你的大脑冷静一下ㄢ在下一节中,我们将得到更多的闭包练习ㄢ

#### 模块

在JavaScript中闭包最常用的方式是模块模式ㄢ模块让您定义隐藏在外部世界中的私有实现细节(变量ㄡ函数),以及公共APIㄢ_是_从外面看ㄢ

考虑: 

```js
function User(){
	var username, password;

	function doLogin(user,pw) {
		username = user;
		password = pw;

		// do the rest of the login work
	}

	var publicAPI = {
		login: doLogin
	};

	return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( "fred", "12Battery34!" );
```

这个`user()`函数充当容纳变量的外部范围ㄢ`用户名`和`密码`以及内在的`dologin()`函数;这些都是私有的内部细节ㄢ`用户`无法从外部世界访问的模块ㄢ

**警告: **我们没有打电话`新的user()`在这里,有意的,尽管这似乎对大多数读者来说都是常见的ㄢ`user()`只是一个函数,而不是一个要实例化的类,所以它通常被称为函数ㄢ使用`新的`是不恰当的,实际上是浪费资源ㄢ

执行`user()`创建一个_实例_的`用户`模块ℴℴ创建一个全新的范围,从而为每个内部变量/函数提供一个全新的副本ㄢ我们将这个实例分配给`弗莱德`ㄢ如果我们运行`user()`同样,我们将得到一个完全独立于此的新实例ㄢ`弗莱德`ㄢ

内`dologin()`函数有一个结束`用户名`和`密码`也就是说,即使在`user()`功能结束运行ㄢ

`publicapi`是一个具有一个属性/方法的对象,`登录`这是对内部的一个参考ㄢ`dologin()`功能ㄢ当我们回来的时候`publicapi`从`user()`它变成了我们调用的实例`弗莱德`ㄢ

在这一点上,外面`user()`函数已完成执行ㄢ通常,你会认为内部变量是这样的ㄢ`用户名`和`密码`已经走了ㄢ但在这里他们没有,因为有一个封闭的`login()`使他们活着的功能ㄢ

这就是为什么我们可以打电话`弗莱德登录(..)`-和调用内部一样`doLogin(..)`-它仍然可以访问`用户名`和`密码`内部变量ㄢ

有一个很好的机会,只需简单地一瞥闭包和模块模式,其中一些仍然有点混乱ㄢ没关系!它需要一些工作来包装你的大脑围绕它ㄢ

从这里开始读_范围和关闭_本系列的标题是为了更深入的探索ㄢ

## `这`标识符

JavaScript中另一个非常常见的误解是`这`标识符ㄢ再说一遍,里面有几个章节ㄢ_对象原型_这个系列的标题,下面我们简单介绍一下这个概念ㄢ

虽然它似乎常常`这`与JS中的"面向对象的模式ℽ相关ㄢ`这`是不同的机制ㄢ

如果函数有一个`这`参考里面,`这`引用通常指向`对象`ㄢ但这`对象`它取决于调用函数的方式ㄢ

认识到这点很重要ㄢ`这` _不_请参考函数本身,这是最常见的误解ㄢ

这里有一个快速的例子: 

```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

// --------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );		// "obj2"
new foo();			// undefined
```

有四条规则`这`获取并设置在该代码段的最后四行中ㄢ

1.  `foo()`最终设置`这`对非严格模式的全局对象ℴℴ严格模式,`这`将`未定义`而且您在访问`酒吧`财产,所以`"全球ℽ`是找到的值吗?`this.bar`ㄢ
2.  `foo() obj1ㄢ`集`这`到`obj1`对象ㄢ
3.  `foo调用(obj2)ㄢ`集`这`到`obj2`对象ㄢ
4.  `新的foo()`集`这`一个全新的空物体ㄢ

底线: 了解什么`这`指向,你必须检查这个函数是如何被调用的ㄢ这将是这四种方式中的一种,它将回答什么ㄢ`这`是.

**注: **有关更多信息`这`见第1章和第2章_对象原型_本系列的标题ㄢ

## 原型

JavaScript中的原型机制相当复杂ㄢ我们只会在这里浏览一下ㄢ你要花很多时间复习第4-6章的内容ㄢ_对象原型_本系列的所有细节的标题ㄢ

当引用对象上的属性时,如果该属性不存在,JavaScript将自动使用该对象的内部原型引用来查找另一个对象来查找ㄢ你可以认为这几乎是一个后备如果缺少财产ㄢ

从一个对象到它的回退的内部原型引用链接发生在对象创建时ㄢ最简单的说明方法是调用内置的实用工具ㄢ`对象创建(..)`ㄢ

考虑: 

```js
var foo = {
	a: 42
};

// create `bar` and link it to `foo`
var bar = Object.create( foo );

bar.b = "hello world";

bar.b;		// "hello world"
bar.a;		// 42 <-- delegated to `foo`
```

这可能有助于形象化`Foo`和`酒吧`对象及其关系: 

<img src="fig6.png">

这个`一`属性实际上不存在于`酒吧`对象,但因为`酒吧`原型链接到`Foo`JavaScript自动回落到寻找`一`上`Foo`对象,在它被找到的地方ㄢ

这种联系似乎是语言的一个奇怪的特征ㄢ最常用的方法是使用这个特性

但是应用原型的一种更自然的方式是一种称为"行为委托ℽ的模式,在这个模式中,您有意地设计您的链接对象,以便能够_代表_从一个到另一个需要的行为的一部分ㄢ

**注: **有关原型和行为委托的更多信息,请参见_对象原型_本系列的标题ㄢ

## 新与旧

我们已经涉及到的一些JS特性,当然还有本系列其余部分所涵盖的许多特性,都是新增加的,在旧浏览器中不一定可用ㄢ事实上,规范中的一些最新特性甚至没有在任何稳定的浏览器中实现ㄢ

那么,你用这些新材料做什么呢?你是否需要等上几年或几十年,让所有旧的浏览器淡出默默无闻?

这就是很多人对这种情况的看法,但对JS来说这并不是一个健康的方法ㄢ

目前主要有两种技术可以"带来ℽ新的JavaScript的东西老的浏览器: polyfilling和transpilingㄢ

### polyfilling

"polyfillℽ是一个发明的术语(Remy Sharp)(<https://remysharp.com/2010/10/08/what-is-a-polyfill>)用于指取新特性的定义并生成与行为相当的代码,但可以在较旧的JS环境中运行ㄢ

例如,定义了一个工具叫ES6`数ㄢisnan(..)`提供准确无车支票`南`价值贬的原`isnan(..)`效用ㄢ但是很容易polyfill效用以便你可以使用它在您的代码中,无论用户是在一个6浏览器或不ㄢ

考虑: 

```js
if (!Number.isNaN) {
	Number.isNaN = function isNaN(x) {
		return x !== x;
	};
}
```

这个`如果`声明防应用定义浏览器polyfill ES6那里将已经存在ㄢ如果它还没有出现,我们定义`数ㄢisnan(..)`ㄢ

**注: **我们在这里做的检查是利用了一个怪癖ㄢ`南`值,也就是说,它们是整个语言中唯一不等于自身的值ㄢ所以`南`价值观是唯一能创造价值的东西ㄢ`X!= = x`是`真正的`ㄢ

不是所有的新功能是完全polyfillableㄢ有时,大多数的行为可以polyfilled,但仍有小的偏差ㄢ你真的应该在实现自己一个polyfill非常小心,以确保你坚持尽可能严格的规范ㄢ

或者更好的是,使用一个已经审核组polyfills可以信任的,如那些由ES5垫片提供(<https://github.com/es-shims/es5-shim>)和垫片(ES6<https://github.com/es-shims/es6-shim>)ㄢ

### transpiling

有没有办法polyfill新语法已被添加到语言ㄢ新语法将在旧JS引擎中抛出一个不可识别/无效的错误ㄢ

更好的选择是使用一种工具,将新代码转换成旧代码等价物ㄢ这个过程通常被称为"transpiling,"转化+编译期ㄢ

从本质上讲,你的源代码是写在新的语法形式,而是你部署到浏览器是transpiled码在旧的语法形式ㄢ通常你将transpiler到您的构建过程,类似于你的代码短绒或缩小镜ㄢ

你可能想知道为什么你会去麻烦写新的语法不仅有transpiled去旧的代码--为什么不写旧的代码直接?

你应该关心transpiling的几个重要原因: 

-   添加到该语言的新语法是为了使代码更易读和可维护而设计的ㄢ较老的对等词通常更为复杂ㄢ您应该更喜欢编写更新的ㄡ更干净的语法,不仅是为您自己,也是为开发团队的所有其他成员编写的ㄢ
-   如果你transpile只有旧的浏览器,但服务新语法的最新的浏览器,你可以利用与新语法浏览器性能优化ㄢ这也让浏览器制造商拥有更真实的代码来测试它们的实现和优化ㄢ
-   使用新的语法之前允许它被测试在现实世界中的更强劲,可提供早期反馈给JavaScript(TC39委员会)ㄢ如果问题被及早发现,在这些语言设计错误变成永久性之前,它们可以被改变/固定ㄢ

这是一个简单的例子transpilingㄢ6添加一种称为"默认参数值ℽㄢ它看起来像这样: 

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

很简单,对吧?也很有帮助!但新的语法,pre-es6引擎的无效ㄢ所以会有什么transpiler做代码能运行在旧的环境?

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

如您所见,它检查是否`论点[ 0 ]`值`无效0`(又名`未定义`)如果有,则提供`二`默认值;否则,它分配传递的内容ㄢ

除了能够现在即使在旧的浏览器使用良好的语法,看着transpiled代码实际上解释了预期的行为更清晰ㄢ

你可能没有看着6版本实现`未定义`是唯一不能在默认值参数中显式传递的值ㄢ

的强调transpilers最后一个重要的细节是,他们现在应该被认为是JS开发生态系统和过程的一个标准部分ㄢjs将继续发展,比以前更快,所以每隔几个月就会添加新的语法和新特性ㄢ

如果你使用一个transpiler默认情况下,你将永远是能够切换到新的语法,只要你觉得有用,而不是总是等待年今天的浏览器淘汰ㄢ

有很多伟大的transpilers供您选择ㄢ以下是写作时的一些不错的选择: 

-   Babel(<https://babeljs.io>)(原名6to5): transpiles ES6 +为ES5
-   Traceur(<https://github.com/google/traceur-compiler>): transpiles ES6,ES7,到超越ES5

## 非JavaScript

到目前为止,我们只讨论了js语言本身ㄢ事实上,大多数JS都是为了运行和与浏览器这样的环境进行交互而编写的ㄢ严格来说,你在代码中编写的大量内容不是直接由JavaScript控制的ㄢ听起来可能有点奇怪ㄢ

您遇到的最常见的非JavaScript JavaScript是DOM APIㄢ例如:

```js
var el = document.getElementById( "foo" );
```

这个`文件`当您的代码在浏览器中运行时,变量作为全局变量存在ㄢ它不是js引擎提供的,也不是JavaScript规范特别控制的ㄢ它的形式看起来非常像普通的JSㄢ`对象`但事实并非如此ㄢ这是特别的`对象,`通常称为"宿主对象ℽㄢ

此外,该`getElementById(..)`方法`文件`看起来像一个普通的js函数,但它只是一个稀疏的接口,它是DOM从浏览器提供的内置方法ㄢ在一些(新一代)的浏览器,这一层也可以在JS,但是传统的DOM及其行为是更像C / C++实现ㄢ

另一个例子是输入/输出(I/O)ㄢ

大家都喜欢的`警报(ⅆ)`在用户的浏览器窗口中弹出一个消息框ㄢ`警报(ⅆ)`由浏览器提供给js程序,而不是js引擎本身ㄢ您所做的调用将消息发送到浏览器内部,并处理消息框的绘制和显示ㄢ

同样的道理`控制台(ⅆ)`浏览器提供这些机制,并将它们挂在开发人员的工具上ㄢ

这本书,以及整个系列,都集中在JavaScript语言上ㄢ这就是为什么您没有看到这些非JavaScript JavaScript机制的实质性报道ㄢ然而,你需要意识到它们,因为它们在你写的每一个js程序中都会出现!

## 回顾

学习JavaScript编程风格的第一步是对其核心机制(如值ㄡ类型ㄡ函数闭包)有一个基本的了解,`这`和原型ㄢ

当然,这些主题中的每一个都应该比你在这里看到的更为广泛,但这就是为什么他们在本系列的其余部分中有专门的章节和书籍ㄢ在你对本章中的概念和代码样本感到相当满意之后,本系列的其余部分就等着你真正深入了解这门语言ㄢ

这本书的最后一章将简要地总结本系列中的每一个标题以及它们所涵盖的其他概念,以及我们已经探索过的内容ㄢ
