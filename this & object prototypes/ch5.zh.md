
# 你不认识JS：_这_与对象的原型

# 第5章：原型

在第3章和第4章中，我们提到了`[原型]`链了好几次，但都没说到底是什么。我们现在将详细检查原型。

**注：**所有的模仿复制类行为的尝试，正如4章先前描述的，称为“混合”的变化，完全规避`[原型]`我们在本章中讨论的链式机制。

## `[原型]`

JavaScript中的对象有一个内部属性，在规范中表示为`[原型]`，这只是对另一个对象的引用。几乎所有对象都给出非—`无效的`此属性在创建时的值。

**注：**我们很快就会看到的。_是_可能对象有空`[原型]`链接，虽然这有点不常见。

考虑：

```js
var myObject = {
	a: 2
};

myObject.a; // 2
```

什么是`[原型]`引用用于？在第3章中，我们研究了`[得到]`引用对象上的属性时调用的操作，例如`一个MyObject。`。为默认`[得到]`操作，第一步是检查对象本身是否具有属性。`一`在上面，如果是的话，它被使用了。

**注：**ES6代理这本书的讨论范围之外（将覆盖在系列！后来的书）但我们在这里讨论的一切都是正常的`[得到]`和`[[Put]]`行为不适用于`代理`参与。

但如果发生`一`不是**目前对**MyObject`这就引起我们的注意。`\[原型]`对象链接。`默认的

\[得到]`操作继续进行`\[原型]`链接`如果对象不能直接在对象上找到所请求的属性，则。**注：**我们将解释什么

```js
var anotherObject = {
	a: 2
};

// create an object linked to `anotherObject`
var myObject = Object.create( anotherObject );

myObject.a; // 2
```

**对象创建（..）**短期内是如何运作的？。现在，假设它用`[原型]`链接，我们正在检查指定的对象。`所以，我们有`MyObject

这就是现在`[原型]`联系`另`。明确`一个MyObject。`实际上并不存在，但是，属性访问成功（在`另`相反，确实发现了价值。`二`。`但是，如果`一

没有发现`另`要么，它`[原型]`链条，如果不是空的，请再次咨询和遵循。`此过程将继续进行，直到找到匹配的属性名，或`\[原型]

链的末端。如果没有匹配属性`曾经`在链的末端发现，返回结果来自_\[得到]_操作`未定义`。`类似这样的`\[原型]

链查找过程，如果你用`对..`循环迭代一个对象，通过它的链可以到达的任何属性（也是`枚举`——参见第3章）将被列举。如果您使用`在里面`运算符测试对象上某个属性是否存在，`在里面`将检查对象的整个链（不管`枚举`）。_因此，该_\[原型]

```js
var anotherObject = {
	a: 2
};

// create an object linked to `anotherObject`
var myObject = Object.create( anotherObject );

for (var k in myObject) {
	console.log("found: " + k);
}
// found: a

("a" in myObject); // true
```

当你在各种时尚中进行财产检查时，连锁店一次一个环节。一旦找到属性或链结束，查找就会停止。`object.prototype`但

### `哪里`

到底是什么_\[原型]_链“结束”？`每一个顶点`正常的

\[原型]_链是内置的_object.prototype`。这个对象包含了JS上使用的各种常见实用程序，因为JavaScript中的所有“正常”（内置的，不是主机特定的扩展）对象都是从“下降”中派生出来的。`\[原型]`链）的`object.prototype`对象。`您可能熟悉的一些实用程序包括`tostring()。`和

valueof()。`。在第3章中，我们介绍了另一个：`hasownproperty（..）。`。还有另一个功能`object.prototype`您可能不熟悉，但我们将在本章后面提到的是`isprototypeof（..）。`。`设置和跟踪属性`回到第3章，我们提到在对象上设置属性要比向对象添加一个新属性或者改变一个现有属性的值更微妙。我们现在将更全面地重新审视这种情况。`如果

### MyObject

对象已经有一个正常的数据访问特性称为

```js
myObject.foo = "bar";
```

Foo`直接出现在它上，任务就像改变现有财产的价值一样简单。`如果`Foo`没有直接出现在

MyObject`，的`\[原型]`链被遍历，就像`\[得到]`操作。如果`Foo`在链的任何地方都找不到，属性`Foo`直接添加到`MyObject`如预期的那样指定值。`然而，如果`Foo`已经存在于链中更高的位置，可能会出现微妙的（也许是令人惊讶的）行为。

myobject.foo =“酒吧”`分配。我们会在一瞬间检查更多。`如果属性名`Foo`双方都结束了

MyObject`本身和更高层次的`\[原型]`开始于`MyObject`这叫做`阴影`。这个`Foo_财产直接_MyObject`阴影`任何`Foo`在链中看起来更高的属性，因为_myobject.foo_查`Foo`在链中看起来更高的属性，因为`myobject.foo`查找总是会找到`Foo`在链中最低的属性。

正如我们刚才暗示的，阴影`Foo`在`MyObject`并不像看上去那么简单。现在我们将研究三个场景`myobject.foo =“酒吧”`分配时`Foo`是**不**已经在`MyObject`直接，但**是**在较高的水平上`MyObject`的`[原型]`链：

1.  如果一个正常的数据访问（见3章）属性命名`Foo`在任何地方都能找到。`[原型]`链，**而且它没有标记为只读（`写：假`）**然后调用一个新属性`Foo`直接添加到`MyObject`导致**阴影属性**。
2.  如果一个`Foo`在…`[原型]`链，但它被标记为**只读（`写：假`）**然后，既有现有属性的设置，也可以创建阴影属性。`MyObject`是不允许的**。如果代码正在运行**严格模式`将抛出一个错误。否则，属性值的设置将被忽略。无论哪种方式，`无遮蔽的发生**。**如果一个
3.  Foo`在…`\[原型]`链，它是一个二传手（见第3章），然后二传将永远被称为。不`Foo`将被添加到（又名，阴影上）`MyObject`也不会`Foo`二传手被重新定义。`大多数开发商假定转让财产。

\[…]`如果属性已经存在，那么将始终导致阴影。`\[原型]`链，但你可以看到，在一个真正的（# 1）的三种情况描述。`如果你想影子

Foo`在例2和3 # #，不能使用`=`赋值，但必须使用`对象。defineproperty（..）`（见第3章）`Foo`到`MyObject`。`注：

**案例# 5月2日是最令人惊讶的三。A的存在**只读_属性防止在一个较低级别的隐式创建（阴影）的同一名称的属性。_\[原型]`链。这种限制的原因主要是为了增强类继承属性的错觉。如果你想到`Foo`在链的较高层次上，被继承（复制）到`MyObject`那么，强制执行该文件的非可写性是有意义的。`Foo`财产`MyObject`。然而，如果你将幻觉与事实分开，并认识到没有这种继承复制。`事实上_发生了（见第4章和第5章），这有点不自然。_MyObject`将防止有`Foo`属性只是因为其他对象具有不可写性。`Foo`在这。更奇怪的是，这种限制只适用于`=`赋值，但使用时不强制执行`对象。defineproperty（..）`。`阴影

方法**导致了难看的**明确的伪基因多态性_（见第4章）如果您需要在两者之间进行委托。通常，阴影比它的价值更为复杂和微妙，_所以，如果可能的话，你应该尽量避免。**。见第6章的替代设计模式，其中除其他事项阻止阴影有利于更清洁的替代品。**阴影甚至可以以微妙的方式隐式发生，所以如果试图避免它，就必须小心。考虑：

虽然看起来可能

```js
var anotherObject = {
	a: 2
};

var myObject = Object.create( anotherObject );

anotherObject.a; // 2
myObject.a; // 2

anotherObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "a" ); // false

myObject.a++; // oops, implicit shadowing!

anotherObject.a; // 2
myObject.a; // 3

myObject.hasOwnProperty( "a" ); // true
```

MyObject。+ +`应该（通过委托）查找并只增加`另一个。`财产本身`在的地方_相反的，_+ +`操作对应`MyObject。= MyObject。+ 1`。其结果是`\[得到]`抬头`一`属性通过`\[原型]`获取当前值`二`从`另一个。`，增加价值，然后`\[…]`分配`三`值为新的阴影属性。`一`在`MyObject`。哎呀!`处理您修改的委托属性时要非常小心。如果你想增加

另一个。`唯一正确的方法是`另一个C++。`。`“类”

## 此时，您可能会疑惑：“

为什么_一个对象需要链接到另一个对象吗？”真正的好处是什么？这是一个非常恰当的问题，但我们必须首先明白什么是什么。_\[原型]`是`不**之前我们可以充分理解和欣赏它。**是_以及它是如何有用的。_正如我们在第4章中所解释的，在JavaScript中，对于面向类的语言，没有所谓的“类”对象的抽象模式/蓝图。JavaScript

只是**有对象。**事实上，JavaScript是

几乎是独一无二的**在语言中，可能是唯一一种有权使用“面向对象”标签的语言，因为它是一种很短的语言列表，其中的对象可以直接创建，而不需要类。**在JavaScript，阶级不能（因为他们不存在！）描述一个物体能做什么。对象直接定义自己的行为。

有**只是_对象。_“类”函数**

### 有个古怪的行为，一直无耻地滥用JavaScript来

乱劈_的东西，_看_像“类”。我们将详细研究这种方法。_独特的“类”的行为取决于一个奇怪的特征排序功能

独特的“类的类”的行为取决于函数的一个奇怪的特点：所有功能默认情况下被公开，不可枚举（见3章）对他们所谓的财产`原型`，指向另一个任意对象。

```js
function Foo() {
	// ...
}

Foo.prototype; // { }
```

这个对象通常被称为“富的原型”，因为我们通过一个不幸的名字访问它。`foo.prototype`属性参考。然而，这一术语毫无意义地注定要使我们陷入混乱，我们不久就会看到。相反，我将把它称为“以前称为富的原型”的对象。只是在开玩笑。如何：“对象任意标记的“点原型””？

不管我们叫什么，这个对象到底是什么？

解释它的最直接的方法是从调用中创建的每个对象。`新的foo()`（见第2章）将结束（有些武断）。`[原型]`-链接到这个“点原型”对象。

让我们举例说明：

```js
function Foo() {
	// ...
}

var a = new Foo();

Object.getPrototypeOf( a ) === Foo.prototype; // true
```

什么时候`一`是通过调用创建的`新的foo()`其中一件事（见所有的第2章）。_四_这种情况发生的原因是`一`有一个内部`[原型]`链接到对象`foo.prototype`指着。

停一下，思考一下那句话的含意。

在面向类的语言中，多**副本**类的（例如，“实例”）可以做，比如从模具中冲压出一些东西。正如我们在4章中看到的，这是因为实例化过程（或继承）一类的意思，“复制行为的计划从类到一个物理对象”，这是每一个新的实例再做。

但在JavaScript，没有这样的复制行为。您不创建类的多个实例。您可以创建多个对象`[原型]`链接_对一个共同的对象。但默认情况下，不会发生复制，因此这些对象不会最终完全分离和断开，而是相当_链接**_。_**新的foo()

`结果出现在一个新对象中（我们称之为`一`），和`那个**新的对象**一`内部`\[原型]`联系到`foo.prototype`对象。`我们最终得到两个互相连接的对象。

**那是**它_。我们没有实例化一个类。我们当然没有把任何行为从一个“类”复制到一个具体对象中。我们刚把两个物体连在一起。_事实上，这个秘密，这使得大多数JS开发者，是的

新的foo()`函数调用实际上几乎没有`直接的_处理创建链接的过程。_这是一种偶然的副作用。**新的foo()**是一种迂回的、迂回的方式来达到我们想要的结果：`链接到另一个对象的新对象`。**我们能得到更多我们想要的吗？**直接的

路吗？_对!_英雄**对象创建（..）**。但我们会得到一点。`名字里有什么？`在JavaScript中，我们不做

#### 副本

从一个对象（“类”）到另一个对象（“实例”）。我们做的_链接_对象之间的。对于_\[原型]_在视觉上，箭头从右向左移动，从底部移动到顶部。`这种机制被称为“原型继承”（我们将探讨代码详细不久），通常称为“经典传承的动态语言版本”。这是一种试图在阶级导向的世界中对“继承”意味着什么的共同理解，但`扭

<img src="fig3.png">

（_阅读：铺路_理解的语义，以适应动态脚本。**“继承”一词有很强的含义（见第4章），有很多的精神先例。只要加入“原型”前面的区分**实际上几乎是相反的

在JavaScript的行为在其身后近二十年离开泥泞的混乱。_我想说的是，坚持“原型”前面的“继承”彻底扭转它的实际意思是一手拿着桔子，在另一个苹果，并坚持称苹果“红橙色”。不管我在它前面放了什么令人困惑的标签，都不会改变。_事实

那一个水果是苹果，另一个是桔子。_更好的方法是简单地称苹果为苹果——使用最准确、最直接的术语。这样就更容易理解它们的相似之处和它们的相似之处。_许多的差异

因为我们都有一个简单的、共同的理解“苹果”是什么意思。**由于混淆和术语混为一谈，我相信“原型继承”本身（并试图MIS应用所有相关的类方向的术语，如“类”、“构造”、“实例”、“多态性”，等）做了**弊大于利

在解释JavaScript机制的过程中**真正地**作品._“继承”意味着_复制

操作，和JavaScript不复制对象的属性（本机默认）。相反，js在两个对象之间创建了一个链接，其中一个对象本质上可以是一个对象。_代表_访问另一个对象的属性/函数。“委托”（参见第6章）是JavaScript对象链接机制的一个更准确的术语。_有时在JavaScript中抛出的另一个术语是“差异继承”。这里的想法_访问另一个对象的属性/函数。“委托”（参见第6章）是JavaScript对象链接机制的一个更准确的术语。

有时在JavaScript中抛出的另一个术语是“差异继承”。这里的想法是，我们描述一个对象的行为在什么方面。_不同的_从更一般的描述符。例如，你解释汽车是一种汽车，但它有4个轮子，而不是重新描述组成普通汽车（发动机等）的所有细节。

如果你试着把js中的给定对象看作是所有行为的总和。_可获得的_经授权，并**在你的脑海里你变平了**所有这些行为变成一个有形的_事情_，然后你可以（有点）看到“微分继承”可能适合。

但就像“原型继承”、“微分继承“假装你的心智模型比语言所产生的身体更重要。它忽略了对象的事实。`B`实际上并不是差异化构造，而是与定义的特定特性一起构建，与“空洞”一起定义。正是在这些“漏洞”（差距，或缺乏定义）的代表团。_可以_接管，并立即，“填充他们”与委托行为。

默认情况下，该对象不会被转换为单个差分对象，**通过复制**“微分继承”的心智模式意味着。因此，“差异继承”并不是天生就适合描述JavaScript的`[原型]`机制实际工作。

你_可以选择_更喜欢“差异继承”的术语和心理模型，作为一个口味的问题，但不能否认的事实是_只有_适合你头脑中的技巧，而不是发动机中的物理行为。

### “建设者”

让我们回到早期的代码：

```js
function Foo() {
	// ...
}

var a = new Foo();
```

到底是什么让我们思考`Foo`是一个“类”吗？

首先，我们看到了`新的`关键字，就像类面向语言在构建类实例时所做的那样。另一方面，看来我们实际上是在执行一个_构造函数_类的方法，因为`foo()`实际上是一种调用方法，就像实例化类时如何调用一个真正类的构造函数一样。

为了进一步混淆“构造函数”语义，任意标记`foo.prototype`对象还有另一个技巧。考虑这个代码：

```js
function Foo() {
	// ...
}

Foo.prototype.constructor === Foo; // true

var a = new Foo();
a.constructor === Foo; // true
```

这个`foo.prototype`默认情况下的对象（在代码片段第1行的声明时间）！获取一个公共，不可枚举（见3章）的属性称为`构造函数。`这个属性是函数的引用（`Foo`在这种情况下）对象与。此外，我们看到了这个对象。`一`由“构造函数”调用创建`新的foo()`似乎_也有它的属性叫做_构造函数。`这也类似于“创造它的功能”。`注：

**事实并非如此。**一`没有`构造函数。`财产，虽然`a.constructor`事实上解决了`Foo`函数“构造函数”`实际上并不意味着**“由它构建”，正如它所显示的。我们将很快解释这种陌生感。**哦，是的，也…按照JavaScript世界中的约定，“类”ES用大写字母命名，所以它是

Foo`而不是`Foo`是一个强烈的线索，我们打算它是一个“类”。这对你来说完全是对的，对吗？！？`注：

**该公约是如此强烈，很多JS短绒实际上**抱怨_如果你打电话_新的`在一个带有小写名称的方法上，或者如果我们不调用`新的`关于以大写字母开头的函数。那种犹豫不决，我们做太多的抗争来获得（假）”类取向”`正确的_在JavaScript，我们创造了短绒规则确保我们使用大写字母的大写字母，尽管并不意味着_任何东西**_完全_到js引擎。**构造函数或调用？

#### 在上面的片段中，很容易想到

Foo`是一个“构造函数”，因为我们称它为`新的`我们观察到它“构造”一个对象。`在现实生活中，

Foo`不再是程序中任何其他函数的“构造函数”。函数本身是`不**构造函数。然而，当你把**新的`在正常函数调用前面的关键字，使该函数调用“构造函数调用”。事实上，`新的`这种劫持任何正常功能并调用它的方式，构建了一个对象，`除了它要做的任何事情**。**例如:

没什么特别的

```js
function NothingSpecial() {
	console.log( "Don't mind me!" );
}

var a = new NothingSpecial();
// "Don't mind me!"

a; // {}
```

`只是普通的普通函数，但是当调用时`新的`，它`构建_一个几乎是副作用的对象，我们碰巧分配给它_一`。这个`呼叫**是一个**构造函数调用_，但_没什么特别的`不是，本身就是`构造函数_。_换句话说，在JavaScript中，最恰当的说法是“构造函数”是

调用的函数**新的`关键词`在它前面。**函数不是构造函数，但函数调用是“构造函数调用”，当且仅当

n`新的`使用。

### 机械

是_那些_在JavaScript中，不幸的“类”讨论的唯一常见触发器是什么？

**不完全。**js开发人员努力模拟类的方向：

```js
function Foo(name) {
	this.name = name;
}

Foo.prototype.myName = function() {
	return this.name;
};

var a = new Foo( "a" );
var b = new Foo( "b" );

a.myName(); // "a"
b.myName(); // "b"
```

这个片段展示了另外两个游戏中的“类倾向”技巧：

1.  `this.name =名称`：加`名称`属性放到每个对象上（`一`和`B`分别参见第2章`这`绑定）类似于类实例如何封装数据值。

2.  `foo.prototype.myname =…`也许是更有趣的技术，它将属性（函数）添加到`foo.prototype`对象。现在,`A. myname()`工作，但也许令人惊讶。怎么用？

在上面的片段中，很容易想到`一`和`B`创建，属性/函数在`foo.prototype`对象_复制_到每一个`一`和`B`物体.**然而，这并不是发生了什么。**

在本章的开头，我们解释了`[原型]`链接，以及如果属性引用不是直接在对象上找到的，它是如何提供返回查找步骤的，作为缺省值的一部分`[得到]`算法.

所以，根据它们是如何产生的，`一`和`B`每个内部都有一个内部。`[原型]`联动`foo.prototype`。什么时候`我的名字`没有发现`一`或`B`相反，它是通过（代表团，见第6章）找到的。`foo.prototype`。

#### “建设者”

回忆起前面关于这个问题的讨论`构造函数。`财产，以及它如何_似乎_喜欢`a.constructor = = = foo`真实就是`一`有一个实际的`构造函数。`指向它的属性`Foo`？**不正确的。**

这只是不幸的混淆。事实上，`构造函数。`也可参考_委派_高达`foo.prototype`，这**发生**默认情况下，有一个`构造函数。`那点`Foo`。

它_似乎_非常方便，一个物体`一`“由”构成`Foo`将有机会获得`构造函数。`指向的属性`Foo`。但那不过是一种虚假的安全感。这是一个幸福的事故，几乎是切向的。`a.constructor`发生_来点_Foo`通过默认的`\[原型]`代表团。事实上，有几种方法可以让我们假设`构造函数。`意思是“被造”可以回来咬你。`一方面，

构造函数。`财产`foo.prototype`只有在默认创建的对象时才存在`Foo`函数被声明。如果创建一个新对象，并替换函数的默认值`原型。`对象引用，默认情况下新对象不会神奇地获得`构造函数。`在这。`考虑：

对象（…）

```js
function Foo() { /* .. */ }

Foo.prototype = { /* .. */ }; // create a new prototype object

var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```

`没有“建构”`A1`是吗？看起来确实像`foo()`“建造”它。许多开发商认为`foo()`就像做建筑一样，但当所有东西都分崩离析时，你就认为“构造函数”是“由”建造的，因为那个推理，`a1.constructor`应该是`Foo`但它不是！`在忙什么？

A1`没有`构造函数。`属性，所以它代表`\[原型]`链`foo.prototype`。但是那个对象没有`构造函数。`要么（像默认情况一样）`foo.prototype`对象会有！）所以它一直在授权，这一次`object.prototype`，代表团链的顶端。`那_对象确实有_构造函数。`在它上面指向内置的`对象（…）`功能。`误解，被破坏。

**当然，您可以添加**

构造函数。`回到`foo.prototype`对象，但这需要手动工作，特别是如果你想匹配的本地行为，它是不可数（见3章）。`例如:

那是很多手工工作需要修理的。

```js
function Foo() { /* .. */ }

Foo.prototype = { /* .. */ }; // create a new prototype object

// Need to properly "fix" the missing `.constructor`
// property on the new object serving as `Foo.prototype`.
// See Chapter 3 for `defineProperty(..)`.
Object.defineProperty( Foo.prototype, "constructor" , {
	enumerable: false,
	writable: true,
	configurable: true,
	value: Foo    // point `.constructor` at `Foo`
} );
```

构造函数。`。此外，我们实际上所做的只是延续“构造函数”是“由”构造的误解。这是一个`昂贵的_幻觉。_事实是，

构造函数。`在任意一个对象上，默认情况下，在一个函数中，每个对象都有一个返回对象的引用——它调用的一个引用。`原型。`。单词“构造函数”和“原型”只有一个松散的默认含义，可能以后也可能不成立。最好的办法是提醒自己，“构造函数并不意味着”。`构造函数。

`不是魔法不变的属性。它`是_不可数（见下段），但它的价值是可写的（可以修改），而且你可以添加或覆盖（有意或无意）的名称的属性_构造函数`在任何物体上`\[原型]`链，任何您认为合适的值。`由于如何

\[得到]`遍历`\[原型]`链，一`构造函数。`在任何地方找到的属性引用可能与您期望的完全不同。`看看它的意思到底有多武断？

结果呢？一些任意对象属性引用如下

a1.constructor`无法被`可信的_为默认函数引用。此外，正如我们不久将看到的，仅仅是简单的省略，_a1.constructor`甚至可以最终指向的地方相当惊人和昏迷。`构造函数。

`非常unreliabl`非常不可靠，并且在代码中依赖于不安全引用。**一般情况下，应尽可能避免这种引用。**

## “（Prototypal）继承”

我们已经看到一些“类”力学的近似，它们通常被攻击到JavaScript程序中。但是如果我们没有近似“继承”的话，JavaScript“类”ES就相当空洞了。

事实上，我们已经看到了机构，通常称为“原型继承”在工作的时候`一`能够“继承”`foo.prototype`从而获得`myname()`功能。但是我们传统上认为“继承”是两个“类”之间的关系，而不是“类”和“实例”之间的关系。

<img src="fig3.png">

从前面回顾这个数字，它不仅显示了来自对象的委托（又名“实例”）。`A1`对象`foo.prototype`，但从`bar.prototype`到`foo.prototype`这有点类似于父类继承的概念。_像_当然，除了箭头的方向之外，箭头显示的是委托链接，而不是复制操作。

下面是创建这种链接的典型的“原型风格”代码：

```js
function Foo(name) {
	this.name = name;
}

Foo.prototype.myName = function() {
	return this.name;
};

function Bar(name,label) {
	Foo.call( this, name );
	this.label = label;
}

// here, we make a new `Bar.prototype`
// linked to `Foo.prototype`
Bar.prototype = Object.create( Foo.prototype );

// Beware! Now `Bar.prototype.constructor` is gone,
// and might need to be manually "fixed" if you're
// in the habit of relying on such properties!

Bar.prototype.myLabel = function() {
	return this.label;
};

var a = new Bar( "a", "obj a" );

a.myName(); // "a"
a.myLabel(); // "obj a"
```

**注：**要理解为什么`这`点`一`在上面的代码片段中，见第2章。

The important part is`bar.prototype =（foo.prototype）创建对象。`。`对象创建（..）`创建_一个“新”的物体从稀薄的空气，并链接新对象的内部_\[原型]`对指定的对象（`foo.prototype`在这种情况下）。`换句话说，那句话是：“做一个

新的_“点原型”对象，链接到“点原型”。_什么时候

功能bar() { ..}`声明，`酒吧`和其他函数一样，有一个`原型。`链接到它的默认对象。但`那个_对象没有链接到_foo.prototype`像我们想要的。所以，我们创建一个`新的_对象_是_链接到我们想要的，有效地丢弃原始的不正确链接对象。_注：

**一个常见的MIS概念/困惑是以下任一种方法**也_工作，但它们不能像你期望的那样工作：_bar.prototype = foo.prototype

```js
// doesn't work like you want!
Bar.prototype = Foo.prototype;

// works kinda like you want, but with
// side-effects you probably don't want :(
Bar.prototype = new Foo();
```

`不创建一个新对象`bar.prototype`联系。它只是使`bar.prototype`是另一个参考`foo.prototype`有效链接`酒吧`直接`同一对象**Foo**链接：`foo.prototype`。这意味着当你开始赋值时，比如`bar.prototype.mylabel =…`你在修改`不是单独的对象`但是**这个**共享_foo.prototype_对象本身，它将影响任何链接到的对象。`foo.prototype`。这几乎不是你想要的。如果它`是`你想要什么，那么你可能不需要_酒吧_总之，应该只使用`Foo`使代码更简单。`bar.prototype =新foo()`事实上，

`创建一个新的对象，该对象与`foo.prototype**正如我们想要的。但是，它使用**富（…）`“构造函数调用”来完成它。如果该函数有任何副作用（如日志记录、更改状态、对其他对象注册），`将数据属性添加到`这`这些副作用发生在连接的时候（很可能是针对错误的对象）！，而不是只有在最终**bar()`“后代”被创造出来，正如人们所预料的那样。`**所以，我们剩下的是使用`对象创建（..）`使一个新的对象被正确地连接起来，但是没有调用的副作用

富（…）`。缺点是我们必须创建一个新对象，扔掉旧的对象，而不是修改我们提供的现有默认对象。`这将是`美好的`如果有一个标准的和可靠的方法来修改现有对象的链接。之前有一个非标准6，并没有完全跨浏览器的方式，通过

\_\_proto\_\_。_财产，这是设置。6添加_对象。setprototypeof（..）`助手实用程序，它以标准和可预测的方式进行操作。`比较pre-es6 ES6标准和技术连接`bar.prototype`到

foo.prototype`，并排：`忽略了轻微的性能劣势（扔掉一个后来垃圾收集的对象）`对象创建（..）`的方法，它是短一点，可以或许更容易阅读比6 +方法。但这可能是一种语法清洗。

```js
// pre-ES6
// throws away default existing `Bar.prototype`
Bar.prototype = Object.create( Foo.prototype );

// ES6+
// modifies existing `Bar.prototype`
Object.setPrototypeOf( Bar.prototype, Foo.prototype );
```

检查阶级关系`如果你有一个对象`一

### 想知道它代表了什么对象（如果有的话）？检查一个实例（JS中的一个对象）的继承祖先（js中的委托链接）通常称为

反思`（或`反射_在传统的面向类的环境中。_考虑：_我们如何反省_一

找出它的“祖先”（代表团联系）？第一种方法包括“类”混淆：

```js
function Foo() {
	// ...
}

Foo.prototype.blah = ...;

var a = new Foo();
```

这个`运算符`运算符将一个普通对象作为它的左操作数和

```js
a instanceof Foo; // true
```

功能`作为它的右操作数。这个问题`运算符**答案是：**在整个`[原型]`链**一`对象是否被任意指向`foo.prototype`会出现吗？`不幸的是，这`foo.prototype`会出现吗？**

不幸的是，这意味着您只能查询某个对象的“祖先”。`一`如果你有一些**功能**（`Foo`附随附`原型。`参考）用。如果你有两个任意对象，比如`一`和`B`想知道是否_对象_通过一个相互关联`[原型]`链，`运算符`光忍不住。

**注：**如果你使用内置的`绑定（…）`实用程序使一个硬函数（见第2章），创建的函数不会有一个`原型。`财产。使用`运算符`这样的函数可以透明地替换`原型。`的_目标函数_硬函数是由。

将硬绑定函数用作“构造函数调用”是很少见的，但如果这样做，它的行为将像原始函数一样。_目标函数_调用了，这意味着使用`运算符`带硬函数的函数也根据原函数的行为。

这个片段说明努力之间的关系的理性的荒谬**两个对象**使用“类”语义和`运算符`：

```js
// helper utility to see if `o1` is
// related to (delegates to) `o2`
function isRelatedTo(o1, o2) {
	function F(){}
	F.prototype = o2;
	return o1 instanceof F;
}

var a = {};
var b = Object.create( a );

isRelatedTo( b, a ); // true
```

里面`isrelatedto（..）`我们借用一个扔掉的功能`F`重新分配它，`原型。`任意指向某物体`O2`然后问是否`O1`是“实例”`F`。很明显`O1`不是_事实上_继承的、下降的甚至建造的`F`所以，应该清楚为什么这种运动是愚蠢和混乱的。**问题归结为JavaScript强制的类语义的笨拙。**在这种情况下，间接语义揭示了`运算符`。

第二，更清洁，接近`[原型]`反射：

```js
Foo.prototype.isPrototypeOf( a ); // true
```

请注意，在这种情况下，我们并不真正关心（甚至）_需要_）`Foo`我们只需要一个**对象**（在我们的例子中，任意标记`foo.prototype`测试另一个**对象**。这个问题`isprototypeof（..）`答案是：**在整个`[原型]`链`一`，并`foo.prototype`会出现吗？**

同样的问题，完全相同的答案。但在这第二种方法中，我们并不需要引用间接寻址**功能**（`Foo`）的`原型。`将自动查阅属性。

我们_只是需要_二**物体**检查他们之间的关系。例如:

```js
// Simply: does `b` appear anywhere in
// `c`s [[Prototype]] chain?
b.isPrototypeOf( c );
```

注意，这种方法根本不需要一个函数（“类”）。它只是直接使用对象引用。`B`和`C`并询问他们之间的关系。换句话说，我们`isrelatedto（..）`上面的实用程序是内置于语言中的，它被称为`isprototypeof（..）`。

我们也可以直接检索`[原型]`物体的。由于ES5，这样的标准方法是：

```js
Object.getPrototypeOf( a );
```

您会注意到对象引用正是我们所期望的：

```js
Object.getPrototypeOf( a ) === Foo.prototype; // true
```

大多数浏览器（不是全部）！也长期支持非标准的内部访问方式。`[原型]`：

```js
a.__proto__ === Foo.prototype; // true
```

奇怪的`__proto__。`（不规范，直到6！）属性“神奇地”检索内部。`[原型]`作为参考的对象，如果您想直接检查（甚至遍历），这是非常有用的：`__proto__。__proto__…`）链。

正如我们早些时候看到的`构造函数。`，`__proto__。`实际上不存在于您检查的对象上（`一`在我们的运行示例中）。事实上，它的存在（不可数；见2章）的内置`object.prototype`以及其他公用设施（`tostring()。`，`isprototypeof（..）。`等等）。

此外，`__proto__。`看起来像一个属性，但实际上它更合适的认为它作为一个吸气剂/二传手（见第3章）。

粗略地说，我们可以想象`__proto__。`实现（见对象属性定义的第3章）：

```js
Object.defineProperty( Object.prototype, "__proto__", {
	get: function() {
		return Object.getPrototypeOf( this );
	},
	set: function(o) {
		// setPrototypeOf(..) as of ES6
		Object.setPrototypeOf( this, o );
		return o;
	}
} );
```

因此，当我们访问（检索值）时`a.__proto__`就像是打电话`A. __proto__()`（调用吸气剂函数）。_那_函数调用`一`作为其`这`即使吸气剂函数存在于`object.prototype`对象（见第2章）`这`绑定规则），所以它就像是说`（一）getprototypeof对象。`。

`__proto__。`又是一个可设置的属性，就像使用ES6的`对象。setprototypeof（..）`前面所示。不过，一般来说你**不应改变`[原型]`现有对象的**。

有一些很复杂的，先进的技术，用深的一些框架，允许技巧如“子”`阵列`但这在一般的编程实践中通常是不令人满意的，因为它通常导致_许多的_难以理解/维护代码。

**注：**截至6，的`班`关键词将允许一些接近“子”内置的喜欢`阵列`。见附录A讨论`班`在6添加语法。

唯一的另一个狭窄的例外（如前面提到的）将设置`[原型]`默认函数的`原型。`对象引用其他对象（除了`object.prototype`）。这样可以避免用一个新的链接对象完全替换那个默认对象。否则，**最好对待对象。`[原型]`连锁作为一个只读的特性**以便稍后阅读代码。

**注：**JavaScript社区非正式地创造了一个双词下划线，特别是领先的性质`__proto__`：“渣滓”。所以，JavaScript中的“酷孩子”一般都会发音。`__proto__`“在原”。

## 对象链接

正如我们现在看到的，`[原型]`机制是存在于一个对象上的内部链接，它引用另一个对象。

当对第一个对象进行属性/方法引用时，这种链接主要是执行的，并且没有这样的属性/方法存在。在这种情况下，`[原型]`链接告诉引擎查找链接到对象的属性/方法。反过来，如果该对象不能完成查找，则`[原型]`被跟踪，等等。这一系列的对象之间的联系形成了所谓的“原型链”。

### `create()`ING的链接

我们已经彻底揭穿为什么JavaScript`[原型]`机制**不**喜欢_类_我们已经看到了它是如何创造的。**链接**在适当的对象之间。

这一点有什么意义？`[原型]`机制？为什么js开发人员在代码中花这么多精力（仿真类）来连接这些链接呢？

还记得我们在本章前面说过的话吗？`对象创建（..）`会成为英雄吗？现在，我们准备看看如何。

```js
var foo = {
	something: function() {
		console.log( "Tell me something good..." );
	}
};

var bar = Object.create( foo );

bar.something(); // Tell me something good...
```

`对象创建（..）`创建一个新对象（`酒吧`）链接到我们指定的对象（`Foo`），这给我们所有的权力（代表团）`[原型]`机制，但没有任何不必要的并发症`新的`充当类和构造函数调用的函数，使人困惑。`原型。`和`构造函数。`参考资料，或任何额外的东西。

**注：**对象创建（null）`创建具有空的对象（又名，`无效的`）`\[原型]`链接，因此对象不能委托任何地方。因为这样的对象没有原型链，所以`运算符`操作符（前面解释过）没有什么要检查的，所以它总是返回。`假`。这些特别的空—`\[原型]`对象通常被称为“字典”，因为它们通常只用于在属性中存储数据，主要是因为它们对任何已委派的属性/函数都不可能产生意外的影响。`\[原型]`链，因此是纯粹的平面数据存储。`我们不

需要_创建两个对象之间有意义的关系的类。我们唯一应该做的事_真的很在乎**对象是否链接在一起进行授权，以及**对象创建（..）`给我们联系没有所有类缺陷。`create()对象。

#### `polyfilled`对象创建（..）

`加入ES5。你可能需要支持pre-es5环境（如旧版IE的），所以让我们简单的看一看`部分**polyfill为**对象创建（..）`这给了我们在旧的JS环境中所需要的能力：`这是通过使用polyfill扔掉

```js
if (!Object.create) {
	Object.create = function(o) {
		function F(){}
		F.prototype = o;
		return new F();
	};
}
```

F`函数及其重写`原型。`属性指向要链接到的对象。然后我们使用`新的f()`构造以创建一个将按照我们指定的链接的新对象。`这种用法

对象创建（..）`是迄今为止最常用的用法，因为它是`可以是_polyfilled。有一个额外的功能，标准的ES5内置_对象创建（..）`提供，这是`不polyfillable**对于pre-es5。因此，这种能力远远不常用。为了完整起见，让我们看看附加功能：**第二个论点

```js
var anotherObject = {
	a: 2
};

var myObject = Object.create( anotherObject, {
	b: {
		enumerable: false,
		writable: true,
		configurable: false,
		value: 3
	},
	c: {
		enumerable: true,
		writable: false,
		configurable: false,
		value: 4
	}
} );

myObject.hasOwnProperty( "a" ); // false
myObject.hasOwnProperty( "b" ); // true
myObject.hasOwnProperty( "c" ); // true

myObject.a; // 2
myObject.b; // 3
myObject.c; // 4
```

对象创建（..）`通过声明每个新属性，指定要添加到新创建的对象的属性名。`属性描述符_（见第3章）。因为polyfilling属性描述符为pre-es5是不可能的，这个额外的功能_对象创建（..）`也不能polyfilled。`绝大多数的使用

对象创建（..）`采用功能polyfill安全子集，因此大多数开发商都好用`部分polyfill**在pre-es5环境。**一些开发商采取更严格的观点，即没有功能应polyfilled除非能

地_polyfilled。自_对象创建（..）`是其中的一个partial-polyfill'able事业，这个狭隘的角度说，如果你需要的功能`对象创建（..）`在pre-es5环境，而不是polyfilling，你应该使用一个自定义的效用，并远离使用的名称`object.create`完全。您可以定义自己的实用程序，比如：`我不同意这种严格的意见。我完全赞同普遍偏polyfill的

```js
function createAndLinkObject(o) {
	function F(){}
	F.prototype = o;
	return new F();
}

var anotherObject = {
	a: 2
};

var myObject = createAndLinkObject( anotherObject );

myObject.a; // 2
```

对象创建（..）`如上图所示，并用它在你的代码甚至在pre-es5。我会让你自己做决定的。`联系Fallbacks？

### 认为对象之间的这些联系可能是诱人的。

主要地_为“丢失”属性或方法提供一种回退。虽然这可能是一个观察到的结果，但我不认为它代表了正确的思考方式。_\[原型]`。`考虑：

该代码将根据

```js
var anotherObject = {
	cool: function() {
		console.log( "cool!" );
	}
};

var myObject = Object.create( anotherObject );

myObject.cool(); // "cool!"
```

\[原型]`但是如果你坚持`但是如果你那样写的话`另`充当后援**以防万一**MyObject`无法处理某些开发人员可能试图调用的一些属性/方法，这可能是因为您的软件会更“神奇”，更难理解和维护。`这并不是说不存在的情况下，回退是一个合适的设计模式，但并不常见或惯用的JS，所以如果你发现你这样做，你可能要退后一步，重新考虑是否真的合适、合理的设计。

注：

**在一个称为6，先进的功能**代理`介绍了可以提供某种“方法未发现”的行为类型。`代理`超出了这本书的范围，但将在后面的一本书中详细介绍。`“你不知道JS”_系列。_不要错过一个重要但微妙的观点。

**为开发人员设计软件，例如，调用**

cool() MyObject。`即使没有，也可以做那项工作`cool()`方法`MyObject`在API设计中引入一些“魔力”，对于未来维护软件的开发人员来说，这可能是令人惊讶的。`然而，你可以用较少的“魔力”来设计你的API，但仍然利用它的力量。

\[原型]`联动。`在这里，我们调用

```js
var anotherObject = {
	cool: function() {
		console.log( "cool!" );
	}
};

var myObject = Object.create( anotherObject );

myObject.doCool = function() {
	this.cool(); // internal delegation!
};

myObject.doCool(); // "cool!"
```

docool() MyObject。`这是一种方法`真的存在_在_MyObject`使我们的API设计更加明确（少“神奇”）。`内部_我们的实现如下_代理设计模式**（见第6章），利用**\[原型]`代表团`另cool()。`。`换句话说，如果它是一个内部实现细节，而不是在API设计中清楚地暴露，那么委派将不会那么令人惊讶/迷惑。我们将阐述

代表团**下一章非常详细。**回顾（TL；DR）

## 当试图对不具有该属性的对象进行属性访问时，对象的内部

\[原型]`链接定义了`\[得到]`操作（见第3章）应着眼于下一步。这种从对象到对象的级联连接本质上定义了一个“原型链”（有些类似于嵌套的范围链），用于遍历属性解析的对象。`所有正常对象都有内置的

object.prototype`作为原型链的顶部（如范围查找中的全局范围），如果在链中没有找到任何属性，则属性解析将停止。`tostring()`，`valueof()`以及其他一些常见的实用程序存在于此`object.prototype`对象，解释语言中所有对象如何能够访问它们。`获取两个相互关联的对象的最常用方法是

新的`在函数的四个步骤中（参见第2章），它创建一个链接到另一个对象的新对象。`新对象链接到的另一个对象恰好是任意命名的对象。

原型。`调用的函数的属性`新的`。函数调用`新的`通常被称为“建设者”，尽管他们实际上没有实例化一个类`构造函数_用传统的面向类的语言。_虽然这些JavaScript机制似乎类似于传统面向类语言的“类实例化”和“类继承”，但关键区别在于JavaScript中没有复制。相反，对象最终通过内部连接。

\[原型]`链。`因为各种各样的原因，不仅仅是术语的先例，“继承”（与“原型继承”）和所有其他的面向对象的条款就没有意义的时候，考虑到JavaScript

事实上_作品（不仅仅适用于我们的强迫心智模型）。_相反，“委托”是一个更恰当的术语，因为这些关系不是。

副本_但代表团_链接**。**。
