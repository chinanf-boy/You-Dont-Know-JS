
# 你不认识JS: _这_与对象的原型

# 第5章: 原型

在第3章和第4章中,我们提到了`[原型]`链了好几次,但都没说到底是什么ㄢ我们现在将详细检查原型ㄢ

**注: **所有的模仿复制类行为的尝试,正如4章先前描述的,称为"混合ℽ的变化,完全规避`[原型]`我们在本章中讨论的链式机制ㄢ

## `[原型]`

JavaScript中的对象有一个内部属性,在规范中表示为`[原型]`,这只是对另一个对象的引用ㄢ几乎所有对象都给出非ℴ`无效的`此属性在创建时的值ㄢ

**注: **我们很快就会看到的ㄢ_是_可能对象有空`[原型]`链接,虽然这有点不常见ㄢ

考虑: 

```js
var myObject = {
	a: 2
};

myObject.a; // 2
```

什么是`[原型]`引用用于?在第3章中,我们研究了`[得到]`引用对象上的属性时调用的操作,例如`一个MyObjectㄢ`ㄢ为默认`[得到]`操作,第一步是检查对象本身是否具有属性ㄢ`一`在上面,如果是的话,它被使用了ㄢ

**注: **ES6代理这本书的讨论范围之外(将覆盖在系列!后来的书)但我们在这里讨论的一切都是正常的`[得到]`和`[ⅆ]`behavior does not apply if a`代理`参与ㄢ

但如果发生`一` **不是**目前对`MyObject`这就引起我们的注意ㄢ`[原型]`对象链接ㄢ

默认的`[得到]`操作继续进行`[原型]` **链接**如果对象不能直接在对象上找到所请求的属性,则ㄢ

```js
var anotherObject = {
	a: 2
};

// create an object linked to `anotherObject`
var myObject = Object.create( anotherObject );

myObject.a; // 2
```

**注: **我们将解释什么`对象创建(..)`短期内是如何运作的?ㄢ现在,假设它用`[原型]`链接,我们正在检查指定的对象ㄢ

所以,我们有`MyObject`这就是现在`[原型]`联系`另`ㄢ明确`一个MyObjectㄢ`实际上并不存在,但是,属性访问成功(在`另`相反,确实发现了价值ㄢ`二`ㄢ

但是,如果`一`没有发现`另`要么,它`[原型]`链条,如果不是空的,请再次咨询和遵循ㄢ

此过程将继续进行,直到找到匹配的属性名,或`[原型]`链的末端ㄢ如果没有匹配属性_曾经_在链的末端发现,返回结果来自`[得到]`操作`未定义`ㄢ

类似这样的`[原型]`链查找过程,如果你用`对..`循环迭代一个对象,通过它的链可以到达的任何属性(也是`枚举`ℴℴ参见第3章)将被列举ㄢ如果您使用`在里面`运算符测试对象上某个属性是否存在,`在里面`将检查对象的整个链(不管_枚举_)ㄢ

```js
var anotherObject = {
	a: 2
};

// create an object linked to `anotherObject`
var myObject = Object.create( anotherObject );

for (var k in myObject) {
	console.log("found: " + k);
}
// found: a

("a" in myObject); // true
```

因此,该`[原型]`当你在各种时尚中进行财产检查时,连锁店一次一个环节ㄢ一旦找到属性或链结束,查找就会停止ㄢ

### `object.prototype`

但_哪里_到底是什么`[原型]`链"结束ℽ?

每一个顶点_正常的_ `[原型]`链是内置的`object.prototype`ㄢ这个对象包含了JS上使用的各种常见实用程序,因为JavaScript中的所有"正常ℽ(内置的,不是主机特定的扩展)对象都是从"下降ℽ中派生出来的ㄢ`[原型]`链)的`object.prototype`对象ㄢ

您可能熟悉的一些实用程序包括`tostring()ㄢ`和`valueof()ㄢ`ㄢ在第3章中,我们介绍了另一个: `hasownproperty(..)ㄢ`ㄢ还有另一个功能`object.prototype`您可能不熟悉,但我们将在本章后面提到的是`isprototypeof(..)ㄢ`ㄢ

### 设置和跟踪属性

回到第3章,我们提到在对象上设置属性要比向对象添加一个新属性或者改变一个现有属性的值更微妙ㄢ我们现在将更全面地重新审视这种情况ㄢ

```js
myObject.foo = "bar";
```

如果`MyObject`对象已经有一个正常的数据访问特性称为`Foo`直接出现在它上,任务就像改变现有财产的价值一样简单ㄢ

如果`Foo`没有直接出现在`MyObject`,的`[原型]`链被遍历,就像`[得到]`操作ㄢ如果`Foo`在链的任何地方都找不到,属性`Foo`直接添加到`MyObject`如预期的那样指定值ㄢ

然而,如果`Foo`已经存在于链中更高的位置,可能会出现微妙的(也许是令人惊讶的)行为ㄢ`myobject.foo ="酒吧ℽ`分配ㄢ我们会在一瞬间检查更多ㄢ

如果属性名`Foo`双方都结束了`MyObject`本身和更高层次的`[原型]`开始于`MyObject`这叫做_阴影_ㄢ这个`Foo`财产直接`MyObject` _阴影_任何`Foo`在链中看起来更高的属性,因为`myobject.foo`查会`Foo`在链中最低的属性ㄢ

正如我们刚才暗示的,阴影`Foo`在`MyObject`并不像看上去那么简单ㄢ现在我们将研究三个场景`myobject.foo ="酒吧ℽ`分配时`Foo`是**不**已经在`MyObject`直接,但**是**在较高的水平上`MyObject`的`[原型]`链: 

1.  如果一个正常的数据访问(见3章)属性命名`Foo`在任何地方都能找到ㄢ`[原型]`链,**而且它没有标记为只读(`写: 假`)**然后调用一个新属性`Foo`直接添加到`MyObject`导致**阴影属性**ㄢ
2.  如果一个`Foo`在ⅆ`[原型]`链,但它被标记为**只读(`写: 假`)**然后,既有现有属性的设置,也可以创建阴影属性ㄢ`MyObject` **是不允许的**ㄢ如果代码正在运行`严格模式`将抛出一个错误ㄢ否则,属性值的设置将被忽略ㄢ无论哪种方式,**无遮蔽的发生**ㄢ
3.  如果一个`Foo`在ⅆ`[原型]`链,它是一个二传手(见第3章),然后二传将永远被称为ㄢ不`Foo`将被添加到(又名,阴影上)`MyObject`也不会`Foo`二传手被重新定义ㄢ

大多数开发商假定转让财产ㄢ`[ⅆ]`如果属性已经存在,那么将始终导致阴影ㄢ`[原型]`链,但你可以看到,在一个真正的(# 1)的三种情况描述ㄢ

如果你想影子`Foo`在例2和3 # #,不能使用`=`赋值,但必须使用`对象ㄢdefineproperty(..)`(见第3章)`Foo`到`MyObject`ㄢ

**注: **案例# 5月2日是最令人惊讶的三ㄢA的存在_只读_属性防止在一个较低级别的隐式创建(阴影)的同一名称的属性ㄢ`[原型]`链ㄢ这种限制的原因主要是为了增强类继承属性的错觉ㄢ如果你想到`Foo`在链的较高层次上,被继承(复制)到`MyObject`那么,强制执行该文件的非可写性是有意义的ㄢ`Foo`财产`MyObject`ㄢ然而,如果你将幻觉与事实分开,并认识到没有这种继承复制ㄢ_事实上_发生了(见第4章和第5章),这有点不自然ㄢ`MyObject`将防止有`Foo`属性只是因为其他对象具有不可写性ㄢ`Foo`在这ㄢ更奇怪的是,这种限制只适用于`=`赋值,但使用时不强制执行`对象ㄢdefineproperty(..)`ㄢ

阴影**方法**导致了难看的_明确的伪基因多态性_(见第4章)如果您需要在两者之间进行委托ㄢ通常,阴影比它的价值更为复杂和微妙,**所以,如果可能的话,你应该尽量避免ㄢ**ㄢ见第6章的替代设计模式,其中除其他事项阻止阴影有利于更清洁的替代品ㄢ

阴影甚至可以以微妙的方式隐式发生,所以如果试图避免它,就必须小心ㄢ考虑: 

```js
var anotherObject = {
	a: 2
};

var myObject = Object.create( anotherObject );

anotherObject.a; // 2
myObject.a; // 2

anotherObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "a" ); // false

myObject.a++; // oops, implicit shadowing!

anotherObject.a; // 2
myObject.a; // 3

myObject.hasOwnProperty( "a" ); // true
```

虽然看起来可能`MyObjectㄢ+ +`应该(通过委托)查找并只增加`另一个ㄢ`财产本身_在的地方_相反的,`+ +`操作对应`MyObjectㄢ= MyObjectㄢ+ 1`ㄢ其结果是`[得到]`抬头`一`属性通过`[原型]`获取当前值`二`从`另一个ㄢ`,增加价值,然后`[ⅆ]`分配`三`值为新的阴影属性ㄢ`一`在`MyObject`ㄢ哎呀!

处理您修改的委托属性时要非常小心ㄢ如果你想增加`另一个ㄢ`唯一正确的方法是`另一个C++ㄢ`ㄢ

## "类ℽ

此时,您可能会疑惑: "_为什么_一个对象需要链接到另一个对象吗?ℽ真正的好处是什么?这是一个非常恰当的问题,但我们必须首先明白什么是什么ㄢ`[原型]`是**不**之前我们可以充分理解和欣赏它ㄢ_是_以及它是如何有用的ㄢ

正如我们在第4章中所解释的,在JavaScript中,对于面向类的语言,没有所谓的"类ℽ对象的抽象模式/蓝图ㄢJavaScript**只是**有对象ㄢ

事实上,JavaScript是**几乎是独一无二的**在语言中,可能是唯一一种有权使用"面向对象ℽ标签的语言,因为它是一种很短的语言列表,其中的对象可以直接创建,而不需要类ㄢ

在JavaScript,阶级不能(因为他们不存在!)描述一个物体能做什么ㄢ对象直接定义自己的行为ㄢ**有_只是_对象ㄢ**

### "类ℽ函数

有个古怪的行为,一直无耻地滥用JavaScript来_乱劈_的东西,_看_像"类ℽㄢ我们将详细研究这种方法ㄢ

独特的"类的类ℽ的行为取决于函数的一个奇怪的特点: 所有功能默认情况下被公开,不可枚举(见3章)对他们所谓的财产`原型`,指向另一个任意对象ㄢ

```js
function Foo() {
	// ...
}

Foo.prototype; // { }
```

这个对象通常被称为"富的原型ℽ,因为我们通过一个不幸的名字访问它ㄢ`foo.prototype`属性参考ㄢ然而,这一术语毫无意义地注定要使我们陷入混乱,我们不久就会看到ㄢ相反,我将把它称为"以前称为富的原型ℽ的对象ㄢ只是在开玩笑ㄢ如何: "对象任意标记的"点原型ℽℽ?

不管我们叫什么,这个对象到底是什么?

解释它的最直接的方法是从调用中创建的每个对象ㄢ`新的foo()`(见第2章)将结束(有些武断)ㄢ`[原型]`-链接到这个"点原型ℽ对象ㄢ

让我们举例说明: 

```js
function Foo() {
	// ...
}

var a = new Foo();

Object.getPrototypeOf( a ) === Foo.prototype; // true
```

什么时候`一`是通过调用创建的`新的foo()`其中一件事(见所有的第2章)ㄢ_四_这种情况发生的原因是`一`有一个内部`[原型]`链接到对象`foo.prototype`指着ㄢ

停一下,思考一下那句话的含意ㄢ

在面向类的语言中,多**副本**类的(例如,"实例ℽ)可以做,比如从模具中冲压出一些东西ㄢ正如我们在4章中看到的,这是因为实例化过程(或继承)一类的意思,"复制行为的计划从类到一个物理对象ℽ,这是每一个新的实例再做ㄢ

但在JavaScript,没有这样的复制行为ㄢ您不创建类的多个实例ㄢ您可以创建多个对象`[原型]` _链接_对一个共同的对象ㄢ但默认情况下,不会发生复制,因此这些对象不会最终完全分离和断开,而是相当**_链接_**ㄢ

`新的foo()`结果出现在一个新对象中(我们称之为`一`),和**那个**新的对象`一`内部`[原型]`联系到`foo.prototype`对象ㄢ

**我们最终得到两个互相连接的对象ㄢ**那是_它_ㄢ我们没有实例化一个类ㄢ我们当然没有把任何行为从一个"类ℽ复制到一个具体对象中ㄢ我们刚把两个物体连在一起ㄢ

事实上,这个秘密,这使得大多数JS开发者,是的`新的foo()`函数调用实际上几乎没有_直接的_处理创建链接的过程ㄢ**这是一种偶然的副作用ㄢ** `新的foo()`是一种迂回的ㄡ迂回的方式来达到我们想要的结果: **链接到另一个对象的新对象**ㄢ

我们能得到更多我们想要的吗?_直接的_路吗?**对!**英雄`对象创建(..)`ㄢ但我们会得到一点ㄢ

#### 名字里有什么?

在JavaScript中,我们不做_副本_从一个对象("类ℽ)到另一个对象("实例ℽ)ㄢ我们做的_链接_对象之间的ㄢ对于`[原型]`在视觉上,箭头从右向左移动,从底部移动到顶部ㄢ

<img src="fig3.png">

这种机制被称为"原型继承ℽ(我们将探讨代码详细不久),通常称为"经典传承的动态语言版本ℽㄢ这是一种试图在阶级导向的世界中对"继承ℽ意味着什么的共同理解,但_扭_(**阅读: 铺路**理解的语义,以适应动态脚本ㄢ

"继承ℽ一词有很强的含义(见第4章),有很多的精神先例ㄢ只要加入"原型ℽ前面的区分_实际上几乎是相反的_在JavaScript的行为在其身后近二十年离开泥泞的混乱ㄢ

我想说的是,坚持"原型ℽ前面的"继承ℽ彻底扭转它的实际意思是一手拿着桔子,在另一个苹果,并坚持称苹果"红橙色ℽㄢ不管我在它前面放了什么令人困惑的标签,都不会改变ㄢ_事实_那一个水果是苹果,另一个是桔子ㄢ

更好的方法是简单地称苹果为苹果ℴℴ使用最准确ㄡ最直接的术语ㄢ这样就更容易理解它们的相似之处和它们的相似之处ㄢ**许多的差异**因为我们都有一个简单的ㄡ共同的理解"苹果ℽ是什么意思ㄢ

由于混淆和术语混为一谈,我相信"原型继承ℽ本身(并试图MIS应用所有相关的类方向的术语,如"类ℽㄡ"构造ℽㄡ"实例ℽㄡ"多态性ℽ,等)做了**弊大于利**在解释JavaScript机制的过程中_真正地_作品.

"继承ℽ意味着_复制_操作,和JavaScript不复制对象的属性(本机默认)ㄢ相反,js在两个对象之间创建了一个链接,其中一个对象本质上可以是一个对象ㄢ_代表_访问另一个对象的属性/函数ㄢ"委托ℽ(参见第6章)是JavaScript对象链接机制的一个更准确的术语ㄢ

有时在JavaScript中抛出的另一个术语是"差异继承ℽㄢ这里的想法是,我们描述一个对象的行为在什么方面ㄢ_不同的_从更一般的描述符ㄢ例如,你解释汽车是一种汽车,但有一辆正好有4个轮子ㄢ

如果你试着把js中的给定对象看作是所有行为的总和ㄢ_可获得的_经授权,并**在你的脑海里你变平了**所有这些行为变成一个有形的_事情_,然后你可以(有点)看到"微分继承ℽ可能适合ㄢ

但就像"原型继承ℽㄡ"微分继承"假装你的心智模型比语言所产生的身体更重要ㄢ它忽略了对象的事实ㄢ`B`实际上并不是差异化构造,而是与定义的特定特性一起构建,与"空洞ℽ一起定义ㄢ正是在这些"漏洞ℽ(差距,或缺乏定义)的代表团ㄢ_可以_接管,并立即,"填充他们ℽ与委托行为ㄢ

默认情况下,该对象不会被转换为单个差分对象,**通过复制**"微分继承ℽ的心智模式意味着ㄢ因此,"差异继承ℽ并不是天生就适合描述JavaScript的`[原型]`机制实际工作ㄢ

你_可以选择_更喜欢"差异继承ℽ的术语和心理模型,作为一个口味的问题,但不能否认的事实是_只有_适合你头脑中的技巧,而不是发动机中的物理行为ㄢ

### "建设者ℽ

让我们回到早期的代码: 

```js
function Foo() {
	// ...
}

var a = new Foo();
```

到底是什么让我们思考`Foo`是一个"类ℽ吗?

首先,我们看到了`新的`关键字,就像类面向语言在构建类实例时所做的那样ㄢ另一方面,看来我们实际上是在执行一个_构造函数_类的方法,因为`foo()`实际上是一种调用方法,就像实例化类时如何调用一个真正类的构造函数一样ㄢ

为了进一步混淆"构造函数ℽ语义,任意标记`foo.prototype`对象还有另一个技巧ㄢ考虑这个代码: 

```js
function Foo() {
	// ...
}

Foo.prototype.constructor === Foo; // true

var a = new Foo();
a.constructor === Foo; // true
```

这个`foo.prototype`默认情况下的对象(在代码片段第1行的声明时间)!获取一个公共,不可枚举(见3章)的属性称为`构造函数ㄢ`这个属性是函数的引用(`Foo`在这种情况下)对象与ㄢ此外,我们看到了这个对象ㄢ`一`由"构造函数ℽ调用创建`新的foo()` _似乎_也有它的属性叫做`构造函数ㄢ`这也类似于"创造它的功能ℽㄢ

**注: **事实并非如此ㄢ`一`没有`构造函数ㄢ`财产,虽然`a.constructor`事实上解决了`Foo`函数"构造函数ℽ**实际上并不意味着**"由它构建ℽ,正如它所显示的ㄢ我们将很快解释这种陌生感ㄢ

哦,是的,也ⅆ按照JavaScript世界中的约定,"类ℽES用大写字母命名,所以它是`Foo`而不是`Foo`是一个强烈的线索,我们打算它是一个"类ℽㄢ这对你来说完全是对的,对吗?!?

**注: **该公约是如此强烈,很多JS短绒实际上_抱怨_如果你打电话`新的`在一个带有小写名称的方法上,或者如果我们不调用`新的`关于以大写字母开头的函数ㄢ那种犹豫不决,我们做太多的抗争来获得(假)ℽ类取向ℽ_正确的_在JavaScript,我们创造了短绒规则确保我们使用大写字母的大写字母,尽管并不意味着**_任何东西_完全**到js引擎ㄢ

#### 构造函数或调用?

在上面的片段中,很容易想到`Foo`是一个"构造函数ℽ,因为我们称它为`新的`我们观察到它"构造ℽ一个对象ㄢ

在现实生活中,`Foo`不再是程序中任何其他函数的"构造函数ℽㄢ函数本身是**不**构造函数ㄢ然而,当你把`新的`在正常函数调用前面的关键字,使该函数调用"构造函数调用ℽㄢ事实上,`新的`这种劫持任何正常功能并调用它的方式,构建了一个对象,**除了它要做的任何事情**ㄢ

例如:

```js
function NothingSpecial() {
	console.log( "Don't mind me!" );
}

var a = new NothingSpecial();
// "Don't mind me!"

a; // {}
```

`没什么特别的`只是普通的普通函数,但是当调用时`新的`,它_构建_一个几乎是副作用的对象,我们碰巧分配给它`一`ㄢ这个**呼叫**是一个_构造函数调用_,但`没什么特别的`不是,本身就是_构造函数_ㄢ

换句话说,在JavaScript中,最恰当的说法是"构造函数ℽ是**调用的函数`新的`关键词**在它前面ㄢ

函数不是构造函数,但函数调用是"构造函数调用ℽ,当且仅当`新的`使用ㄢ

### 机械

是_那些_在JavaScript中,不幸的"类ℽ讨论的唯一常见触发器是什么?

**不完全ㄢ**js开发人员努力模拟类的方向: 

```js
function Foo(name) {
	this.name = name;
}

Foo.prototype.myName = function() {
	return this.name;
};

var a = new Foo( "a" );
var b = new Foo( "b" );

a.myName(); // "a"
b.myName(); // "b"
```

这个片段展示了另外两个游戏中的"类倾向ℽ技巧: 

1.  `this.name =名称`: 加`名称`属性放到每个对象上(`一`和`B`分别参见第2章`这`绑定)类似于类实例如何封装数据值ㄢ

2.  `foo.prototype.myname =ⅆ`也许是更有趣的技术,这增加了一个属性ㄢ`foo.prototype`对象ㄢ现在,`A. myname()`工作,但也许令人惊讶ㄢ怎么用?

在上面的片段中,很容易想到`一`和`B`创建,属性/函数在`foo.prototype`对象_复制_到每一个`一`和`B`物体.**然而,这并不是发生了什么ㄢ**

在本章的开头,我们解释了`[原型]`链接,以及如果属性引用不是直接在对象上找到的,它是如何提供返回查找步骤的,作为缺省值的一部分`[得到]`算法.

所以,根据它们是如何产生的,`一`和`B`每个内部都有一个内部ㄢ`[原型]`联动`foo.prototype`ㄢ什么时候`我的名字`没有发现`一`或`B`相反,它是通过(代表团,见第6章)找到的ㄢ`foo.prototype`ㄢ

#### "建设者ℽ

回忆起前面关于这个问题的讨论`构造函数ㄢ`财产,以及它如何_似乎_喜欢`a.constructor = = = foo`真实就是`一`有一个实际的`构造函数ㄢ`指向它的属性`Foo`?**不正确的ㄢ**

这只是不幸的混淆ㄢ事实上,`构造函数ㄢ`也可参考_委派_高达`foo.prototype`,这**发生**默认情况下,有一个`构造函数ㄢ`那点`Foo`ㄢ

它_似乎_非常方便,一个物体`一`"由ℽ构成`Foo`将有机会获得`构造函数ㄢ`指向的属性`Foo`ㄢ但那不过是一种虚假的安全感ㄢ这是一个幸福的事故,几乎是切向的ㄢ`a.constructor` _发生_来点`Foo`通过默认的`[原型]`代表团ㄢ事实上,有几种方法可以让我们假设`构造函数ㄢ`意思是"被造ℽ可以回来咬你ㄢ

一方面,`构造函数ㄢ`财产`foo.prototype`只有在默认创建的对象时才存在`Foo`函数被声明ㄢ如果创建一个新对象,并替换函数的默认值`原型ㄢ`对象引用,默认情况下新对象不会神奇地获得`构造函数ㄢ`在这ㄢ

考虑: 

```js
function Foo() { /* .. */ }

Foo.prototype = { /* .. */ }; // create a new prototype object

var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```

`对象(ⅆ)`没有"建构ℽ`A1`是吗?看起来确实像`foo()`"建造ℽ它ㄢ许多开发商认为`foo()`就像做建筑一样,但当所有东西都分崩离析时,你就认为"构造函数ℽ是"由ℽ建造的,因为那个推理,`a1.constructor`应该是`Foo`但它不是!

在忙什么?`A1`没有`构造函数ㄢ`属性,所以它代表`[原型]`链`foo.prototype`ㄢ但是那个对象没有`构造函数ㄢ`要么(像默认情况一样)`foo.prototype`对象会有!)所以它一直在授权,这一次`object.prototype`,代表团链的顶端ㄢ_那_对象确实有`构造函数ㄢ`在它上面指向内置的`对象(ⅆ)`功能ㄢ

**误解,被破坏ㄢ**

当然,您可以添加`构造函数ㄢ`回到`foo.prototype`对象,但这需要手动工作,特别是如果你想匹配的本地行为,它是不可数(见3章)ㄢ

例如:

```js
function Foo() { /* .. */ }

Foo.prototype = { /* .. */ }; // create a new prototype object

// Need to properly "fix" the missing `.constructor`
// property on the new object serving as `Foo.prototype`.
// See Chapter 3 for `defineProperty(..)`.
Object.defineProperty( Foo.prototype, "constructor" , {
	enumerable: false,
	writable: true,
	configurable: true,
	value: Foo    // point `.constructor` at `Foo`
} );
```

那是很多手工工作需要修理的ㄢ`构造函数ㄢ`ㄢ此外,我们实际上所做的只是延续"构造函数ℽ是"由ℽ构造的误解ㄢ这是一个_昂贵的_幻觉ㄢ

事实是,`构造函数ㄢ`在任意一个对象上,默认情况下,在一个函数中,每个对象都有一个返回对象的引用ℴℴ它调用的一个引用ㄢ`原型ㄢ`ㄢ单词"构造函数ℽ和"原型ℽ只有一个松散的默认含义,可能以后也可能不成立ㄢ最好的办法是提醒自己,"构造函数并不意味着ℽㄢ

`构造函数ㄢ`不是魔法不变的属性ㄢ它_是_不可数(见下段),但它的价值是可写的(可以修改),而且你可以添加或覆盖(有意或无意)的名称的属性`构造函数`在任何物体上`[原型]`链,任何您认为合适的值ㄢ

由于如何`[得到]`遍历`[原型]`链,一`构造函数ㄢ`在任何地方找到的属性引用可能与您期望的完全不同ㄢ

看看它的意思到底有多武断?

结果呢?一些任意对象属性引用如下`a1.constructor`无法被_可信的_为默认函数引用ㄢ此外,正如我们不久将看到的,仅仅是简单的省略,`a1.constructor`甚至可以最终指向的地方相当惊人和昏迷ㄢ

`构造函数ㄢ`非常不可靠,并且在代码中依赖于不安全引用ㄢ**一般情况下,应尽可能避免这种引用ㄢ**

## "(Prototypal)继承ℽ

我们已经看到一些"类ℽ力学的近似,它们通常被攻击到JavaScript程序中ㄢ但是如果我们没有近似"继承ℽ的话,JavaScript"类ℽES就相当空洞了ㄢ

事实上,我们已经看到了机构,通常称为"原型继承ℽ在工作的时候`一`能够"继承ℽ`foo.prototype`从而获得`myname()`功能ㄢ但是我们传统上

<img src="fig3.png">

从前面回顾这个数字,它不仅显示了来自对象的委托(又名"实例ℽ)ㄢ`A1`对象`foo.prototype`,但从`bar.prototype`到`foo.prototype`这有点类似于父类继承的概念ㄢ_像_当然,除了箭头的方向之外,箭头显示的是委托链接,而不是复制操作ㄢ

下面是创建这种链接的典型的"原型风格ℽ代码: 

```js
function Foo(name) {
	this.name = name;
}

Foo.prototype.myName = function() {
	return this.name;
};

function Bar(name,label) {
	Foo.call( this, name );
	this.label = label;
}

// here, we make a new `Bar.prototype`
// linked to `Foo.prototype`
Bar.prototype = Object.create( Foo.prototype );

// Beware! Now `Bar.prototype.constructor` is gone,
// and might need to be manually "fixed" if you're
// in the habit of relying on such properties!

Bar.prototype.myLabel = function() {
	return this.label;
};

var a = new Bar( "a", "obj a" );

a.myName(); // "a"
a.myLabel(); // "obj a"
```

**注: **要理解为什么`这`点`一`在上面的代码片段中,见第2章ㄢ

The important part is`bar.prototype =(foo.prototype)创建对象ㄢ`ㄢ`对象创建(..)` _创建_一个"新ℽ的物体从稀薄的空气,并链接新对象的内部`[原型]`对指定的对象(`foo.prototype`在这种情况下)ㄢ

换句话说,那句话是: "做一个_新的_"点原型ℽ对象,链接到"点原型ℽㄢ

什么时候`功能bar() { ..}`声明,`酒吧`和其他函数一样,有一个`原型ㄢ`链接到它的默认对象ㄢ但_那个_对象没有链接到`foo.prototype`像我们想要的ㄢ所以,我们创建一个_新的_对象_是_链接到我们想要的,有效地丢弃原始的不正确链接对象ㄢ

**注: **一个常见的MIS概念/困惑是以下任一种方法_也_工作,但它们不能像你期望的那样工作: 

```js
// doesn't work like you want!
Bar.prototype = Foo.prototype;

// works kinda like you want, but with
// side-effects you probably don't want :(
Bar.prototype = new Foo();
```

`bar.prototype = foo.prototype`不创建一个新对象`bar.prototype`联系ㄢ它只是使`bar.prototype`是另一个参考`foo.prototype`有效链接`酒吧`直接**同一对象** `Foo`链接: `foo.prototype`ㄢ这意味着当你开始赋值时,比如`bar.prototype.mylabel =ⅆ`你在修改**不是单独的对象**但是_这个_共享`foo.prototype`对象本身,它将影响任何链接到的对象ㄢ`foo.prototype`ㄢ这几乎不是你想要的ㄢ如果它_是_你想要什么,那么你可能不需要`酒吧`总之,应该只使用`Foo`使代码更简单ㄢ

`bar.prototype =新foo()` **事实上,**创建一个新的对象,该对象与`foo.prototype`正如我们想要的ㄢ但是,它使用`富(ⅆ)`"构造函数调用ℽ来完成它ㄢ如果该函数有任何副作用(如日志记录ㄡ更改状态ㄡ对其他对象注册),**将数据属性添加到`这`**这些副作用发生在连接的时候(很可能是针对错误的对象)!,而不是只有在最终`bar()`"后代ℽ被创造出来,正如人们所预料的那样ㄢ

所以,我们剩下的是使用`对象创建(..)`使一个新的对象被正确地连接起来,但是没有调用的副作用`富(ⅆ)`ㄢ缺点是我们必须创建一个新对象,扔掉旧的对象,而不是修改我们提供的现有默认对象ㄢ

这将是_美好的_如果有一个标准的和可靠的方法来修改现有对象的链接ㄢ之前有一个非标准6,并没有完全跨浏览器的方式,通过`__proto__ㄢ`财产,这是设置ㄢ6添加`对象ㄢsetprototypeof(..)`助手实用程序,它以标准和可预测的方式进行操作ㄢ

比较pre-es6 ES6标准和技术连接`bar.prototype`到`foo.prototype`,并排: 

```js
// pre-ES6
// throws away default existing `Bar.prototype`
Bar.prototype = Object.create( Foo.prototype );

// ES6+
// modifies existing `Bar.prototype`
Object.setPrototypeOf( Bar.prototype, Foo.prototype );
```

忽略了轻微的性能劣势(扔掉一个后来垃圾收集的对象)`对象创建(..)`的方法,它是短一点,可以或许更容易阅读比6 +方法ㄢ但这可能是一种语法清洗ㄢ

### 检查阶级关系

如果你有一个对象`一`想知道它代表了什么对象(如果有的话)?检查一个实例(JS中的一个对象)的继承祖先(js中的委托链接)通常称为_反思_(或_反射_在传统的面向类的环境中ㄢ

考虑: 

```js
function Foo() {
	// ...
}

Foo.prototype.blah = ...;

var a = new Foo();
```

我们如何反省`一`找出它的"祖先ℽ(代表团联系)?第一种方法包括"类ℽ混淆: 

```js
a instanceof Foo; // true
```

这个`运算符`运算符将一个普通对象作为它的左操作数和**功能**作为它的右操作数ㄢ这个问题`运算符`答案是: **在整个`[原型]`链`一`对象是否被任意指向`foo.prototype`会出现吗?**

不幸的是,这意味着您只能查询某个对象的"祖先ℽㄢ`一`如果你有一些**功能**(`Foo`附随附`原型ㄢ`参考)用ㄢ如果你有两个任意对象,比如`一`和`B`想知道是否_对象_通过一个相互关联`[原型]`链,`运算符`光忍不住ㄢ

**注: **如果你使用内置的`绑定(ⅆ)`实用程序使一个硬函数(见第2章),创建的函数不会有一个`原型ㄢ`财产ㄢ使用`运算符`这样的函数可以透明地替换`原型ㄢ`的_目标函数_硬函数是由ㄢ

使用硬约束函数是相当罕见的_目标函数_调用了,这意味着使用`运算符`带硬函数的函数也根据原函数的行为ㄢ

这个片段说明努力之间的关系的理性的荒谬**两个对象**使用"类ℽ语义和`运算符`: 

```js
// helper utility to see if `o1` is
// related to (delegates to) `o2`
function isRelatedTo(o1, o2) {
	function F(){}
	F.prototype = o2;
	return o1 instanceof F;
}

var a = {};
var b = Object.create( a );

isRelatedTo( b, a ); // true
```

里面`isrelatedto(..)`我们借用一个扔掉的功能`F`重新分配它,`原型ㄢ`任意指向某物体`O2`然后问是否`O1`是"实例ℽ`F`ㄢ很明显`O1`不是_事实上_继承的ㄡ下降的甚至建造的`F`所以,应该清楚为什么这种运动是愚蠢和混乱的ㄢ**问题归结为JavaScript强制的类语义的笨拙ㄢ**在这种情况下,间接语义揭示了`运算符`ㄢ

第二,更清洁,接近`[原型]`反射: 

```js
Foo.prototype.isPrototypeOf( a ); // true
```

请注意,在这种情况下,我们并不真正关心(甚至)_需要_)`Foo`我们只需要一个**对象**(在我们的例子中,任意标记`foo.prototype`测试另一个**对象**ㄢ这个问题`isprototypeof(..)`答案是: **在整个`[原型]`链`一`,并`foo.prototype`会出现吗?**

同样的问题,完全相同的答案ㄢ但在这第二种方法中,我们并不需要引用间接寻址**功能**(`Foo`)的`原型ㄢ`将自动查阅属性ㄢ

我们_只是需要_二**物体**检查他们之间的关系ㄢ例如:

```js
// Simply: does `b` appear anywhere in
// `c`s [[Prototype]] chain?
b.isPrototypeOf( c );
```

注意,这种方法根本不需要一个函数("类ℽ)ㄢ它只是直接使用对象引用ㄢ`B`和`C`并询问他们之间的关系ㄢ换句话说,我们`isrelatedto(..)`上面的实用程序是内置于语言中的,它被称为`isprototypeof(..)`ㄢ

我们也可以直接检索`[原型]`物体的ㄢ由于ES5,这样的标准方法是: 

```js
Object.getPrototypeOf( a );
```

您会注意到对象引用正是我们所期望的: 

```js
Object.getPrototypeOf( a ) === Foo.prototype; // true
```

大多数浏览器(不是全部)!也长期支持非标准的内部访问方式ㄢ`[原型]`: 

```js
a.__proto__ === Foo.prototype; // true
```

奇怪的`__proto__ㄢ`(不规范,直到6!)属性"神奇地ℽ检索内部ㄢ`[原型]`作为参考的对象,如果您想直接检查(甚至遍历),这是非常有用的: `__proto__ㄢ__proto__ⅆ`)链ㄢ

正如我们早些时候看到的`构造函数ㄢ`,`__proto__ㄢ`实际上不存在于您检查的对象上(`一`在我们的运行示例中)ㄢ事实上,它的存在(不可数;见2章)的内置`object.prototype`以及其他公用设施(`tostring()ㄢ`,`isprototypeof(..)ㄢ`等等)ㄢ

此外,`__proto__ㄢ`看起来像一个属性,但实际上它更合适的认为它作为一个吸气剂/二传手(见第3章)ㄢ

粗略地说,我们可以想象`__proto__ㄢ`实现(见对象属性定义的第3章): 

```js
Object.defineProperty( Object.prototype, "__proto__", {
	get: function() {
		return Object.getPrototypeOf( this );
	},
	set: function(o) {
		// setPrototypeOf(..) as of ES6
		Object.setPrototypeOf( this, o );
		return o;
	}
} );
```

因此,当我们访问(检索值)时`a.__proto__`就像是打电话`A. __proto__()`(调用吸气剂函数)ㄢ_那_函数调用`一`作为其`这`即使吸气剂函数存在于`object.prototype`对象(见第2章)`这`绑定规则),所以它就像是说`(一)getprototypeof对象ㄢ`ㄢ

`__proto__ㄢ`又是一个可设置的属性,就像使用ES6的`对象ㄢsetprototypeof(..)`前面所示ㄢ不过,一般来说你**不应改变`[原型]`现有对象的**ㄢ

有一些很复杂的,先进的技术,用深的一些框架,允许技巧如"子ℽ`阵列`但这在一般的编程实践中通常是不令人满意的,因为它通常导致_许多的_难以理解/维护代码ㄢ

**注: **截至6,的`班`关键词将允许一些接近"子ℽ内置的喜欢`阵列`ㄢ见附录A讨论`班`在6添加语法ㄢ

唯一的另一个狭窄的例外(如前面提到的)将设置`[原型]`默认函数的`原型ㄢ`对象引用其他对象(除了`object.prototype`)ㄢ这样可以避免用一个新的链接对象完全替换那个默认对象ㄢ否则,**最好对待对象ㄢ`[原型]`作为只读特性的链接**以便稍后阅读代码ㄢ

**注: **JavaScript社区非正式地创造了一个双词下划线,特别是领先的性质`__proto__`: "渣滓ℽㄢ所以,JavaScript中的"酷孩子ℽ一般都会发音ㄢ`__proto__`"在原ℽㄢ

## 对象链接

正如我们现在看到的,`[原型]`机制是存在于一个对象上的内部链接,它引用另一个对象ㄢ

当对第一个对象进行属性/方法引用时,这种链接主要是执行的,并且没有这样的属性/方法存在ㄢ在这种情况下,`[原型]`链接告诉引擎查找链接到对象的属性/方法ㄢ反过来,如果该对象不能完成查找,则`[原型]`被跟踪,等等ㄢ这一系列对象之间的链接形成Wㄢ

### `create()`ING的链接

我们已经彻底揭穿为什么JavaScript`[原型]`机制**不**喜欢_类_我们已经看到了它是如何创造的ㄢ**链接**在适当的对象之间ㄢ

这一点有什么意义?`[原型]`机制?为什么js开发人员在代码中花这么多精力(仿真类)来连接这些链接呢?

还记得我们在本章前面说过的话吗?`对象创建(..)`会成为英雄吗?现在,我们准备看看如何ㄢ

```js
var foo = {
	something: function() {
		console.log( "Tell me something good..." );
	}
};

var bar = Object.create( foo );

bar.something(); // Tell me something good...
```

`对象创建(..)`创建一个新对象(`酒吧`)链接到我们指定的对象(`Foo`),这给我们所有的权力(代表团)`[原型]`机制,但没有任何不必要的并发症`新的`充当类和构造函数调用的函数,使人困惑ㄢ`原型ㄢ`和`构造函数ㄢ`参考资料,或任何额外的东西ㄢ

**注: ** `对象创建(null)`创建具有空的对象(又名,`无效的`)`[原型]`链接,因此对象不能委托任何地方ㄢ因为这样的对象没有原型链,所以`运算符`操作符(前面解释过)没有什么要检查的,所以它总是返回ㄢ`假`ㄢ这些特别的空ℴ`[原型]`对象通常被称为"字典ℽ,因为它们通常只用于在属性中存储数据,主要是因为它们对任何已委派的属性/函数都不可能产生意外的影响ㄢ`[原型]`链,因此是纯粹的平面数据存储ㄢ

我们不_需要_创建两个对象之间有意义的关系的类ㄢ我们唯一应该做的事**真的很在乎**对象是否链接在一起进行授权,以及`对象创建(..)`给我们联系没有所有类缺陷ㄢ

#### `create()对象ㄢ`polyfilled

`对象创建(..)`加入ES5ㄢ你可能需要支持pre-es5环境(如旧版IE的),所以让我们简单的看一看**部分**polyfill为`对象创建(..)`这给了我们在旧的JS环境中所需要的能力: 

```js
if (!Object.create) {
	Object.create = function(o) {
		function F(){}
		F.prototype = o;
		return new F();
	};
}
```

这是通过使用polyfill扔掉`F`函数及其重写`原型ㄢ`属性指向要链接到的对象ㄢ然后我们使用`新的f()`构造以创建一个将按照我们指定的链接的新对象ㄢ

这种用法`对象创建(..)`是迄今为止最常用的用法,因为它是_可以是_polyfilledㄢ有一个额外的功能,标准的ES5内置`对象创建(..)`提供,这是**不polyfillable**对于pre-es5ㄢ因此,这种能力远远不常用ㄢ为了完整起见,让我们看看附加功能: 

```js
var anotherObject = {
	a: 2
};

var myObject = Object.create( anotherObject, {
	b: {
		enumerable: false,
		writable: true,
		configurable: false,
		value: 3
	},
	c: {
		enumerable: true,
		writable: false,
		configurable: false,
		value: 4
	}
} );

myObject.hasOwnProperty( "a" ); // false
myObject.hasOwnProperty( "b" ); // true
myObject.hasOwnProperty( "c" ); // true

myObject.a; // 2
myObject.b; // 3
myObject.c; // 4
```

第二个论点`对象创建(..)`通过声明每个新属性,指定要添加到新创建的对象的属性名ㄢ_属性描述符_(见第3章)ㄢ因为polyfilling属性描述符为pre-es5是不可能的,这个额外的功能`对象创建(..)`也不能polyfilledㄢ

绝大多数的使用`对象创建(..)`采用功能polyfill安全子集,因此大多数开发商都好用**部分polyfill**在pre-es5环境ㄢ

一些开发商采取更严格的观点,即没有功能应polyfilled除非能_地_polyfilledㄢ自`对象创建(..)`是其中的一个partial-polyfill'able事业,这个狭隘的角度说,如果你需要的功能`对象创建(..)`在pre-es5环境,而不是polyfilling,你应该使用一个自定义的效用,并远离使用的名称`object.create`完全ㄢ您可以定义自己的实用程序,比如: 

```js
function createAndLinkObject(o) {
	function F(){}
	F.prototype = o;
	return new F();
}

var anotherObject = {
	a: 2
};

var myObject = createAndLinkObject( anotherObject );

myObject.a; // 2
```

我不同意这种严格的意见ㄢ我完全赞同普遍偏polyfill的`对象创建(..)`如上图所示,并用它在你的代码甚至在pre-es5ㄢ我会让你自己做决定的ㄢ

### 联系Fallbacks?

认为对象之间的这些联系可能是诱人的ㄢ_主要地_为"丢失ℽ属性或方法提供一种回退ㄢ虽然这可能是一个观察到的结果,但我不认为它代表了正确的思考方式ㄢ`[原型]`ㄢ

考虑: 

```js
var anotherObject = {
	cool: function() {
		console.log( "cool!" );
	}
};

var myObject = Object.create( anotherObject );

myObject.cool(); // "cool!"
```

该代码将根据`[原型]`但是如果你那样写的话`另`充当后援**以防万一** `MyObject`无法处理某些开发人员可能试图调用的一些属性/方法,这可能是因为您的软件会更"神奇ℽ,更难理解和维护ㄢ

这并不是说不存在的情况下,回退是一个合适的设计模式,但并不常见或惯用的JS,所以如果你发现你这样做,你可能要退后一步,重新考虑是否真的合适ㄡ合理的设计ㄢ

**注: **在一个称为6,先进的功能`代理`介绍了可以提供某种"方法未发现ℽ的行为类型ㄢ`代理`超出了这本书的范围,但将在后面的一本书中详细介绍ㄢ_"你不知道JSℽ_系列ㄢ

**不要错过一个重要但微妙的观点ㄢ**

设计软件`cool() MyObjectㄢ`即使没有,也可以做那项工作`cool()`方法`MyObject`在API设计中引入一些"魔力ℽ,对于未来维护软件的开发人员来说,这可能是令人惊讶的ㄢ

然而,你可以用较少的"魔力ℽ来设计你的API,但仍然利用它的力量ㄢ`[原型]`联动ㄢ

```js
var anotherObject = {
	cool: function() {
		console.log( "cool!" );
	}
};

var myObject = Object.create( anotherObject );

myObject.doCool = function() {
	this.cool(); // internal delegation!
};

myObject.doCool(); // "cool!"
```

在这里,我们调用`docool() MyObjectㄢ`这是一种方法_真的存在_在`MyObject`使我们的API设计更加明确(少"神奇ℽ)ㄢ_内部_我们的实现如下**代理设计模式**(见第6章),利用`[原型]`代表团`另cool()ㄢ`ㄢ

换句话说,如果它是一个内部实现细节,而不是在API设计中清楚地暴露,那么委派将不会那么令人惊讶/迷惑ㄢ我们将阐述**代表团**下一章非常详细ㄢ

## 回顾(TL;DR)

当试图对不具有该属性的对象进行属性访问时,对象的内部`[原型]`链接定义了`[得到]`操作(见第3章)应着眼于下一步ㄢ这种从对象到对象的级联连接本质上定义了一个"原型链ℽ(有些类似于嵌套的范围链),用于遍历属性解析的对象ㄢ

所有正常对象都有内置的`object.prototype`作为原型链的顶部(如范围查找中的全局范围),如果在链中没有找到任何属性,则属性解析将停止ㄢ`tostring()`,`valueof()`以及其他一些常见的实用程序存在于此`object.prototype`对象,解释语言中所有对象如何能够访问它们ㄢ

获取两个相互关联的对象的最常用方法是`新的`在函数的四个步骤中(参见第2章),它创建一个链接到另一个对象的新对象ㄢ

新对象链接到的另一个对象恰好是任意命名的对象ㄢ`原型ㄢ`调用的函数的属性`新的`ㄢ函数调用`新的`通常被称为"建设者ℽ,尽管他们实际上没有实例化一个类_构造函数_用传统的面向类的语言ㄢ

虽然这些JavaScript机制似乎类似于传统面向类语言的"类实例化ℽ和"类继承ℽ,但关键区别在于JavaScript中没有复制ㄢ相反,对象最终通过内部连接ㄢ`[原型]`链ㄢ

因为各种各样的原因,不仅仅是术语的先例,"继承ℽ(与"原型继承ℽ)和所有其他的面向对象的条款就没有意义的时候,考虑到JavaScript_事实上_作品(不仅仅适用于我们的强迫心智模型)ㄢ

相反,"委托ℽ是一个更恰当的术语,因为这些关系不是ㄢ_副本_但代表团**链接**ㄢ
