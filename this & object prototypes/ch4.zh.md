
# 你不认识JS：_这_与对象的原型

# 第4章：混合（up）“类”对象

在我们探索前一章中的对象之后，我们很自然地将注意力转向“面向对象（OO）编程”和“类”。在检查“类”的机制：“实例化”、“继承”和“（相对）多态性”之前，我们首先将“类方向”作为一种设计模式来看待。

我们会看到，这些概念不是真的地图非常自然的JS对象机制，和长度（混入，等）很多JavaScript开发者去克服这样的挑战。

**注：**这一章花费了相当多的时间（上半场！）重“面向对象编程”理论。我们最终与这些思想具体的JavaScript代码，在下半场，当我们谈论“混入”。但是有很多概念和伪代码要经过第一步，所以不要迷失——坚持下去！

## 阶级理论

“类/继承”描述了某种形式的代码组织和体系结构——一种在软件中模拟真实世界问题域的方法。

面向对象或面向类编程强调数据本质上有关联的行为（当然，取决于数据的类型和性质）。这是对它的操作，所以正确的设计是打包（又名，封装）数据和行为在一起。这在正式的计算机科学中有时被称为“数据结构”。

例如，表示一个单词或短语的一系列字符通常称为“字符串”。字符是数据。但你几乎从不只是关心数据，你通常想_做事情_有了数据，那么可以应用的行为_到_这些数据（计算其长度、附加数据、搜索等）都被设计成`字符串`类。

任何给定的字符串都只是这个类的一个实例，这意味着它是对字符数据和我们可以在其上执行的功能的一种巧妙的打包。

类也意味着_分类_某一数据结构。我们这样做的方式是把任何给定的结构看作是一个更一般的基本定义的特定变体。

让我们通过看一个常见的例子来探索这个分类过程。一_汽车_可以说是一个具体的实现更一般的“类”的东西，叫做_车辆_。

我们用类定义软件中的这种关系，定义一个`车辆`类和`小型车`类。

定义`车辆`可能包括诸如推进（发动机等），携带人的能力等等，这些都是行为。我们所定义的`车辆`是所有（或大部分）不同类型的车辆（飞机、火车和汽车）通用的东西。

在我们的软件中，重新定义每一种不同类型车辆的“承载能力”的基本本质可能是没有意义的。相反，我们在一次定义该功能`车辆`然后，当我们定义`小型车`我们只是表示它“继承”（或“扩展”）基本定义`车辆`。定义`小型车`据说是专门的将军`车辆`定义。

而`车辆`和`小型车`通过方法共同定义行为，实例中的数据将是特定汽车的唯一VIN等。

**因此，类、继承和实例化应运而生。**

类的另一个关键概念是“多态性”，它描述了从父类中可以覆盖父类的一般行为以使其更详细的思想。事实上，相对多态性允许我们引用重写行为的基本行为。

类理论强烈建议父类和子类共享某些行为的相同方法名，以便子覆盖父（差异）。正如我们稍后将看到的，在JavaScript代码中这样做是为了挫败和代码脆性。

### “类”设计模式

你可能从来没有关于类为“设计模式”的思想，因为它是最常见的流行的“面向对象设计模式的探讨”、“迭代”、“观察”、“工厂”、“单身”等提出的这种方式，这几乎是一个面向对象的类的假设下我们所实施的所有水平力学（高层次）的设计模式，如面向对象是一个给定的基础_全部的_（适当）代码。

根据你在编程中的正规教育水平，你可能听说过“程序编程”，它是一种描述代码的方法，它只包含调用其他函数的过程（即函数），没有任何更高的抽象。你可能已经被告知，课程是_适当的_将程序式“意大利面条代码”转换成格式良好、组织严密的代码。

当然，如果你有“功能编程经验”（单子，等），你知道得很清楚，类是几种常见的设计模式。但对其他人来说，这可能是你第一次问自己。

有些语言（如java）不给你选择，所以不是很_可选择的_一切都是一个阶级。其他语言如C、C++、PHP给你程序和面向类的语法，它留下更多的开发者的选择方式或混合方式是合适的。

### javascript类

JavaScript在这方面下降在哪里？JS有_一些_类语法元素（如`新的`和`运算符`）很长一段时间，最近在6，一些内容，如`班`关键词（见附录A）。

但这实际上意味着JavaScript吗？_有_课吗？质朴：**不.**

因为类是一种设计模式，所以_可以_通过相当多的努力（我们将在本章的其余部分中看到），实现对许多经典类功能的近似。js试图满足非常普遍的_欲望_通过提供貌似类语法的类来设计类。

虽然我们可能有一个类似于类的语法，但JavaScript机制似乎在用_类设计模式_因为在幕后，你建立的机制运作截然不同。语法糖和（非常广泛使用的）JS“类库”可以很好地把这个事实隐藏起来，但迟早你会面对这样一个事实：_类_你在其他语言中不象你在JS中所用的“类”。

归根结底，类是软件设计中的可选模式，您可以选择使用JavaScript。由于许多开发人员对面向类的软件设计有很强的亲和力，我们将在本章的其余部分中讨论用js提供什么来维护类的错觉，以及我们所经历的痛苦点。

## 力学类

在许多面向类的语言中，“标准库”提供一个“堆栈”数据结构（推、POP等）作为`堆栈`类。这个类将有一组存储数据的内部变量，它将有一组由类提供的公共可访问的行为（“方法”），这使您的代码能够与（隐藏的）数据（添加和删除数据等）进行交互。

但在这种语言中，你并不是直接操作。`堆栈`（除非制作**静态**类成员引用，这超出了我们讨论的范围）。这个`堆栈`类只是对什么的抽象解释。_任何_“堆栈”应该这样做，但它本身不是。_一_“堆栈”。你必须**实例化**这个`堆栈`在拥有具体的数据结构之前_事情_反对。

### 建筑

传统的“阶级”和“实例”的隐喻来自建筑。

建筑师设计出建筑物的所有特征：有多宽、有多高、有多少窗户、在什么地方，哪一种材料用于墙壁和屋顶。在这一点上她并不在乎，_哪里_这座大楼将建成，她也不关心。_有多少_那座大楼的复制品将被建造。

她也不太关心这座建筑的内容——家具、墙纸、吊扇等等——只知道它们将包含什么样的结构。

她生产的建筑蓝图只是_计划_为建筑物。它们实际上并不是一座我们可以走进和坐下来的建筑物。我们需要一个建筑工人来做那项工作。一个建筑工人将采取这些计划，并按照他们，确切地说，因为他。_建立_建筑。在一个非常真实的意义上，他是_复制_从计划到有形建筑的预期特征。

一旦完成，该结构是蓝图蓝图的物理实例化，希望本质上是完美的。_复制_。然后建筑商可以搬到隔壁的露天场地，再做一遍，再创造一个。_复制_。

建筑与蓝印花布的关系是间接的。你可以检查一个蓝图来理解建筑物是如何构造的，对于建筑物本身的直接检查的任何部分都是不够的。但是，如果你想打开一扇门，你就必须去建筑本身——蓝图只有在一页上画出的线条。_代表_门应该在哪里。

班级是蓝色的。实际上_得到_我们可以与之交互的对象，我们必须从类中构建（又名“实例化”）某些东西。这种“构造”的最终结果是一个对象，通常称为“实例”，我们可以根据需要直接调用和访问任意公共数据属性的方法。

**这个对象是_复制_**在类所描述的所有特性中。

你可能不会想到走进一座建筑物，发现，挂在墙上，墙上挂着一张蓝图，用来规划这座建筑，尽管蓝色的照片可能在公共档案局存档。类似地，一般不使用对象实例直接访问和操作类，但通常至少可以确定。_这类_一个对象实例

考虑类与对象实例的直接关系更有用，而不是对象实例和它来自的类之间的任何间接关系。**通过复制操作将类实例化为对象窗体。**

<img src=“图。png”>

正如您所看到的，箭头从左向右移动，从上到下，这表示在概念上和物理上发生的复制操作。

### 构造函数

类的实例是由类的特殊方法构造的，通常与类的名称相同，称为_构造函数_。此方法的显式任务是初始化实例所需的任何信息（状态）。

例如，考虑这个松散的伪代码（发明的语法）类：

```js
class CoolGuy {
	specialTrick = nothing

	CoolGuy( trick ) {
		specialTrick = trick
	}

	showOff() {
		output( "Here's my trick: ", specialTrick )
	}
}
```

以_制作_一`coolguy`例如，我们将调用类构造函数：

```js
Joe = new CoolGuy( "jumping rope" )

Joe.showOff() // Here's my trick: jumping rope
```

请注意，`coolguy`类有构造函数`coolguy()`这就是我们所说的`新的coolguy（..）`。我们从构造函数中获得一个对象（我们的类的一个实例），我们可以调用这个方法。`showoff()`打印出那个特殊的`coolguy`特技。

_显然，跳绳使乔成为一个非常酷的家伙。_

类的构造函数_属于_对于类，几乎与类的名称相同。而且，构造函数几乎总是需要调用`新的`让语言引擎知道你想构建一个_新的_类的实例。

## 类的继承

在面向类的语言中，不仅可以定义一个可以实例化的类，还可以定义另一个类**继承**从头等舱。

第二类通常被称为“子类”，而第一类是“父类”。这些术语显然来自父母和孩子的隐喻，尽管这里的隐喻有点紧张，你不久就会看到。

当父母有亲生孩子时，父母的遗传特征被复制到孩子身上。显然，在大多数生物繁殖系统中，有两个父母在基因中共同贡献基因。但是，为了隐喻的目的，我们只假设一个父类。

一旦孩子存在，他或她与父母分开。孩子受父母遗传的影响很大，但独特而独特。如果一个孩子的头发是红色的，那并不意味着父母的头发。_是_或自动_成为_红。

同样的，一旦定义了子类，它就与父类分离并区别开来。子类包含父级行为的初始副本，但可以覆盖任何继承的行为，甚至定义新的行为。

记住我们谈论的是父母和孩子是很重要的。**类**那些不是物质的东西。这就是父母和孩子的隐喻有点混淆的原因，因为我们实际上应该说父类就像父母的DNA，而子类就像孩子的DNA。我们必须使一个人从每一组DNA中“出来”，以便有一个真正的人与他交谈。

让我们撇开生物学上的父母和孩子，通过一个稍微不同的镜头来看待遗产：不同类型的车辆。这是理解遗传的最标准的（通常是值得叹息的）隐喻之一。

让我们重访`车辆`和`小型车`本章早些时候的讨论。考虑这个松散的伪代码（发明的语法）用于继承类：

```js
class Vehicle {
	engines = 1

	ignition() {
		output( "Turning on my engine." )
	}

	drive() {
		ignition()
		output( "Steering and moving forward!" )
	}
}

class Car inherits Vehicle {
	wheels = 4

	drive() {
		inherited:drive()
		output( "Rolling on all ", wheels, " wheels!" )
	}
}

class SpeedBoat inherits Vehicle {
	engines = 2

	ignition() {
		output( "Turning on my ", engines, " engines." )
	}

	pilot() {
		inherited:drive()
		output( "Speeding through the water with ease!" )
	}
}
```

**注：**为了简洁明了，这些类的构造函数被省略了。

我们定义`车辆`假定发动机、点火方式和驱动方式。但你不会制造一个通用的“汽车”，所以在这一点上它实际上只是一个抽象概念。

然后我们定义了两种特定类型的车辆：`小型车`和`快艇`。它们各自继承了`车辆`但是他们对每种类型都有适当的特性。一辆车需要4个轮子，快艇需要2个引擎，这就意味着它需要格外注意打开两个引擎的点火。

### 多态性

`小型车`定义了自己的`drive()`方法，重写继承的同名名称的方法。`车辆`。但随后，`小型车`S`drive()`方法调用`继承：drive()`，这表明`小型车`可以引用预先重写的原始内容。`drive()`它继承了。`快艇`S`pilot()`方法还引用其继承的副本`drive()`。

这种技术称为“多态”或“虚拟多态”。更具体地说，我们现在称之为“相对多态性”。

多态性是一个比我们在这里耗尽的更广泛的主题，但是我们当前的“相对”语义指的是一个特定的方面：任何方法都可以在继承层次的更高层次上引用另一种方法（相同或不同的名称）。我们说“相对”是因为我们没有绝对定义我们想要访问哪一个继承级别（又名类），而是相对关系。

在许多语言中，关键字`超级的`用于代替本示例的`继承:`它依赖于“超级类”是当前类的父/祖先的思想。

多态性的另一个方面是，方法名称可以在继承链的不同级别上有多个定义，并且在解析调用哪些方法时自动地选择这些定义。

我们在上面的例子中看到了这两个行为的出现：`drive()`定义在两个`车辆`和`小型车`，和`ignition()`定义在两个`车辆`和`快艇`。

**注：**传统的面向类语言给你的另一件事是`超级的`是子类的构造函数引用其父类的构造函数的直接方式。这在很大程度上是正确的，因为使用真正的类，构造函数属于类。然而，在js中，它是相反的——考虑到属于构造函数的“类”实际上更为合适（`原型…`类型引用）。因为在js中，子和父之间的关系只存在于两者之间。`原型。`各自的构造函数的对象，构造函数本身并不直接相关，因此，有没有简单的方法来比较从另一个参考（见附录A 6`班`这解决了这个问题`超级的`）。

一个有趣的多态性暗示可以具体地看到`ignition()`。里面`pilot()`对（继承的）进行相对多态引用。`车辆`S版`drive()`。但是，`drive()`引用`ignition()`方法仅按名称（没有相对引用）。

哪个版本的`ignition()`语言引擎会使用吗？`车辆`还是那一个`快艇`？**它使用`快艇`版本`ignition()`。**如果你_是_实例化`车辆`类本身，然后调用它`drive()`语言引擎将只使用`车辆`S`ignition()`方法定义。

换句话说，方法的定义`ignition()`多晶型_（更改）取决于您引用的实例的一个类（继承级别）。_这似乎是过于深刻的学术细节。但是理解这些细节对于正确地对比JavaScript中相似的（但不同的）行为是必要的。

\[原型]`机制.`当类被继承时，有一种方法。

对于班级本身**（不是从它们创建的对象实例！）到**相当地_引用继承的类，这个相对引用通常被称为_超级的`。`记住这个数字：

&lt;img src=“图。png”>

注意两个实例化如何（

A1`，`A2`，`B1`，和`B2`）`和_继承（_酒吧`）箭头表示复制操作。`从概念上讲，它似乎是一个子类。

酒吧`可以在其父类中访问行为`Foo`使用相对多态引用（又名，`超级的`）。然而，实际上，子类仅从父类中得到继承行为的副本。如果孩子“重写”了它继承的方法，则实际维护了方法的原始版本和重写版本，这样它们都是可访问的。`不要让多态性使您认为子类与其父类相关联。而子类则从父类获取它需要的副本。

类继承意味着副本。**多重继承**

### 还记得我们先前关于父母、孩子和DNA的讨论吗？我们说这个比喻有点奇怪，因为从生物学上来说，大多数后代都来自双亲。如果一个类可以继承其他两个类，则它更适合父/子隐喻。

一些面向类的语言允许您指定多个“父类”来“继承”。多重继承意味着每个父类定义都复制到子类中。

从表面上看，这似乎是对类方向的强大补充，使我们能够一起编写更多的功能。然而，肯定会出现一些复杂的问题。如果两个父类都提供了一个名为

drive()`哪个版本会`drive()`参考在孩子决心吗？是否总是必须手动指定哪些父类`drive()`你的意思，从而失去一些多态继承的优雅？`还有另一种变体，就是所谓的“菱形问题”，它指的是子类“D”继承来自两个父类（“B”和“C”）的情况，而每一个类都继承了一个普通的“A”父类。如果“A”提供了一种方法

drive()`，和“B”和“C”重写（多态），方法，当`D`引用`drive()`它应该使用哪种版本？`B：drive()`或`C：drive()`）？`&lt;img src=“2。png”>

这些并发症比这一眼更为深刻。我们只在这里讨论它们，因此我们可以对比JavaScript机制的工作方式。

JavaScript更简单：它不提供“多继承”的本地机制。很多人看到这是一个

JavaScript更简单：它不提供“多继承”的本地机制。很多人看到这是一件好事，因为复杂的储蓄比弥补“减少”的功能更多。但这并不能阻止开发者以各种方式伪造它，我们将在下一步看到它。

## 混合

javascript的对象机制没有_自动_执行“继承”或“实例化”时的复制行为。显然，JavaScript中没有“类”来实例化，只有对象。并且对象不会被复制到其他对象，他们得到_联系在一起_（更多关于第5章的内容）。

由于其他语言中观察到的类行为意味着拷贝，所以我们来看看js开发人员是如何开发的。**伪造的**这个_丢失的_类在JavaScript中复制行为：混合。我们来看看两种类型的“混合”：**明确的**和**隐性的**。

### 显式混合

让我们再重温一下`车辆`和`小型车`以前的例子。因为JavaScript不会自动复制行为。`车辆`到`小型车`我们可以创建一个手动复制的实用程序。这样的实用程序通常被称为`扩展（…）`许多图书馆/框架，但我们将称之为`mixin（..）`这里举例说明。

```js
// vastly simplified `mixin(..)` example:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// only copy if not already present
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}

var Vehicle = {
	engines: 1,

	ignition: function() {
		console.log( "Turning on my engine." );
	},

	drive: function() {
		this.ignition();
		console.log( "Steering and moving forward!" );
	}
};

var Car = mixin( Vehicle, {
	wheels: 4,

	drive: function() {
		Vehicle.drive.call( this );
		console.log( "Rolling on all " + this.wheels + " wheels!" );
	}
} );
```

**注：**微妙但重要的是，我们不再处理类，因为JavaScript中没有类。`车辆`和`小型车`只是我们分别复制和复制的对象。

`小型车`现在有一个属性和函数的副本`车辆`。从技术上讲，函数实际上并不是复制的，而是_引用_对功能进行复制。所以，`小型车`现在有一个名为`点火`，这是对`ignition()`函数，以及一个名为`发动机`具有复制值`一`从`车辆`。

`小型车`已经_有一个_开车`属性（函数），使属性引用未被重写（参见`如果`声明`mixin（..）`以上）。`重新审视“多态”

#### 让我们检查一下这句话：

车辆。驱动。呼叫（此）`。这就是我所说的“显式伪多态”。回忆在我们以前的伪代码中，这一行是`继承：drive()`我们称之为“相对多态性”。`JavaScript没有（前6；见附件一）为相对多态性设施。所以，

因为**小型车`和`车辆`具有相同名称的函数：`drive()`为了区分一个或另一个调用，我们必须做一个绝对的（不是相对的）引用。我们显式指定`**车辆`对象的名称，并调用`drive()`它的功能。`但是如果我们说

drive()车辆。`，的`这`该函数调用的绑定将是`车辆`对象而不是`小型车`对象（参见第2章），这不是我们想要的。因此，我们使用`打电话（这个）`（第2章）以确保`drive()`在上下文中执行`小型车`对象。`注：

**如果函数名称标识符为**drive()车。`没有重叠（又名“阴影”）；见第5章）`drive()车辆。`我们不会一直在练习“方法多态”。因此，参考`drive()车辆。`将被复制`mixin（..）`调用，我们可以直接访问`这drive()。`。所选标识符重叠`阴影**是**为什么_我们必须使用更复杂的_明确的伪基因多态性_方法。_在面向类的语言中，它们具有相对多态性。

小型车`和`车辆`建立一次，在类定义的顶部，这使得只有一个地方保持这种关系。`但由于JavaScript的特殊性，显式伪多态（因为阴影！）创建脆性手动/显式链接

在每一个函数中，您需要这样一个（伪）多态引用**。这可以大大增加维护成本。此外，虽然显性伪多态可以模拟“多重继承”的行为，但它只会增加复杂性和脆性。**这种方法的结果通常更复杂，更难阅读，

和_难以维护的代码。_应尽可能避免显式伪多态。**因为成本在大多数方面都超过了利益。**混合的副本

#### 回忆

mixin（..）`上面的实用程序：`现在，让我们来看看如何

```js
// vastly simplified `mixin()` example:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// only copy if not already present
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}
```

mixin（..）`作品.遍历性质`sourceobj`（`车辆`在我们的示例中，如果该名称中没有匹配的属性，则`targetobj`（`小型车`在我们的示例中，它复制了一个副本。由于我们在初始对象存在之后复制，所以我们小心不要复制目标属性。`如果我们先复制，然后再指定

小型车`具体内容，我们可以取消这项支票。`targetobj`，但有点笨重，效率较低，所以一般不喜欢：`无论哪种方法，我们都明确地复制了不重叠的内容。

```js
// alternate mixin, less "safe" to overwrites
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		targetObj[key] = sourceObj[key];
	}

	return targetObj;
}

var Vehicle = {
	// ...
};

// first, create an empty object with
// Vehicle's stuff copied in
var Car = mixin( Vehicle, { } );

// now copy the intended contents into Car
mixin( {
	wheels: 4,

	drive: function() {
		// ...
	}
}, Car );
```

车辆`进入之内`小型车`。“混合”来自解释任务的一种替代方式：`小型车`有`车辆`的内容`混合**就像你把巧克力片拌进你最喜欢的曲奇饼里。**作为一个结果

由于复制操作，`小型车`将分开操作一些`车辆`。如果将属性添加到`小型车`它不会影响`车辆`反之亦然。

**注：**这里掠过一些细枝末节。即使复制后，两个对象仍然有一些微妙的方式相互影响，比如它们都共享对一个公共对象的引用（比如一个数组）。

因为这两个对象也共享对它们的公共函数的引用，这意味着**即使手动复制功能（又名，混入）从一个对象到另一个不_其实模仿_类面向语言中从类到实例的真正复制**。

JavaScript函数不能真正复制（以标准、可靠的方式），所以您最终使用的是**复制参考**对于相同的共享函数对象（函数是对象；参见第3章）。如果您修改了其中一个共享**函数对象**（像`ignition()`通过在它的顶部加上属性，例如`车辆`和`小型车`将通过共享引用“受影响”。

显式混合JavaScript中的精细机制。但它们看起来比实际的更强大。没有多少好处_事实上_从将属性从一个对象复制到另一个对象而派生的，**与只定义属性两次相反**每个对象上一次。鉴于我们刚才提到的函数对象引用的细微差别，这一点尤其正确。

如果显式地将两个或多个对象混合到目标对象中，则可以**部分模拟**“多重继承”的行为，但是如果从一个以上的源复制相同的方法或属性，则没有直接的方法来处理冲突。一些开发商/图书馆想出了“后期绑定”技术和其他异国情调的工作环境，但从根本上说，这些“招数”_通常_更多的努力（和较低的表现！）比还清。

注意只能使用显式的混合，它实际上有助于使代码的可读性，如果你发现它使代码很难跟踪避免模式，或者如果你发现它会造成不必要的或笨重的对象之间的依赖关系。

**如果它开始得到_更努力_正确使用混合比在你使用它们**，你应该停止使用混合。事实上，如果您必须使用复杂的库/实用程序来解决所有这些细节，这可能是一个信号，表明您正在以更难的方式处理它，也许是不必要的。在第6章中，我们将尝试提炼出一种更简单的方法来完成预期的结果而不必大惊小怪。

#### 寄生继承

在这个明确的混合模式的一种变化，即在某些方面和其他方面的显隐，被称为“寄生继承”，重点推广道格拉斯克罗克福德。

以下是它如何工作：

```js
// "Traditional JS Class" `Vehicle`
function Vehicle() {
	this.engines = 1;
}
Vehicle.prototype.ignition = function() {
	console.log( "Turning on my engine." );
};
Vehicle.prototype.drive = function() {
	this.ignition();
	console.log( "Steering and moving forward!" );
};

// "Parasitic Class" `Car`
function Car() {
	// first, `car` is a `Vehicle`
	var car = new Vehicle();

	// now, let's modify our `car` to specialize it
	car.wheels = 4;

	// save a privileged reference to `Vehicle::drive()`
	var vehDrive = car.drive;

	// override `Vehicle::drive()`
	car.drive = function() {
		vehDrive.call( this );
		console.log( "Rolling on all " + this.wheels + " wheels!" );
	};

	return car;
}

var myCar = new Car();

myCar.drive();
// Turning on my engine.
// Steering and moving forward!
// Rolling on all 4 wheels!
```

如您所见，我们最初从`车辆`“父类”（对象），然后混入我们的“子类”（对象）的定义（保留特权的父类引用需要），并把这个组合对象`汽车`作为我们的子实例。

**注：**我们打电话的时候`新的car()`创建一个新对象并由其引用`小型车`S`这`参考文献（见第2章）。但是因为我们不使用那个对象，而返回我们自己的对象`汽车`对象，最初创建的对象将被丢弃。所以，`car()`可以不用`新的`关键字，上面的功能将是相同的，但没有浪费的对象创建/垃圾收集。

### 隐式混合

隐式混合密切相关_明确的伪基因多态性_如前所述。因此，它们带有相同的警告和警告。

考虑这个代码：

```js
var Something = {
	cool: function() {
		this.greeting = "Hello World";
		this.count = this.count ? this.count + 1 : 1;
	}
};

Something.cool();
Something.greeting; // "Hello World"
Something.count; // 1

var Another = {
	cool: function() {
		// implicit mixin of `Something` to `Another`
		Something.cool.call( this );
	}
};

Another.cool();
Another.greeting; // "Hello World"
Another.count; // 1 (not shared state with `Something`)
```

随着`Something.cool.call( this )`这可能发生在“构造函数”调用（最常见的）或方法调用中（此处显示），我们本质上是“借用”函数。`cool()东西。`并称之为`另一个`（通过其`这`绑定；参见第2章）`什么东西`。最终的结果是`cool()东西。`使适用于`另一个`对象而不是`什么东西`对象。

所以，有人说我们“混在一起”`什么东西`s行为与（或进入）`另一个`。

虽然这种技术似乎有助于`这`重新绑定的功能，它是易碎的`很酷的东西。`调用，它不能成为一个相对的（因此更灵活的）引用，您应该**谨慎小心**。一般，**尽可能避免这种结构。**保持更清洁和更易于维护的代码。

## 回顾（TL；DR）

类是一种设计模式。许多语言提供语法，使自然面向类的软件设计成为可能。js也有类似的语法，但它的行为**非常不同**从你习惯于其他语言的课程。

**类等于副本。**

当实例化传统类时，会发生一个从类到实例的行为副本。当继承类时，也会发生从父到子的行为副本。

多态性（具有不同的功能）

JavaScript**不自动**在对象之间创建副本（如类所暗示）。

混合模式（显性和隐性）是经常使用的_某种程度上_模拟类复制行为，但这通常会导致像显式伪多态这样的丑陋和脆弱的语法（`otherobj。methodename。电话（这个…）`这常常会导致难于理解和维护代码。

明确的混合也不完全一样的类_复制_因为对象（和函数！）只有共享引用复制，而不是对象/函数本身复制。没有注意到这样的细微差别是各种问题的来源。

一般来说，在JS中伪造类通常比解决目前的问题给未来的编码带来更多的地雷。_真实的_问题.
