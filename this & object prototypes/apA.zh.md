
# 你不认识JS: _这_与对象的原型

# 附录一: ES6`班`

如果这本书的下半部分(第4-6章)中有任何外卖信息,那么这些类是代码的可选设计模式(不是必需的),而且在一个`[原型]`类似JavaScript的语言. 

这种尴尬_不_关于语法,尽管这是其中的一大部分. 4章和5检查不少句法丑,从冗长的`原型. `引用复杂的代码,以_明确的伪基因多态性_(参见第4章)当您在链的不同级别给方法相同的名称时,尝试从一个低级方法到一个更高级别的方法实现多态引用. `构造函数. `被错误地解释为"被构造",但是对这个定义不可靠是另一个句法上的丑陋. 

但课堂设计的问题更为严重. 第4章指出传统的面向类语言中的类实际上产生了一个_复制_从父到子到实例的动作,而在`[原型]`行动是**不**一个副本,而恰恰相反ℴℴ一个委托链接. 

相比于简单的oloo风格的代码和行为代表团(见6章),拥抱`[原型]`而不是隐藏它,类脱颖而出,作为一个疼痛拇指在JS. 

## `班`

但我们_不要_需要重新辩论那个案件. 我再提那些问题简单地只让你记住这新鲜的现在,我们将注意力转向ES6`班`机制.我们将在这里演示它是如何工作的,看看是否`班`有什么实质性的事情可以解决这些"类"问题吗?. 

让我们重访`小装置`/`按钮`第6章的例子: 

```js
class Widget {
	constructor(width,height) {
		this.width = width ƜƜ 50;
		this.height = height ƜƜ 50;
		this.$elem = null;
	}
	render($where){
		if (this.$elem) {
			this.$elem.css( {
				width: this.width + "px",
				height: this.height + "px"
			} ).appendTo( $where );
		}
	}
}

class Button extends Widget {
	constructor(width,height,label) {
		super( width, height );
		this.label = label ƜƜ "Default";
		this.$elem = $( "<button>" ).text( this.label );
	}
	render($where) {
		super.render( $where );
		this.$elem.click( this.onClick.bind( this ) );
	}
	onClick(evt) {
		console.log( "Button '" + this.label + "' clicked!" );
	}
}
```

除此之外的语法_看_好的,什么问题6解决?

1.  没有更多的(嗯,有点,见下文!)引用`原型. `简洁的代码. 
2.  `按钮`直接声明为"继承"(又名`延伸`)`小装置`而不是需要使用`对象创建(..)`更换`原型. `链接的对象,或必须设置的对象`__proto__. `或`对象. setprototypeof(..)`. 
3.  `超级(ⅆ)`现在给了我们很大的帮助. **相关的多态性**能力,这样链上任何一级的任何方法都可以将链上的一级相对地引用到同一名称的方法中. 这包括解决注4章关于不属于自己的类的构造函数的怪异,所以没有关系ℴℴ`super()`在构造函数中工作,正如您所期望的那样. 
4.  `班`文字语法没有提供指定属性(方法). 对某些人来说,这似乎是有限的,但大多数情况下,一个属性(状态)存在于其他地方,但最终的链"实例",这通常是错误的和令人惊讶的(因为它在所有"实例"中隐含地"共享"). 所以,一个_能够_说`班`语法保护你不犯错误. 
5.  `延伸`允许扩展甚至内置对象(子)类型,比如`阵列`或`正则表达式`以非常自然的方式. 这样做不`类..延伸`长期以来,这是一项极其复杂和令人沮丧的任务,只有最熟练的框架作者才能够精确地处理. 现在,这将是相当微不足道的!

平心而论,这些都是解决许多最明显的(语法)问题和人们对经典原型代码的惊讶的一些实质性的解决方案. 

## `班`陷阱

不是所有的泡泡糖和玫瑰花,虽然. 在JS中使用"类"作为设计模式仍然存在一些深层次的问题. 

首先,该`班`语法可以让你一个新的"类"的机制存在于JS为ES6. **不是这样的. ** `班`主要是句法上的糖. `[原型]`(代表团!)机制.

这意味着`班`实际上并不是按照传统的面向类语言在声明时静态地定义定义. 如果在父类上更改/替换方法(有意或无意),子类和/或实例仍然受影响,因为它们在声明时没有得到副本,它们仍然使用基于`[原型]`: 

```js
class C {
	constructor() {
		this.num = Math.random();
	}
	rand() {
		console.log( "Random: " + this.num );
	}
}

var c1 = new C();
c1.rand(); // "Random: 0.4324299..."

C.prototype.rand = function() {
	console.log( "Random: " + Math.round( this.num * 1000 ));
};

var c2 = new C();
c2.rand(); // "Random: 867"

c1.rand(); // "Random: 432" -- oops!!!
```

这似乎是合理的行为. _如果你已经知道_关于事物的委托性质,而不是期望_副本_从"真正的阶级". 所以问自己的问题是,你为什么选择?`班`与类有根本区别的语法吗?

不6`班`语法**只是让它更难**查看和理解传统类和委托对象之间的区别吗?

`班`语法_不_提供一种声明类成员属性的方法(仅使用方法). 所以,如果你需要这样做来跟踪实例之间的共享状态,那么你最终回到了丑陋的状态. `原型. `语法,像这样: 

```js
class C {
	constructor() {
		// make sure to modify the shared state,
		// not set a shadowed property on the
		// instances!
		C.prototype.count++;

		// here, `this.count` works as expected
		// via delegation
		console.log( "Hello: " + this.count );
	}
}

// add a property for shared state directly to
// prototype object
C.prototype.count = 0;

var c1 = new C();
// Hello: 1

var c2 = new C();
// Hello: 2

c1.count === 2; // true
c1.count === c2.count; // true
```

这里最大的问题是它背叛了`班`通过暴露(泄漏)语法`原型. `作为实现细节. 

但是,我们也仍然有惊喜了,`这个数+ +`将隐式创建一个单独的阴影. `数. `财产上`C1`和`C2`对象,而不是更新共享状态. `班`对这个问题我们没有任何安慰,除了(可能)缺乏句法支持意味着你不应该那样做. _完全_. 

此外,意外阴影仍然是一种危险: 

```js
class C {
	constructor(id) {
		// oops, gotcha, we're shadowing `id()` method
		// with a property value on the instance
		this.id = id;
	}
	id() {
		console.log( "Id: " + this.id );
	}
}

var c1 = new C( "c1" );
c1.id(); // TypeError -- `c1.id` is now the string "c1"
```

也有一些微妙微妙的问题与如何`超级的`作品.你可以假设`超级的`将以类似的方式绑定到`这`得到绑定(参见第2章),这是`超级的`将始终绑定到高于当前方法中位置的任何一个级别. `[原型]`链. 

但是,出于性能原因(`这`绑定已经很昂贵了),`超级的`不动态绑定. 作为声明时间,它是静态的. 没什么大不了的,对吧?

呃ⅆ也许,也许不是. 如果你像大多数JS开发者,开始分配功能在不同的对象(来自`班`定义),以各种不同的方式,您可能不会非常清楚,在所有这些情况下,`超级的`覆盖之下的机制每次都必须重新绑定. 

根据您对这些赋值的语法方法,可能有很多情况下`超级的`不能正确绑定(至少,不是你怀疑),所以你可能会(在写这篇文章的时候,讨论的话题是持续TC39)有手动绑定`超级的`具有`方法(..)`(有点像你必须做的`绑定(ⅆ)`对于`这`ℴℴ见第2章). 

您习惯于将方法分配给不同的对象. _自动_充分利用`这`通过_隐式绑定_规则(见第2章). 但使用方法可能也不一样. `超级的`. 

考虑什么`超级的`应该在这里做(反对)`D`和`E`): 

```js
class P {
	foo() { console.log( "P.foo" ); }
}

class C extends P {
	foo() {
		super();
	}
}

var c1 = new C();
c1.foo(); // "P.foo"

var D = {
	foo: function() { console.log( "D.foo" ); }
};

var E = {
	foo: C.prototype.foo
};

// Link E to D for delegation
Object.setPrototypeOf( E, D );

E.foo(); // "P.foo"
```

如果你在想(相当合理)!那个`超级的`将在调用时间动态绑定,您可能会期望`super()`会自动识别`E`代表`D`,所以`E. foo()`使用`super()`应该打个电话`D. foo()`. 

**不是这样的. **出于绩效实用主义的理由,`超级的`是不是_后期绑定_(又名动态绑定)`这`是.相反,它是在调用时间从`[ ] [ ] [ homeobject [原型] ]. `,在那里`homeobject [ [ ] ]`在创建时静态绑定. 

在这种特殊情况下,`super()`仍在解决`foo() P.`,因为方法`homeobject [ [ ] ]`仍然是`C`和`C. [原型]`是`P`. 

将有_可能_可手动解决这些问题的方法. 使用`方法(..)`绑定/绑定方法的`homeobject [ [ ] ]`(连同设置`[原型]`那个物体!)似乎在这种情况下起作用: 

```js
var D = {
	foo: function() { console.log( "D.foo" ); }
};

// Link E to D for delegation
var E = Object.create( D );

// manually bind `foo`s `[[HomeObject]]` as
// `E`, and `E.[[Prototype]]` is `D`, so thus
// `super()` is `D.foo()`
E.foo = C.prototype.foo.toMethod( E, "foo" );

E.foo(); // "D.foo"
```

**注: ** `方法(..)`克隆方法,并采取`homeobject`作为第一个参数(这就是我们通过的原因). `E`),第二个参数(可选)设置一个`名称`对于新方法(保持在"富"). 

这还有待观察是否有其他角情况下的陷阱,会遇到超出本方案开发. 无论如何,你必须要勤奋,并且要注意引擎在哪个位置自动计算出来. `超级的`对你来说,哪些地方你必须手动照顾它. **啊!**

# 静态>动态?

但最大的问题是关于ES6`班`是,所有这些各种各样的陷阱的意思`班`很可能你进入一个语法,这似乎意味着(像传统的类),当你声明一个`班`,它是一个静态定义的(未来实例化)的东西. 你完全忽略了这个事实. `C`是一个对象,一个具体的东西,你可以直接与它交互. 

在传统的面向类的语言中,您以后不会调整类的定义,因此类设计模式不建议这样的功能. 但**最强大的部件之一**js是它吗?_是_动态的,任何对象的定义是(除非你使它不可变)是易变的. _事情_. 

`班`似乎意味着你不应该做这样的事情,迫使你的丑陋`原型. `这样做的语法,或者强迫你思考`超级的`等问题,提供了_很小_支持这种活力所带来的任何陷阱. 

换句话说,就好像`班`告诉你: "动态太难了,所以这可能不是个好主意. ". 这里有一个静态语法,所以要静态地编码你的东西. 

对JavaScript的评论真可悲: **动态太难了,让我们假装(但实际上不是)!静止的**. 

这就是为什么ES6`班`是伪装成句法头痛一个很好的解决方案,但它实际上浑水进一步使事情变得更糟的JS和简明清晰的认识. 

**注: **如果您使用`绑定(ⅆ)`效用做出硬约束函数(见2章),该函数创建不生子类有6`延伸`像正常函数一样. 

## 回顾(TL;DR)

`班`假装解决问题做了很好的工作**它隐藏了许多问题,并引入了其他微妙但危险的问题. **. 

`班`促成了JavaScript近20年来一直困扰语言的"阶级"的不断混乱. 在某些方面,它问的问题比回答的问题多,它感觉总体上像一种非常不自然的适合于优雅简洁的`[原型]`机制.

底线: 如果6`班`使得更难有力的杠杆作用. `[原型]`并隐藏js对象机制的最重要的特性ℴℴ**Live代表团在对象之间链接. **-难道我们不应该看到吗?`班`为创造更多的麻烦,就把它反模式?

我真的不能回答你这个问题. 但我希望这本书在更深的层次上对这个问题进行了全面的探索,并给了你所需的信息. _自己回答_. 
