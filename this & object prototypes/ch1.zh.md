
# 你不认识JS: _这_与对象的原型

# 1章: `这`还是那个?

JavaScript中最混乱的机制之一是`这`关键词ㄢ这是一个特殊的标识符,关键字,自动在每个函数的作用域中定义的,但究竟什么是困扰甚至经验丰富的JavaScript开发者ㄢ

> 任何足够_先进的_技术与魔法是分不开的ㄢℴℴArthur C. Clarke

JavaScript的`这`机制实际上不是_那个_先进的,但开发人员经常通过插入"复杂ℽ或"混乱ℽ来解释他们自己的报价,毫无疑问,这是毫无疑问的,`这`似乎很神奇_你的_混乱ㄢ

**注: **"这个ℽ这个词在一般语篇中是一个非常常见的代名词ㄢ因此,要确定我们是否使用"这个ℽ作代词或使用它来引用实际的关键字标识符,这是非常困难的,尤其是口头上的ㄢ为了清晰起见,我会一直使用`这`要引用特殊关键字,以及"此ℽ或_这_否则ㄢ

## 为什么`这`?

如果`这`机制如此混乱,即使是经验丰富的JavaScript开发人员,也可能会疑惑为什么它甚至有用呢?它比它的价值更麻烦吗?在我们跳进_怎样_我们应该检查一下_为什么_ㄢ

让我们来说明一下动机和效用ㄢ`这`: 

```js
function identify() {
	return this.name.toUpperCase();
}

function speak() {
	var greeting = "Hello, I'm " + identify.call( this );
	console.log( greeting );
}

var me = {
	name: "Kyle"
};

var you = {
	name: "Reader"
};

identify.call( me ); // KYLE
identify.call( you ); // READER

speak.call( me ); // Hello, I'm KYLE
speak.call( you ); // Hello, I'm READER
```

如果_怎样_这个片段迷惑了你,别担心!我们很快就会明白的ㄢ把这些问题简单地放在一边,这样我们就可以了解_为什么_更清楚ㄢ

此代码段允许`identify()`和`speak()`重新使用的函数_语境_(`我`和`你`对象,而不是为每个对象需要一个单独的函数版本ㄢ

而不是依靠`这`您可以显式地将上下文对象传递给两者ㄢ`identify()`和`speak()`ㄢ

```js
function identify(context) {
	return context.name.toUpperCase();
}

function speak(context) {
	var greeting = "Hello, I'm " + identify( context );
	console.log( greeting );
}

identify( you ); // READER
speak( me ); // Hello, I'm KYLE
```

然而,这`这`机制提供了一种更优雅的方式,隐式地"传递ℽ对象引用,从而实现更干净的API设计和更容易重用ㄢ

更复杂的使用模式,更清楚你会发现通过上下文作为一个明确的参数往往比通过一个`这`语境ㄢ当我们探讨的对象和原型,你将看到一系列的函数能够自动引用适当的上下文帮助ㄢ

## 困惑

我们将很快开始解释`这` _事实上_工作,但首先我们必须消除一些误解ㄢ_不_其实工作ㄢ

当开发人员试图从字面上考虑它时,这个"名称ℽ会造成混乱ㄢ通常有两种含义,但都是不正确的ㄢ

### 本身

第一个常见的诱惑是假设ㄢ`这`指的是功能本身ㄢ至少,这是一个合理的语法推断ㄢ

为什么要从内部引用函数?最常见的原因可能是递归的(从其内部调用一个函数)或一个事件处理程序,可以打开自己当它第一次被调用ㄢ

新开发的JS机制经常认为引用函数是一个对象(JavaScript中的所有函数都是对象)!让你的店_状态_函数调用中的值(属性值)ㄢ虽然这当然是可能的,并有一些有限的用途,本书的其余部分将阐述许多其他模式ㄢ_更好的_除函数对象外存储状态的位置ㄢ

但就一会儿,我们将探索这种模式,来说明`这`不要让函数像我们假设的那样获得对自身的引用ㄢ

考虑下面的代码,我们试图跟踪函数的多少次(`Foo`被称为: 

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 0 -- WTF?
```

`foo.count`是_仍然_ `零`即使四`console.log`陈述清楚地表明`富(ⅆ)`事实上被称为四次ㄢ挫折源于_太直白_解释什么`这`(在`这个数+ +`)手段ㄢ

当代码执行时`foo.count = 0`事实上,它添加了一个属性ㄢ`计数`对函数对象`Foo`ㄢ但对于`this.count`函数内部引用,`这`实际上并不是指向_完全_这个函数的对象,所以即使物业的名称是相同的,根对象不同,和随之而来的困惑ㄢ

**注: **一个负责任的开发商_应该_请在这一点上,"如果我是递增`计数`财产,但它不是我所期望的,哪一个`计数` _是_我快吗?ℽ事实上,如果她深入挖掘,她会发现她无意中创造了一个全局变量ㄢ`计数`(见第2章)_怎样_那件事发生了!)它现在有价值`南`ㄢ当然,一旦她发现了这个奇特的结果,她就有了另外一系列的问题: "它是如何全球性的,为什么它会结束?ℽ`南`而不是一些适当的计数值?ℽ(见第2章)ㄢ

而不是停留在这一点,挖掘为什么`这`参考似乎不象_预期_为了回答那些棘手但重要的问题,许多开发人员干脆完全回避这个问题,然后求助于其他解决方案ㄢ`计数`财产: 

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	data.count++;
}

var data = {
	count: 0
};

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( data.count ); // 4
```

虽然这种方法确实"解决了ℽ这个问题,但不幸的是它忽略了真正的问题ℴℴ缺乏理解ㄢ`这`方法和方法是如何工作的,而回到一个更熟悉的机制的舒适区: 词法范围ㄢ

**注: **词法范围是一个很好的和有用的机制;我不是贬低它的使用,以任何方式(见_"范围和闭包ℽ_这本书系列的标题)ㄢ但不断_猜测_如何使用`这`,通常是_错误的_,这不是撤退到词汇范围而不学习的好理由ㄢ_为什么_ `这`躲避你ㄢ

从内部引用函数对象,`这`本身通常是不够的ㄢ通常需要通过指向它的词法标识符(变量)来引用函数对象ㄢ

考虑这两个函数: 

```js
function foo() {
	foo.count = 4; // `foo` refers to itself
}

setTimeout( function(){
	// anonymous function (no name), cannot
	// refer to itself
}, 10 );
```

在第一个函数中,称为"命名函数ℽ,`Foo`是一个引用,可以从内部引用函数ㄢ

但是在第二个例子中,函数回调传递给`setTimeout(..)`没有名称标识符(称为"匿名函数ℽ),因此没有适当的方法引用函数对象本身ㄢ

**注: **老学校现在废弃,皱眉头`arguments.callee`函数中的引用_也_指向当前执行函数的函数对象ㄢ此引用通常是从内部访问匿名函数对象的唯一方法ㄢ然而,最好的方法是完全避免使用匿名函数,至少对于那些需要自我引用的函数,而使用命名函数(表达式)ㄢ`arguments.callee`是过时的和不应该使用ㄢ

因此,我们的运行示例的另一个解决方案是使用`Foo`标识符在每个位置作为一个函数对象引用,而不是使用`这`总之,哪个_作品_: 

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	foo.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 4
```

然而,这种方法类似于侧面步骤ㄢ_实际的_理解`这`和完全依赖变量的词法作用域`Foo`ㄢ

另一个接近这个问题的方法是强制ㄢ`这`事实上指向`Foo`函数对象: 

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	// Note: `this` IS actually `foo` now, based on
	// how `foo` is called (see below)
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		// using `call(..)`, we ensure the `this`
		// points at the function object (`foo`) itself
		foo.call( foo, i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 4
```

**而不是回避`这`我们拥抱它ㄢ**我们稍微解释一下ㄢ_怎样_这样的技术工作得更彻底,所以如果你还有些困惑的话就别担心!

### 它的范围

下一个最常见的误解`这`它是指函数的作用域ㄢ这是一个棘手的问题,因为从某种意义上讲,有些道理,但从另一个意义上说,它是相当误导的ㄢ

澄清,`这`不以任何方式引用函数的**词法范围**ㄢ的确,内部范围类似于具有每个可用标识符的属性的对象ㄢ但是JavaScript代码不能访问范围"对象ℽㄢ这是一个内在的部分ㄢ_发动机_的实现ㄢ

考虑尝试(失败)的代码ㄢ跨越边界和使用`这`隐式地引用函数的词法范围: 

```js
function foo() {
	var a = 2;
	this.bar();
}

function bar() {
	console.log( this.a );
}

foo(); //undefined
```

这个片段中不止一个错误ㄢ虽然看起来有些做作,但您所看到的代码是在公共社区帮助论坛中交换的实际真实代码的升华ㄢ这是一个很好的例子(如果不是悲伤的)ㄢ`这`假设可以ㄢ

首先,试图引用`bar()`函数通过`这bar()ㄢ`ㄢ几乎可以肯定的是_意外_它可以工作,但我们将解释_怎样_不久ㄢ最自然的调用方式`bar()`本来是要省略领导的`这ㄢ`只需对标识符进行词汇引用ㄢ

然而,编写此类代码的开发人员正试图使用ㄢ`这`在词法范围之间创建一个桥梁`foo()`和`bar()`,所以`bar()`访问变量`一`在内部范围内`foo()`ㄢ**没有这样的桥是可能的ㄢ**你不能使用`这`在词汇范围内查找某物的引用ㄢ这是不可能的ㄢ

每当你觉得自己试图混合词汇范围时`这`提醒自己: _没有桥_ㄢ

## 什么`这`?

撇开各种不正确的假设,现在让我们把注意力转向`这`机制确实有效ㄢ

我们早些时候说过`这`不是作者绑定时间,而是运行时绑定ㄢ它是基于函数调用的条件的上下文相关的ㄢ`这`绑定与声明函数的位置无关,但与调用函数的方式有关ㄢ

当调用一个函数时,创建一个激活记录,也就是所谓的执行上下文ㄢ此记录包含有关从调用堆栈调用函数的信息,_怎样_函数被调用,传递了什么参数,这个记录的属性之一是`这`用于该函数执行期间的引用ㄢ

在下一章中,我们将学习查找函数的**打电话给网站**确定其执行将如何绑定ㄢ`这`ㄢ

## 回顾(TL;DR)

`TH`对于JavaScript开发人员来说,绑定是混乱的经常来源,他们不花时间去了解机制实际上是如何工作的ㄢ猜测,试验和错误,盲目副本正贴从堆栈溢出的答案不是杠杆的有效或适当的方式_这_重要的`这`机制.

学习`这`你首先要学什么`这`是_不_尽管有任何可能导致你走上这些道路的假设或误解ㄢ`这`既不是对函数本身的引用,也不是对函数的引用ㄢ_词汇_范围ㄢ

`这`实际上是在函数被调用时产生的绑定,以及_什么_它的引用完全由调用函数的调用站点决定ㄢ
