
# 你不认识JS：_这_与对象的原型

# 1章：`这`还是那个？

JavaScript中最混乱的机制之一是`这`关键词。这是一个特殊的标识符，关键字，自动在每个函数的作用域中定义的，但究竟什么是困扰甚至经验丰富的JavaScript开发者。

> 任何足够_先进的_技术与魔法是分不开的。——Arthur C. Clarke

JavaScript的`这`机制实际上不是_那个_先进的，但开发人员经常通过插入“复杂”或“混乱”来解释他们自己的报价，毫无疑问，这是毫无疑问的，`这`似乎很神奇_你的_混乱。

**注：**“这个”这个词在一般语篇中是一个非常常见的代名词。因此，要确定我们是否使用“这个”作代词或使用它来引用实际的关键字标识符，这是非常困难的，尤其是口头上的。为了清晰起见，我会一直使用`这`要引用特殊关键字，以及“此”或_这_否则。

## 为什么`这`？

如果`这`机制如此混乱，即使是经验丰富的JavaScript开发人员，也可能会疑惑为什么它甚至有用呢？它比它的价值更麻烦吗？在我们跳进_怎样_我们应该检查一下_为什么_。

让我们来说明一下动机和效用。`这`：

```js
function identify() {
	return this.name.toUpperCase();
}

function speak() {
	var greeting = "Hello, I'm " + identify.call( this );
	console.log( greeting );
}

var me = {
	name: "Kyle"
};

var you = {
	name: "Reader"
};

identify.call( me ); // KYLE
identify.call( you ); // READER

speak.call( me ); // Hello, I'm KYLE
speak.call( you ); // Hello, I'm READER
```

如果_怎样_这个片段迷惑了你，别担心！我们很快就会明白的。把这些问题简单地放在一边，这样我们就可以了解_为什么_更清楚。

此代码段允许`identify()`和`speak()`重新使用的函数_语境_（`我`和`你`对象，而不是为每个对象需要一个单独的函数版本。

而不是依靠`这`您可以显式地将上下文对象传递给两者。`identify()`和`speak()`。

```js
function identify(context) {
	return context.name.toUpperCase();
}

function speak(context) {
	var greeting = "Hello, I'm " + identify( context );
	console.log( greeting );
}

identify( you ); // READER
speak( me ); // Hello, I'm KYLE
```

然而，这`这`机制提供了一种更优雅的方式，隐式地“传递”对象引用，从而实现更干净的API设计和更容易重用。

更复杂的使用模式，更清楚你会发现通过上下文作为一个明确的参数往往比通过一个`这`语境。当我们探讨的对象和原型，你将看到一系列的函数能够自动引用适当的上下文帮助。

## 困惑

我们将很快开始解释`这`事实上_工作，但首先我们必须消除一些误解。_不_其实工作。_当开发人员试图从字面上考虑它时，这个“名称”会造成混乱。通常有两种含义，但都是不正确的。

本身

### 第一个常见的诱惑是假设。

这`指的是功能本身。至少，这是一个合理的语法推断。`为什么要从内部引用函数？最常见的原因可能是递归的（从其内部调用一个函数）或一个事件处理程序，可以打开自己当它第一次被调用。

新开发的JS机制经常认为引用函数是一个对象（JavaScript中的所有函数都是对象）！让你的店

状态_函数调用中的值（属性值）。虽然这当然是可能的，并有一些有限的用途，本书的其余部分将阐述许多其他模式。_更好的_除函数对象外存储状态的位置。_但就一会儿，我们将探索这种模式，来说明

这`不要让函数像我们假设的那样获得对自身的引用。`考虑下面的代码，我们试图跟踪函数的多少次（

Foo`被称为：`foo.count

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 0 -- WTF?
```

`是`仍然_零_即使四`console.log`陈述清楚地表明`富（…）`事实上被称为四次。挫折源于`太直白`解释什么_这_（在`这个数+ +`）手段。`当代码执行时`foo.count = 0

事实上，它添加了一个属性。`计数`对函数对象`Foo`。但对于`this.count`函数内部引用，`这`实际上并不是指向`完全`这个函数的对象，所以即使物业的名称是相同的，根对象不同，和随之而来的困惑。_注：_一个负责任的开发商

**应该**请在这一点上，“如果我是递增_计数_财产，但它不是我所期望的，哪一个`计数`是`我快吗？”事实上，如果她深入挖掘，她会发现她无意中创造了一个全局变量。`计数_（见第2章）_怎样`那件事发生了！）它现在有价值`南_。当然，一旦她发现了这个奇特的结果，她就有了另外一系列的问题：“它是如何全球性的，为什么它会结束？”_南`而不是一些适当的计数值？”（见第2章）。`而不是停留在这一点，挖掘为什么`这`参考似乎不象

预期`为了回答那些棘手但重要的问题，许多开发人员干脆干脆回避这个问题，然后求助于其他人。`参考似乎不象_预期_为了回答那些棘手但重要的问题，许多开发人员干脆完全回避这个问题，然后求助于其他解决方案，例如创建另一个对象来保存`计数`财产：

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	data.count++;
}

var data = {
	count: 0
};

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( data.count ); // 4
```

虽然这种方法确实“解决了”这个问题，但不幸的是它忽略了真正的问题——缺乏理解。`这`方法和方法是如何工作的，而回到一个更熟悉的机制的舒适区：词法范围。

**注：**词法范围是一个很好的和有用的机制；我不是贬低它的使用，以任何方式（见_“范围和闭包”_这本书系列的标题）。但不断_猜测_如何使用`这`，通常是_错误的_，这不是撤退到词汇范围而不学习的好理由。_为什么_这`躲避你。`从内部引用函数对象，

这`本身通常是不够的。通常需要通过指向它的词法标识符（变量）来引用函数对象。`考虑这两个函数：

在第一个函数中，称为“命名函数”，

```js
function foo() {
	foo.count = 4; // `foo` refers to itself
}

setTimeout( function(){
	// anonymous function (no name), cannot
	// refer to itself
}, 10 );
```

Foo`是一个引用，可以从内部引用函数。`但是在第二个例子中，函数回调传递给

setTimeout（..）`没有名称标识符（称为“匿名函数”），因此没有适当的方法引用函数对象本身。`注：

**老学校现在废弃，皱眉头**arguments.callee`函数中的引用`也_指向当前执行函数的函数对象。此引用通常是从内部访问匿名函数对象的唯一方法。然而，最好的方法是完全避免使用匿名函数，至少对于那些需要自我引用的函数，而使用命名函数（表达式）。_arguments.callee`是过时的和不应该使用。`因此，我们的运行示例的另一个解决方案是使用

Foo`标识符在每个位置作为一个函数对象引用，而不是使用`这`总之，哪个`作品_：_然而，这种方法类似于侧面步骤。

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	foo.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 4
```

实际的_理解_这`和完全依赖变量的词法作用域`Foo`。`另一个接近这个问题的方法是强制。

这`事实上指向`Foo`函数对象：`而不是回避

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	// Note: `this` IS actually `foo` now, based on
	// how `foo` is called (see below)
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		// using `call(..)`, we ensure the `this`
		// points at the function object (`foo`) itself
		foo.call( foo, i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 4
```

**这`我们拥抱它。`我们稍微解释一下。**怎样_这样的技术工作得更彻底，所以如果你还有些困惑的话就别担心！_它的范围

### 下一个最常见的误解

这`它是指函数的作用域。这是一个棘手的问题，因为从某种意义上讲，有些道理，但从另一个意义上说，它是相当误导的。`澄清，

这`不以任何方式引用函数的`词法范围**。的确，内部范围类似于具有每个可用标识符的属性的对象。但是JavaScript代码不能访问范围“对象”。这是一个内在的部分。**发动机_的实现。_考虑尝试（失败）的代码。跨越边界和使用

这`隐式地引用函数的词法范围：`这个片段中不止一个错误。虽然看起来有些做作，但您所看到的代码是在公共社区帮助论坛中交换的实际真实代码的升华。这是一个很好的例子（如果不是悲伤的）。

```js
function foo() {
	var a = 2;
	this.bar();
}

function bar() {
	console.log( this.a );
}

foo(); //undefined
```

这`假设可以。`首先，试图引用

bar()`函数通过`这bar()。`。几乎可以肯定的是`意外_它可以工作，但我们将解释_怎样_不久。最自然的调用方式_bar()`本来是要省略领导的`这。`只需对标识符进行词汇引用。`然而，编写此类代码的开发人员正试图使用。

这`在词法范围之间创建一个桥梁`foo()`和`bar()`，所以`bar()`访问变量`一`在内部范围内`foo()`。`没有这样的桥是可能的。**你不能使用**这`在词汇范围内查找某物的引用。这是不可能的。`每当你觉得自己试图混合词汇范围时

这`提醒自己：`没有桥_。_什么

## 这`？`撇开各种不正确的假设，现在让我们把注意力转向

这`机制确实有效。`我们早些时候说过

这`不是作者绑定时间，而是运行时绑定。它是基于函数调用的条件的上下文相关的。`这`绑定与声明函数的位置无关，但与调用函数的方式有关。`当调用一个函数时，创建一个激活记录，也就是所谓的执行上下文。此记录包含有关从调用堆栈调用函数的信息，

怎样_函数被调用，传递的参数是什么，等等。_函数被调用，传递了什么参数，这个记录的属性之一是`这`用于该函数执行期间的引用。

在下一章中，我们将学习查找函数的**打电话给网站**确定其执行将如何绑定。`这`。

## 回顾（TL；DR）

`这`对于JavaScript开发人员来说，绑定是混乱的经常来源，他们不花时间去了解机制实际上是如何工作的。猜测，试验和错误，盲目副本正贴从堆栈溢出的答案不是杠杆的有效或适当的方式_这_重要的`这`机制.

学习`这`你首先要学什么`这`是_不_尽管有任何可能导致你走上这些道路的假设或误解。`这`既不是对函数本身的引用，也不是对函数的引用。_词汇_范围。

`这`实际上是在函数被调用时产生的绑定，以及_什么_它的引用完全由调用函数的调用站点决定。
