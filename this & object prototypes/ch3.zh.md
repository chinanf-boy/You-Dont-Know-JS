
# 你不认识JS：_这_与对象的原型

# 第3章：对象

在第1章和第2章中，我们解释了`这`根据函数调用的调用位置绑定到各种对象。但是对象究竟是什么，为什么我们需要指向它们呢？我们将在本章中详细探讨对象。

## 语法

对象有两种形式：声明式（字面）形式和构造形式。

对象的字面语法看起来如下所示：

```js
var myObj = {
	key: value
	// ...
};
```

构建的窗体如下所示：

```js
var myObj = new Object();
myObj.key = value;
```

所构造的形式和字面形式导致完全相同的对象类型。惟一的区别是，您可以在文本声明中添加一个或多个键/值对，而对于已构造的表单对象，则必须逐一添加属性。

**注：**使用“构造的窗体”创建对象是非常不寻常的。您几乎总是希望使用字面语法形式。大多数内置对象也是如此（见下文）。

## 型

对象是构建大量js的通用构建块。它们是js中6种主要类型之一（称为“语言类型”）：

-   `一串`
-   `数`
-   `布尔`
-   `无效的`
-   `未定义`
-   `对象`

请注意，_简单的原语_（`一串`，`数`，`布尔`，`无效的`，和`未定义`）是**不**他们自己`物体`。`无效的`有时被称为对象类型，但这种误解源于语言中的一个bug。`类型的空`返回字符串`“对象”`错误（和混淆）。事实上，`无效的`是它自己的原始类型。

**“JavaScript中的所有东西都是对象”是一个常见的错误陈述。这显然不是真的。**

相比之下，那里_是_一些特殊的对象子类型，我们可以称之为_复杂的原语_。

`功能`是对象的子类型（技术上是“可调用对象”）。js中的函数被称为“第一类”，因为它们基本上都是普通对象（带有可调用的行为语义），因此它们可以像其他普通对象一样处理。

数组也是对象的一种形式，具有额外的行为。数组中的内容组织比一般对象稍有结构。

### 内置对象

还有其他几个对象子类型，通常称为内置对象。对于他们中的一些人，他们的名字似乎意味着他们直接关系到他们简单的原语部分，但事实上，他们的关系更为复杂，我们将在不久的将来探索。

-   `字符串`
-   `数`
-   `布尔`
-   `对象`
-   `功能`
-   `阵列`
-   `日期`
-   `正则表达式`
-   `误差`

这些内置的实际类型，甚至阶级的出现，如果你依赖相似的其他语言如java的`字符串`类。

但在js中，它们实际上只是内置函数。这些内置函数中的每一个都可以用作构造函数（也就是说，`新的`操作符——参见第2章，结果是新的_构建_子类型对象。例如:

```js
var strPrimitive = "I am a string";
typeof strPrimitive;							// "string"
strPrimitive instanceof String;					// false

var strObject = new String( "I am a string" );
typeof strObject; 								// "object"
strObject instanceof String;					// true

// inspect the object sub-type
Object.prototype.toString.call( strObject );	// [object String]
```

我们将在后面的章节中详细地看到`对象的ToString。原型…`位工作，但简单地说，我们可以通过借用基本缺省值来检查内部子类型。`tostring()`方法，你可以看到它揭示了`strobject`实际上是由`字符串`构造函数。

原始值`“我是一根绳子”`不是一个对象，它是一个原始的文字和不可变的值。在其上执行操作，如检查其长度、访问其单个字符内容等`字符串`对象是必需的。

幸运的是，语言自动强迫一个`“字符串”`原始的一种`字符串`在必要时，这意味着您几乎不需要显式地创建对象窗体。它是**优先考虑**大多数JS社区在可能的情况下使用文本形式，而不是构建的对象窗体。

考虑：

```js
var strPrimitive = "I am a string";

console.log( strPrimitive.length );			// 13

console.log( strPrimitive.charAt( 3 ) );	// "m"
```

在这两种情况下，我们呼吁一个字符串的原始属性或方法，和发动机自动强迫其一`字符串`对象，以便属性/方法访问工作。

相同的强制类型发生在数字原语之间。`四十二`和`新号码（42）`当使用方法时，对象包装器`42.359固定资产（2）。`。同样，`布尔`对象`“布尔”`原语。

`无效的`和`未定义`没有对象包装器形式，只有它们的原始值。通过对比，`日期`值_只有_用它们所构造的对象形式创建，因为它们没有文字形式的反作用部分。

`对象`S，`阵列`S，`功能`S，和`正则表达式`S（正则表达式）都是对象，不管使用的是文字还是构造形式。在某些情况下，构造形式确实提供了比字面形式对应的更多的创造选项。由于对象是以任意方式创建的，所以简单的字面形式几乎是普遍首选的。**如果需要额外的选项，只使用构造的表单。**

`误差`对象很少在代码中显式创建，但通常在抛出异常时自动创建。`新错误（..）`但这通常是不必要的。

## 内容

如前所述，对象的内容由存储在指定名称中的值（任何类型）组成。_位置_我们称之为属性。

重要的是要注意，当我们说“内容”时，意味着这些值是_事实上_存储在对象中，这只是一个外观。引擎以依赖于实现的方式存储值，并且很可能不能存储它们。_在里面_一些对象容器。什么_是_存储在容器中的是这些属性名，它们充当指针（技术上），_引用_到存储值的地方。

考虑：

```js
var myObject = {
	a: 2
};

myObject.a;		// 2

myObject["a"];	// 2
```

在_位置_一`在里面`MyObject`我们需要使用`。`操作者或`\[ ]`算子。这个`的。`语法通常称为“属性”访问，而`\[ A ]`语法通常称为“键”访问。实际上，它们都访问相同的`位置_并将拉出相同的值，_二`因此，这些术语可以互换使用。我们将从这里开始使用最常用的术语“属性访问”。`两种语法之间的主要区别是：

。`运营商需要一个`标识符`兼容后的属性名，而`\[ \[…] ]`语法可以基本上任何UTF-8字符串/ unicode兼容为属性的名称。引用一个名为“超级乐趣”的属性。例如，你必须使用`\[超级好玩！]`访问语法`超级好玩的！`不是有效的`标识符`属性名称。`而且，自从

\[ \[…] ]`语法使用字符串`价值**为了指定位置，这意味着程序可以以编程方式建立字符串的值，例如：**在对象中，属性名是

```js
var wantA = true;
var myObject = {
	a: 2
};

var idx;

if (wantA) {
	idx = "a";
}

// later

console.log( myObject[idx] ); // 2
```

总是**串.如果您使用其他值，除了**一串`（原始）作为属性，它首先将被转换为字符串。这甚至包括数字，通常用作数组索引，所以注意不要混淆对象和数组之间的数字使用。`计算属性名称

```js
var myObject = { };

myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";

myObject["true"];				// "foo"
myObject["3"];					// "bar"
myObject["[object Object]"];	// "baz"
```

### 这个

MyObject \[ .. ]`如果您需要使用计算表达式值，我们刚才描述的属性访问语法非常有用。`作为_密钥名，例如_MyObject \[前缀+姓名]`。但是当使用对象文本语法声明对象时，这并不是很有帮助。`6加

计算属性名称_，在这里可以指定表达式，由_\[ ]`在对象文字声明的键名称位置：`最常用的用法

```js
var prefix = "foo";

var myObject = {
	[prefix + "bar"]: "hello",
	[prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

计算属性名称_可能是6_符号`在本书中我们将不详细介绍这一点。总之，他们是一个新的原始数据类型有一个不透明的不可猜测值（技术`一串`值）。你将强烈地反对与之合作。`实际值_一个_符号`（从理论上来说，在不同的js引擎之间是不同的），所以`符号`，像`一些符号。`（只是一个假名字！）将是你所使用的：`属性和方法

```js
var myObject = {
	[Symbol.Something]: "hello world"
};
```

### 一些开发人员喜欢在谈论对象上的属性访问时，如果被访问的值恰好是一个函数，则进行区分。因为很容易把函数看成是

属于_对于对象，以及在其他语言中，属于对象（又名“类”）的函数被称为“方法”，与“属性访问”相对应的是“方法访问”，这并不少见。_规范也有同样的区别。

**，有趣的是。**从技术上讲，函数从来都不属于对象，所以说，恰好在对象引用上访问的函数是自动的，“方法”似乎是语义的一部分。

它

是_确实有些函数有_这`参考文献，以及`有时_这些_这`引用指的是调用站点上的对象引用。但这种用法并不能使该函数成为任何其他函数的“方法”，如`这`在运行时动态地绑定在调用站点，因此它与对象的关系是间接的，至多是。`每次访问对象上的属性时，都是

属性访问**不管你得到什么样的价值。如果你**发生_要从该属性访问获得一个函数，在这一点上它并不是一个神奇的“方法”。没有什么特别的（可能的除外）。_这`正如前面解释的绑定，关于一个来自属性访问的函数。`例如:

somefoo

```js
function foo() {
	console.log( "foo" );
}

var someFoo = foo;	// variable reference to `foo`

var myObject = {
	someFoo: foo
};

foo;				// function foo(){..}

someFoo;			// function foo(){..}

myObject.someFoo;	// function foo(){..}
```

`和`myobject.somefoo`只是对同一个函数的两个单独引用，并没有暗示任何特殊或“拥有”任何其他对象的函数。如果`foo()`上面定义有一个`这`参考里面，`myobject.somefoo`隐式绑定`将_只有_两个参考文献之间的可观察到的差异。这两个引用都不是真正意义上的“方法”。**也许有人会争辩**这一功能

**成为一个方法**不是在定义时间，而是在运行时调用，取决于调用站点上调用的方式（对象引用上下文O）_成为一个方法_不是在定义时间，而是在运行时，只是为了调用，取决于它在调用站点上调用的方式（有对象引用上下文）——参见第2章了解更多细节）。甚至这种解释也有点紧张。

最安全的结论可能是“函数”和“方法”在JavaScript中是可以互换的。

**注：**6添加`超级的`引用，通常用于`班`（见附录A）。的方式`超级的`行为（静态绑定而不是后期绑定）`这`）进一步强调了一个函数的概念。`超级的`绑定某处比“函数”更是一种“方法”。但是，这些只是细微的语义（和机械）细微差别。

即使将函数表达式声明为对象文本的一部分，该函数也不会神奇地出现。_属于_更多的对象——仍然是同一个函数对象的多个引用：

```js
var myObject = {
	foo: function foo() {
		console.log( "foo" );
	}
};

var someFoo = myObject.foo;

someFoo;		// function foo(){..}

myObject.foo;	// function foo(){..}
```

**注：**在6章中，我们将覆盖一个6短手`福：功能foo() { ..}`对象文本中的声明语法。

### 阵列

数组也使用`[ ]`访问表单，但如上所述，它们对存储值的方式和位置有稍微有组织的结构（尽管仍然没有限制什么）_类型_值的存储）。阵列承担_数值索引_这意味着值存储在位置，通常称为_指数_在非负整数，例如`零`和`四十二`。

```js
var myArray = [ "foo", 42, "bar" ];

myArray.length;		// 3

myArray[0];			// "foo"

myArray[2];			// "bar"
```

阵列_是_对象，因此即使每个索引都是正整数，您也可以_也_在数组中添加属性：

```js
var myArray = [ "foo", 42, "bar" ];

myArray.baz = "baz";

myArray.length;	// 3

myArray.baz;	// "baz"
```

注意，添加命名属性（不管`。`或`[ ]`运算符语法）不更改报告`长度`数组的。

你_能够_使用一个数组作为一个普通的键/值对象，永远不要添加任何数值索引，但是这是一个坏主意，因为数组的行为和优化是针对它们的预期用途的，同样地，也有普通对象。使用对象存储键/值对，以及数组来存储数值索引中的值。

**小心:**如果您试图向数组中添加属性，但属性名_看_与数字一样，它最终将成为数字索引（从而修改数组内容）：

```js
var myArray = [ "foo", 42, "bar" ];

myArray["3"] = "baz";

myArray.length;	// 4

myArray[3];		// "baz"
```

### 复制对象

当开发人员最新使用JavaScript语言时，最常被要求的特性之一是如何复制对象。看来应该有一个内置的。`copy()`方法，对吗？事实证明它比那个复杂了一点，因为还不完全清楚，默认情况下应该是复制的算法。

例如，考虑这个对象：

```js
function anotherFunction() { /*..*/ }

var anotherObject = {
	c: true
};

var anotherArray = [];

var myObject = {
	a: 2,
	b: anotherObject,	// reference, not a copy!
	c: anotherArray,	// another reference!
	d: anotherFunction
};

anotherArray.push( anotherObject, myObject );
```

A的确切代表应该是什么？_复制_属于`MyObject`？

首先，我们应该回答它是否应该是一个_浅的_或_深的_复制。一_浅拷贝_到头来`一`将新对象作为值的副本。`二`，但`B`，`C`，和`D`属性只引用与原始对象中的引用相同的位置。一_深拷贝_不仅会复制`MyObject`，但`另`和`anotherarray`。但是我们有问题`anotherarray`所引用的`另`和`MyObject`在里面，所以_那些_也应该复制，而不是参考保存。由于循环引用，我们有无限循环复制问题。

我们应该检测一个循环引用并打破循环遍历（让深元素没有完全复制）吗？我们应该完全出错吗？中间有什么？

此外，还不清楚函数的“复制”意味着什么。有一些黑客喜欢拔出`tostring()`函数的源代码的串行化（在实现中各不相同，在所有引擎中都不可靠，这取决于被检查的函数的类型）。

那么，我们该如何解决这些棘手的问题呢？各种js框架都各自选择自己的解释并做出自己的决定。但是JS应该采用哪种（如果有的话）_这个_标准？很长一段时间，没有明确的答案。

一个子集解决方案是JSON安全的对象（即可以序列化为JSON字符串，然后重新解析为具有相同结构和值的对象），可以很容易地_复制_随着：

```js
var newObj = JSON.parse( JSON.stringify( someObj ) );
```

当然，这需要您确保对象是JSON安全的。在某些情况下，这是微不足道的。对其他人来说，这是不够的。

同时，浅拷贝是非常容易理解的，有少得多的问题，所以现在已经定义了6`对象（…）`为了这个任务。`对象（…）`需要一个_目标_对象作为第一个参数，以及一个或多个参数_来源_对象作为其后续参数。遍历所有_枚举_（见下文），_所有的钥匙_（**立即呈现**）上_来源_对象（s）并复制它们（通过`=`仅赋值）_目标_。同时，在返回_目标_正如你在下面看到的：

```js
var newObj = Object.assign( {}, myObject );

newObj.a;						// 2
newObj.b === anotherObject;		// true
newObj.c === anotherArray;		// true
newObj.d === anotherFunction;	// true
```

**注：**在下一节中，我们将描述“属性描述符”（属性特性），并展示`对象。defineproperty（..）`。发生的重复`对象（…）`不过是纯粹的`=`样式赋值，所以属性的任何特殊特性（比如`可写`在源对象上**不保存**在目标对象上。

### 属性说明符

之前ES5，JavaScript语言给你的代码检查或绘制特性之间的任何区别没有直接的方法，如属性是否为只读或不。

但由于ES5，所有性能方面的描述**属性描述符**。

考虑这个代码：

```js
var myObject = {
	a: 2
};

Object.getOwnPropertyDescriptor( myObject, "a" );
// {
//    value: 2,
//    writable: true,
//    enumerable: true,
//    configurable: true
// }
```

正如您所看到的，属性描述符（称为“数据描述符”，因为它只用于保存一个数据值），用于我们的普通对象属性。`一`不仅仅是它的`价值`属于`二`。它包括3个其他特征：`可写`，`枚举`，和`可配置`。

虽然我们可以看到属性描述符特性的默认值是当我们创建一个正常属性时，我们可以使用`对象。defineproperty（..）`添加一个新属性，或修改现有属性（如果它是`可配置`！）具有所需的特性。

例如:

```js
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: true,
	enumerable: true
} );

myObject.a; // 2
```

使用`defineproperty（..）`我们添加了普通的，普通的`一`属性`MyObject`用手工明确的方式。但是，除非您想从其正常行为中修改一个描述符特性，否则一般不会使用这种手动方法。

#### 可写

您更改属性值的能力由`可写`。

考虑：

```js
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: false, // not writable!
	configurable: true,
	enumerable: true
} );

myObject.a = 3;

myObject.a; // 2
```

如你所见，我们修改了`价值`默默的失败。如果我们尝试`严格模式`我们得到一个错误：

```js
"use strict";

var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: false, // not writable!
	configurable: true,
	enumerable: true
} );

myObject.a = 3; // TypeError
```

这个`TypeError`告诉我们不能改变不可写的属性。

**注：**我们将讨论getter和setter不久，但简单，你可以观察到`写：假`表示不能更改值，这与定义非运算器是相当的。事实上，你的OP二传手需要投掷一个`TypeError`在调用时，才能真正符合`写：假`。

#### 可配置

只要一个属性当前是可配置的，我们就可以使用相同的描述符来修改它的描述符定义。`defineproperty（..）`效用。

```js
var myObject = {
	a: 2
};

myObject.a = 3;
myObject.a;					// 3

Object.defineProperty( myObject, "a", {
	value: 4,
	writable: true,
	configurable: false,	// not configurable!
	enumerable: true
} );

myObject.a;					// 4
myObject.a = 5;
myObject.a;					// 5

Object.defineProperty( myObject, "a", {
	value: 6,
	writable: true,
	configurable: true,
	enumerable: true
} ); // TypeError
```

最后的`defineproperty（..）`在一个列表的调用结果，无论`严格模式`如果您试图更改不可配置属性的描述符定义。注意：如你所见，改变`可配置`到`假`是一个**单向动作，不能撤消！**

**注：**有一个微妙的例外要注意：即使财产已经存在。`配置：假`，`可写`总是可以改变的`真正的`到`假`没有错误，却没有回头`真正的`如果已经`假`。

另一件事`配置：假`防止使用的能力`删除`运算符删除现有属性。

```js
var myObject = {
	a: 2
};

myObject.a;				// 2
delete myObject.a;
myObject.a;				// undefined

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: false,
	enumerable: true
} );

myObject.a;				// 2
delete myObject.a;
myObject.a;				// 2
```

如你所见，最后一个`删除`调用失败（无声），因为我们做出了`一`属性不可配置。

`删除`仅用于从对象中直接删除对象属性（可以删除）。如果对象属性是最后一个剩余_参考_对某些对象/函数，以及您`删除`它移除参考现在未引用的对象/函数可以被垃圾收集。但是，它是**不**恰当地考虑`删除`作为一种工具来释放分配的内存作为它在其他语言（如C或C++）。`删除`只是一个对象属性删除操作——仅此而已。

#### 枚举

我们将在这里提到的最终描述符特性（还有两个，我们在讨论激发子/引导程序时很快处理）`枚举`。

这个名字可能很明显，但这一特性控制如果属性将显示在某些对象属性的枚举，如`对..`环。设置`假`让它显示在这样的枚举，尽管它仍然是完全可。设置`真正的`保持现状。

所有正常用户定义的属性默认为`枚举`因为这是最常见的你想要的。但是，如果您想从枚举中隐藏一个特殊属性，请将其设置为`枚举：假`。

我们将展示在更多的细节性不久，所以保持心理书签这个话题。

### 不变性

有时需要制造不可更改的属性或对象（偶然或有意）。ES5添加处理，在各种不同的微妙的方式支持。

值得注意的是**全部的**这些方法创建浅不变性。也就是说，它们只影响对象及其直接属性特性。如果一个对象对另一个对象（数组、对象、函数等）有引用，则_内容_该对象不受影响，并保持可变。

```js
myImmutableObject.foo; // [1,2,3]
myImmutableObject.foo.push( 4 );
myImmutableObject.foo; // [1,2,3,4]
```

我们在这个片段中假设`myimmutableobject`作为不变的已经被创建和保护。但是，也要保护的内容`myimmutableobject.foo`（这是它自己的对象-数组），您还需要做`Foo`不可变的，使用以下功能中的一个或多个。

**注：**在js程序中创建根深蒂固的不可变对象并不常见。特殊案件可以确定_密封_或_冻结_您的所有对象，您可能想退一步，重新考虑您的程序设计，以更强大的潜在变化的对象的价值观。

#### 目标不变

结合`写：假`和`配置：假`基本上可以创建一个_常数_（不能更改、重新定义或删除）作为对象属性，例如：

```js
var myObject = {};

Object.defineProperty( myObject, "FAVORITE_NUMBER", {
	value: 42,
	writable: false,
	configurable: false
} );
```

#### 防止扩展

如果您想阻止对象添加新属性，但另一方面，只剩下对象属性的其余部分，请调用`对象。preventextensions（..）`：

```js
var myObject = {
	a: 2
};

Object.preventExtensions( myObject );

myObject.b = 3;
myObject.b; // undefined
```

在`非严格模式`，创造`B`失败地。在`严格模式`它抛出一个`TypeError`。

#### 密封

`对象：密封（…）`创建一个“密封”对象，这意味着它接受一个现有对象，本质上调用。`对象。preventextensions（..）`在它上，也标志着它的所有现有属性`配置：假`。

因此，不仅不能添加任何其他属性，而且不能重新配置或删除任何现有属性（尽管您_可以_仍然修改它们的值）。

#### 冻结

`对象：冻结（…）`创建一个冻结对象，这意味着它需要一个现有对象，本质上是调用。`对象：密封（…）`它，但它也标志着所有的“数据访问”性质`写：假`这样他们的价值观就不能改变了。

这种方法是最高级别的不变性，可以实现对象本身，因为它可以防止任何更改的对象或其任何直接的性能（虽然，如上所述，任何引用其他对象的内容不受影响）。

你可以通过调用“冻结”一个对象。`对象：冻结（…）`在对象上，然后递归地遍历它引用的所有对象（这是迄今为止没有受到影响的），并调用`对象：冻结（…）`也在他们身上。但是要小心，因为这会影响你不想影响的其他（共享的）对象。

### `[得到]`

关于属性访问是如何执行的，有一个微妙但重要的细节。

考虑：

```js
var myObject = {
	a: 2
};

myObject.a; // 2
```

这个`一个MyObject。`是属性访问，但它不_只是_看看`MyObject`为名称的属性`一`似乎是。

根据规范，上面的代码实际上执行一个`[得到]`操作（有点像函数调用）：`[获得]`）上`MyObject`。默认的内置`[得到]`对象的操作_第一_检查所请求名称的属性的对象，如果找到它，它将相应返回值。

然而，这`[得到]`算法定义了其他重要行为。_不_查找请求名称的属性。我们将在第5章中检查发生了什么。_下一个_（遍历`[原型]`链，如果有的话）。

但这是一个重要的结果`[得到]`操作是，如果不能通过任何方法为请求的属性生成一个值，则返回值。`未定义`。

```js
var myObject = {
	a: 2
};

myObject.b; // undefined
```

这种行为不同于您引用的行为。_变量_通过它们的标识符名称。如果引用不能在可应用的词法范围查找中解决的变量，则结果不是`未定义`因为它是对象属性，而不是`引用错误`抛出。

```js
var myObject = {
	a: undefined
};

myObject.a; // undefined

myObject.b; // undefined
```

从一个_价值_这两个引用之间没有区别，它们都导致`未定义`。然而，这`[得到]`下面的操作，虽然一目了然，但可能为“参考”做了更多的“工作”。`MyObject。B`比对参考`一个MyObject。`。

仅检查值结果，不能区分某个属性是否存在并保留显式值。`未定义`或财产是否_不_存在`未定义`默认的返回值是`[得到]`未能显式返回某些内容。不过，我们很快就会看到你_可以_区分这两种情况。

### `[…]`

既然有内部定义`[得到]`从属性获取值的操作应该很明显，也有默认值。`[…]`操作。

可能认为，对对象上的属性赋值只会调用`[…]`在问题对象上设置或创建该属性。但情况比那更微妙。

当调用`[…]`，如何表现不同，基于多项因素，包括（最impactfully）属性是否已在对象上或不。

如果属性存在，则`[…]`算法大致检查：

1.  是财产的访问说明符（参见“干将与二传手”一节）？**如果是的话，打电话给二传手，如果有的话。**
2.  属性是数据描述符吗？`可写`属于`假`？**如果是这样，默默地失败`非严格模式`，或扔`TypeError`在里面`严格模式`。**
3.  否则，将值设置为正常属性。

如果该属性尚未存在于所讨论的对象上，则`[…]`操作更加细致入微和复杂。在讨论第5章时，我们将重新讨论这个场景。`[原型]`让它更清晰。

### 干将与二传手

默认的`[…]`和`[得到]`对象的操作完全控制值a

**注：**使用该语言的未来/高级功能，可以重写默认值。`[得到]`或`[…]`整个对象的操作（不仅仅是每个属性）。这超出了我们在本书中讨论的范围，但稍后将在“不知道JS”系列中讨论。

ES5介绍了覆盖这些默认的行动的一部分，不在对象级，但每一个属性，通过使用getter和setter。干将是性能，所谓的隐函数来检索一个值。设置者实际上称为隐藏函数来设置值的属性。

当你定义一个属性有一个getter或setter或两者，其定义成为一个“访问描述符”（而不是“数据描述符”）。对于访问的描述符，`价值`和`可写`描述符的特性是未讨论和忽略的，而JS考虑`设置`和`得到`财产的特征（以及`可配置`和`枚举`）。

考虑：

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return 2;
	}
};

Object.defineProperty(
	myObject,	// target
	"b",		// property name
	{			// descriptor
		// define a getter for `b`
		get: function(){ return this.a * 2 },

		// make sure `b` shows up as an object property
		enumerable: true
	}
);

myObject.a; // 2

myObject.b; // 4
```

通过对象字面语法`得到a() { ..}`或者通过明确的定义`defineproperty（..）`在这两种情况下，我们在对象上创建了一个属性，该属性实际上不包含一个值，但是它的访问会自动导致对函数的隐藏函数调用，它返回的任何值都是属性访问的结果。

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return 2;
	}
};

myObject.a = 3;

myObject.a; // 2
```

因为我们只定义了一个`一`如果我们试图确定`一`稍后，set操作不会抛出错误，但只会默默地把任务扔掉。即使有一个有效的设置，我们的自定义吸气剂也被硬编码为只返回。`二`因此，设定操作将是毫无意义的。

为了使这个场景更为合理，属性也应该由决策器定义，它覆盖默认值。`[…]`正如您所期望的，每个属性的操作（又名赋值）。几乎可以肯定，您总是希望声明吸气剂和二传手（只有一个或另一个经常导致意外/令人惊讶的行为）：

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return this._a_;
	},

	// define a setter for `a`
	set a(val) {
		this._a_ = val * 2;
	}
};

myObject.a = 2;

myObject.a; // 4
```

**注：**在本例中，我们实际存储指定的值。`二`分配的任务（`[…]`操作）到另一个变量中`_a_`。这个`_a_`对于这个例子，名字纯粹是惯例，并暗示它的行为没有什么特别之处——它是一个正常属性。

### 存在

我们在前面展示了一个属性访问`一个MyObject。`可能导致`未定义`如果显式的值`未定义`存储在或`一`属性根本不存在。因此，如果两种情况下的值相同，我们又如何区分它们呢？

我们可以问一个对象是否有某种属性。_没有_要求得到那财产的价值：

```js
var myObject = {
	a: 2
};

("a" in myObject);				// true
("b" in myObject);				// false

myObject.hasOwnProperty( "a" );	// true
myObject.hasOwnProperty( "b" );	// false
```

这个`在里面`运营商将检查物业是否_在里面_对象，或者如果它存在于任何更高级别的`[原型]`链对象遍历（见第5章）。通过对比，`hasownproperty（..）`检查看是否_只有_MyObject`拥有或不拥有财产`不_咨询_\[原型]`链。我们将在第5章中回顾一下这两种操作之间的重要区别。`\[原型]`详细说明。`hasownproperty（..）

`对所有正常对象都可以通过委托访问。`object.prototype`（见第5章）。但是创建一个不链接到的对象是可能的。`object.prototype`（通过`对象创建（null）`——见第5章）。在这种情况下，方法调用类似`MyObject。hasownproperty（..）`会失败。`在这种情况下，执行这种检查的一种更健壮的方法是

对象的原型。hasownproperty。电话（MyObject，“”）`借用基础`hasownproperty（..）`方法与应用`明确的_这`结合`（见第2章）适用于我们_MyObject`。`注：

**这个**在里面`运算符具有外观，它将检查是否存在`价值_在容器内，但实际上检查属性名的存在性。对于数组，这种区别是很重要的，就像尝试检查一样。_4 \[ 2, 4, 6 ]`很强，但这不会像预期的那样。`枚举

#### 此前，我们简要地说明了“枚举”当我们看着

枚举`属性描述符特性。让我们重新审视一下，并更仔细地研究它。`你会注意到

```js
var myObject = { };

Object.defineProperty(
	myObject,
	"a",
	// make `a` enumerable, as normal
	{ enumerable: true, value: 2 }
);

Object.defineProperty(
	myObject,
	"b",
	// make `b` NON-enumerable
	{ enumerable: false, value: 3 }
);

myObject.b; // 3
("b" in myObject); // true
myObject.hasOwnProperty( "b" ); // true

// .......

for (var k in myObject) {
	console.log( k, myObject[k] );
}
// "a" 2
```

MyObject。B`事实上，`存在**并且有一个可访问的值，但它不会出现在**对..`循环（但令人惊讶的是）`是**揭示了**在里面`操作员存在检查）。这是因为“枚举”的基本意思是“如果将对象的属性遍历”包括。`注：

**对..**循环应用于阵列可以给一些意想不到的结果，在一个数组的计数将不仅包括所有的数字指标，也是任何可枚举属性。这是个好主意。`对..`环`只有`关于物体和传统_对于_对数组中存储的值进行数值索引迭代的循环。`另一种方式，可枚举，不可枚举属性可以区分：`propertyisenumerable（..）

测试是否给予

```js
var myObject = { };

Object.defineProperty(
	myObject,
	"a",
	// make `a` enumerable, as normal
	{ enumerable: true, value: 2 }
);

Object.defineProperty(
	myObject,
	"b",
	// make `b` non-enumerable
	{ enumerable: false, value: 3 }
);

myObject.propertyIsEnumerable( "a" ); // true
myObject.propertyIsEnumerable( "b" ); // false

Object.keys( myObject ); // ["a"]
Object.getOwnPropertyNames( myObject ); // ["a", "b"]
```

`propertyisenumerable（..）`测试给定属性名是否存在。_直接地_关于对象也是`枚举：真`。

`对象（键）`返回所有可枚举属性数组，而`对象。getownpropertynames（..）`返回一个数组_全部的_性能，可数或不。

而`在里面`vs.`hasownproperty（..）`他们是否咨询`[原型]`链条或不，`对象（键）`和`对象。getownpropertynames（..）`同时检查_只有_指定的直接对象。

有（目前）没有内置的方式获得一个列表**所有属性**这等于是什么`在里面`操作员测试将参考（遍历整个属性）`[原型]`链，如第5章所述）。通过递归遍历，可以近似这样的实用程序。`[原型]`对象的链，对于每个级别，从`对象（键）`只有可数性质。

## 迭代

这个`对..`循环遍历对象的可枚举的属性列表（包括其`[原型]`链）。但是如果你想迭代这些值呢？

对于数字索引数组，对值的迭代通常用一个标准来完成。`对于`循环，如：

```js
var myArray = [1, 2, 3];

for (var i = 0; i < myArray.length; i++) {
	console.log( myArray[i] );
}
// 1 2 3
```

不过，这不是迭代值，而是迭代索引，然后在索引中使用索引引用值，如`MyArray [我]`。

ES5还增加了阵列的几个迭代的助手，包括`foreach（..）`，`每（…）`，和`一些（…）`。这些助手中的每一个都接受一个函数回调来应用于数组中的每个元素，不同的是它们分别对回调中返回值的响应。

`foreach（..）`将迭代数组中的所有值，并忽略任何回调返回值。`每（…）`一直走到最后_或_回调返回一个`假`（或“falsy”）的价值，而`一些（…）`一直走到最后_或_回调返回一个`真正的`（或“真相”）的价值。

这些特殊的返回值在`每（…）`和`一些（…）`有点像`打破`正常语句`对于`循环，在结束之前，停止迭代。

如果您用`对..`环，你也只会在价值是间接的，因为它实际上只有在对象的可枚举属性的迭代，让你访问性能手动获得价值。

**注：**与用数字有序方式迭代数组索引（与此相反）`对于`循环或其他迭代器，在对象属性上的迭代顺序是**没有保证**在不同的JS引擎之间可能会有所不同。**不依赖**对于任何需要环境一致性的事物，任何观察到的协议都是不可靠的。

但是，如果您想要直接遍历值，而不是数组索引（或对象属性）呢？还好，6添加`对..`循环语法，用于遍历数组（以及对象，如果对象定义了自己的自定义迭代器）：

```js
var myArray = [ 1, 2, 3 ];

for (var v of myArray) {
	console.log( v );
}
// 1
// 2
// 3
```

这个`对..`循环要求一个迭代器对象（默认的内部函数称为`@ @迭代器`在规格说明中）_事情_将迭代和循环，然后遍历调用迭代器对象的连续的返回值`next()`方法，每次循环迭代一次。

数组有内置的`@ @迭代器`，所以`对..`如图所示，它们很容易工作。但是，让我们使用内置的数组手动迭代数组。`@ @迭代器`看看它是如何工作的：

```js
var myArray = [ 1, 2, 3 ];
var it = myArray[Symbol.iterator]();

it.next(); // { value:1, done:false }
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { done:true }
```

**注：**我们得到`@ @迭代器`内部属性_使用6对象_符号`：`symbol.iterator`。我们简要地提到`符号`本章前面的语义（参见“计算的属性名称”），因此这里也适用同样的推理。您总是希望引用这些特殊属性。`符号`名称引用，而不是它可能保存的特殊值。此外，尽管名字的含义，`@ @迭代器`是`不是迭代器对象**本身，但**函数返回**迭代器对象——一个微妙但重要的细节！**正如上面的代码片段所揭示的，迭代器的返回值

next()`调用是表单的对象。`{值：…完成了…}`，在那里`价值`是当前的迭代值，以及`完成`是一个`布尔`这表明是否有更多的迭代。`通知的价值

三`被退回`做：假`乍一看，这似乎很奇怪。你必须打电话给`next()`第四次（其中`对..`前一段代码中的循环自动执行）`做：真的`并且知道你真的完成了迭代。这种怪癖的原因超出了范围，我们在这里讨论的，但是它来自ES6生成器的功能语义。`数组确实自动迭代

对..`循环，规则对象`没有内置的**@ @迭代器`。故意遗漏的原因比我们在这里要研究的要复杂得多，但总的来说，最好不要包含一些可能对未来类型的对象造成麻烦的实现。`**它

是_可能定义你_可以定义自己的默认值`@ @迭代器`对于任何您想迭代的对象。例如:

```js
var myObject = {
	a: 2,
	b: 3
};

Object.defineProperty( myObject, Symbol.iterator, {
	enumerable: false,
	writable: false,
	configurable: true,
	value: function() {
		var o = this;
		var idx = 0;
		var ks = Object.keys( o );
		return {
			next: function() {
				return {
					value: o[ks[idx++]],
					done: (idx > ks.length)
				};
			}
		};
	}
} );

// iterate `myObject` manually
var it = myObject[Symbol.iterator]();
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { value:undefined, done:true }

// iterate `myObject` with `for..of`
for (var v of myObject) {
	console.log( v );
}
// 2
// 3
```

**注：**我们使用`对象。defineproperty（..）`定义我们的习惯`@ @迭代器`（所以我们可以使它不可数），但使用`符号`作为一个_计算属性名称_（本章前面提到），我们可以直接声明它，比如`VaR MyObject = {：2、B 3、[符号。迭代器]：function() { /* ..} }`。

每一次的`对..`循环调用`next()`在`MyObject`的迭代器对象，内部指针将前进并返回对象属性列表中的下一个值（参见前面关于对象属性/值的迭代排序的说明）。

我们刚才演示的迭代是一个简单的按值迭代，但是您可以为您的自定义数据结构定义任意复杂的迭代，如您所见。自定义迭代器ES6的结合`对..`循环是用于处理用户定义对象的强大的新语法工具。

例如，一个列表`像素`对象（与`X`和`Y`坐标值）可以决定基于线性距离的迭代。`（0,0）`如果您的迭代器返回期望值，则为“太远”等等。`{值：…}`返回值`next()`调用和`{已完成：真}`在迭代完成的，6`对..`可以迭代它。

事实上，您甚至可以生成“无限”迭代器，这些迭代器从不“完成”，并且总是返回一个新值（如随机数、递增值、唯一标识符等），尽管您可能不会使用具有无限边界的迭代器。`对..`循环，因为它永远不会结束，并且会挂起你的程序。

```js
var randoms = {
	[Symbol.iterator]: function() {
		return {
			next: function() {
				return { value: Math.random() };
			}
		};
	}
};

var randoms_pool = [];
for (var n of randoms) {
	randoms_pool.push( n );

	// don't proceed unbounded!
	if (randoms_pool.length === 100) break;
}
```

这个迭代器会生成随机数“永远”，所以我们小心地只拔出100个值，这样我们的程序就不会挂起了。

## 回顾（TL；DR）

js中的对象都有一个字面形式（例如`var…}`和一种构造形式（如`var =新数组（..）`）。字面形式几乎总是首选，但是构建的表单在某些情况下提供更多的创建选项。

很多人错误地宣称“JavaScript中的所有东西都是一个对象”，但这是不正确的。对象是6个（或7个，取决于您的视角）原始类型。对象有子类型，包括`功能`也可以是行为专门化的，比如`[对象数组]`作为表示数组对象子类型的内部标签。

对象是键/值对的集合。这些值可以作为属性访问，通过`propname。`或`[“propname”]`语法。每当访问一个属性时，引擎实际上调用内部默认值。`[得到]`（和操作`[…]`用于设置值），它不仅直接在对象上查找属性，而且将遍历对象。`[原型]`链（见第5章）如果找不到。

属性具有通过属性描述符控制的某些特性，如`可写`和`可配置`。此外，对象可以有自己的易变性（和他们的属性）控制的不同程度的永恒性使用`对象。preventextensions（..）`，`对象：密封（…）`，和`对象：冻结（…）`。

性能不一定要包含价值--他们可以访问属性”，用getter和setter。他们也可以是_枚举_或者不，控制它们是否出现在`对..`循环迭代，例如。

你也可以迭代**价值观**数据结构（数组、对象等）使用6`对..`语法，它查找内置的或自定义的`@ @迭代器`由一个`next()`方法一次一次地通过数据值。
