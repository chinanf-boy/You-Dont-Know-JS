
# 你不认识JS: _这_与对象的原型

# 第3章: 对象

在第1章和第2章中,我们解释了`这`根据函数调用的调用位置绑定到各种对象ㄢ但是对象究竟是什么,为什么我们需要指向它们呢?我们将在本章中详细探讨对象ㄢ

## 语法

对象有两种形式: 声明式(字面)形式和构造形式ㄢ

对象的字面语法看起来如下所示: 

```js
var myObj = {
	key: value
	// ...
};
```

构建的窗体如下所示: 

```js
var myObj = new Object();
myObj.key = value;
```

所构造的形式和字面形式导致完全相同的对象类型ㄢ惟一的区别是,您可以在文本声明中添加一个或多个键/值对,而对于已构造的表单对象,则必须逐一添加属性ㄢ

**注: **使用"构造的窗体ℽ创建对象是非常不寻常的ㄢ您几乎总是希望使用字面语法形式ㄢ大多数内置对象也是如此(见下文)ㄢ

## 型

对象是构建大量js的通用构建块ㄢ它们是js中6种主要类型之一(称为"语言类型ℽ): 

-   `一串`
-   `数`
-   `布尔`
-   `无效的`
-   `未定义`
-   `对象`

请注意,_简单的原语_(`一串`,`数`,`布尔`,`无效的`,和`未定义`)是**不**他们自己`物体`ㄢ`无效的`有时被称为对象类型,但这种误解源于语言中的一个bugㄢ`类型的空`返回字符串`"对象ℽ`错误(和混淆)ㄢ事实上,`无效的`是它自己的原始类型ㄢ

**"JavaScript中的所有东西都是对象ℽ是一个常见的错误陈述ㄢ这显然不是真的ㄢ**

相比之下,那里_是_一些特殊的对象子类型,我们可以称之为_复杂的原语_ㄢ

`功能`是对象的子类型(技术上是"可调用对象ℽ)ㄢjs中的函数被称为"第一类ℽ,因为它们基本上都是普通对象(带有可调用的行为语义),因此它们可以像其他普通对象一样处理ㄢ

数组也是对象的一种形式,具有额外的行为ㄢ数组中的内容组织比一般对象稍有结构ㄢ

### 内置对象

还有其他几个对象子类型,通常称为内置对象ㄢ对于他们中的一些人,他们的名字似乎意味着他们直接关系到他们简单的原语部分,但事实上,他们的关系更为复杂,我们将在不久的将来探索ㄢ

-   `字符串`
-   `数`
-   `布尔`
-   `对象`
-   `功能`
-   `阵列`
-   `日期`
-   `正则表达式`
-   `误差`

这些内置的实际类型,甚至阶级的出现,如果你依赖相似的其他语言如java的`字符串`类ㄢ

但在js中,它们实际上只是内置函数ㄢ这些内置函数中的每一个都可以用作构造函数(也就是说,`新的`操作符ℴℴ参见第2章,结果是新的_构建_子类型对象ㄢ例如:

```js
var strPrimitive = "I am a string";
typeof strPrimitive;							// "string"
strPrimitive instanceof String;					// false

var strObject = new String( "I am a string" );
typeof strObject; 								// "object"
strObject instanceof String;					// true

// inspect the object sub-type
Object.prototype.toString.call( strObject );	// [object String]
```

我们将在后面的章节中详细地看到`对象的ToStringㄢ原型ⅆ`位工作,但简单地说,我们可以通过借用基本缺省值来检查内部子类型ㄢ`tostring()`方法,你可以看到它揭示了`strobject`实际上是由`字符串`构造函数ㄢ

原始值`"我是一根绳子ℽ`不是一个对象,它是一个原始的文字和不可变的值ㄢ在其上执行操作,如检查其长度ㄡ访问其单个字符内容等`字符串`对象是必需的ㄢ

幸运的是,语言自动强迫一个`"字符串ℽ`原始的一种`字符串`在必要时,这意味着您几乎不需要显式地创建对象窗体ㄢ它是**优先考虑**大多数JS社区在可能的情况下使用文本形式,而不是构建的对象窗体ㄢ

考虑: 

```js
var strPrimitive = "I am a string";

console.log( strPrimitive.length );			// 13

console.log( strPrimitive.charAt( 3 ) );	// "m"
```

在这两种情况下,我们呼吁一个字符串的原始属性或方法,和发动机自动强迫其一`字符串`对象,以便属性/方法访问工作ㄢ

相同的强制类型发生在数字原语之间ㄢ`四十二`和`新号码(42)`当使用方法时,对象包装器`42.359固定资产(2)ㄢ`ㄢ同样,`布尔`对象`"布尔ℽ`原语ㄢ

`无效的`和`未定义`没有对象包装器形式,只有它们的原始值ㄢ通过对比,`日期`值_只有_用它们所构造的对象形式创建,因为它们没有文字形式的反作用部分ㄢ

`对象`S,`阵列`S,`功能`S,和`正则表达式`S(正则表达式)都是对象,不管使用的是文字还是构造形式ㄢ在某些情况下,构造形式确实提供了比字面形式对应的更多的创造选项ㄢ由于对象是以任意方式创建的,所以简单的字面形式几乎是普遍首选的ㄢ**如果需要额外的选项,只使用构造的表单ㄢ**

`误差`对象很少在代码中显式创建,但通常在抛出异常时自动创建ㄢ`新错误(..)`但这通常是不必要的ㄢ

## 内容

如前所述,对象的内容由存储在指定名称中的值(任何类型)组成ㄢ_位置_我们称之为属性ㄢ

重要的是要注意,当我们说"内容ℽ时,意味着这些值是_事实上_存储在对象中,这只是一个外观ㄢ引擎以依赖于实现的方式存储值,并且很可能不能存储它们ㄢ_在里面_一些对象容器ㄢ什么_是_存储在容器中的是这些属性名,它们充当指针(技术上),_引用_到存储值的地方ㄢ

考虑: 

```js
var myObject = {
	a: 2
};

myObject.a;		// 2

myObject["a"];	// 2
```

在_位置_ `一`在里面`MyObject`我们需要使用`ㄢ`操作者或`[ ]`算子ㄢ这个`的ㄢ`语法通常称为"属性ℽ访问,而`[ A ]`语法通常称为"键ℽ访问ㄢ实际上,它们都访问相同的_位置_并将拉出相同的值,`二`因此,这些术语可以互换使用ㄢ我们将从这里开始使用最常用的术语"属性访问ℽㄢ

两种语法之间的主要区别是: `ㄢ`运营商需要一个`标识符`兼容后的属性名,而`[ [ⅆ] ]`语法可以基本上任何UTF-8字符串/ unicode兼容为属性的名称ㄢ引用一个名为"超级乐趣ℽ的属性ㄢ例如,你必须使用`[超级好玩!]`访问语法`超级好玩的!`不是有效的`标识符`属性名称ㄢ

而且,自从`[ [ⅆ] ]`语法使用字符串**价值**为了指定位置,这意味着程序可以以编程方式建立字符串的值,例如: 

```js
var wantA = true;
var myObject = {
	a: 2
};

var idx;

if (wantA) {
	idx = "a";
}

// later

console.log( myObject[idx] ); // 2
```

在对象中,属性名是**总是**串.如果您使用其他值,除了`一串`(原始)作为属性,它首先将被转换为字符串ㄢ这甚至包括数字,通常用作数组索引,所以注意不要混淆对象和数组之间的数字使用ㄢ

```js
var myObject = { };

myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";

myObject["true"];				// "foo"
myObject["3"];					// "bar"
myObject["[object Object]"];	// "baz"
```

### 计算属性名称

这个`MyObject [ .. ]`如果您需要使用计算表达式值,我们刚才描述的属性访问语法非常有用ㄢ_作为_密钥名,例如`MyObject [前缀+姓名]`ㄢ但是当使用对象文本语法声明对象时,这并不是很有帮助ㄢ

6加_计算属性名称_,在这里可以指定表达式,由`[ ]`在对象文字声明的键名称位置: 

```js
var prefix = "foo";

var myObject = {
	[prefix + "bar"]: "hello",
	[prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

最常用的用法_计算属性名称_可能是6`符号`在本书中我们将不详细介绍这一点ㄢ总之,他们是一个新的原始数据类型有一个不透明的不可猜测值(技术`一串`值)ㄢ你将强烈地反对与之合作ㄢ_实际值_一个`符号`(从理论上来说,在不同的js引擎之间是不同的),所以`符号`,像`一些符号ㄢ`(只是一个假名字!)将是你所使用的: 

```js
var myObject = {
	[Symbol.Something]: "hello world"
};
```

### 属性和方法

一些开发人员喜欢在谈论对象上的属性访问时,如果被访问的值恰好是一个函数,则进行区分ㄢ因为很容易把函数看成是_属于_对于对象,以及在其他语言中,属于对象(又名"类ℽ)的函数被称为"方法ℽ,与"属性访问ℽ相对应的是"方法访问ℽ,这并不少见ㄢ

**规范也有同样的区别ㄢ**,有趣的是ㄢ

从技术上讲,函数从来都不属于对象,所以说,恰好在对象引用上访问的函数是自动的,"方法ℽ似乎是语义的一部分ㄢ

它_是_确实有些函数有`这`参考文献,以及_有时_这些`这`引用指的是调用站点上的对象引用ㄢ但这种用法并不能使该函数成为任何其他函数的"方法ℽ,如`这`在运行时动态地绑定在调用站点,因此它与对象的关系是间接的,至多是ㄢ

每次访问对象上的属性时,都是**属性访问**不管你得到什么样的价值ㄢ如果你_发生_要从该属性访问获得一个函数,在这一点上它并不是一个神奇的"方法ℽㄢ没有什么特别的(可能的除外)ㄢ`这`正如前面解释的绑定,关于一个来自属性访问的函数ㄢ

例如:

```js
function foo() {
	console.log( "foo" );
}

var someFoo = foo;	// variable reference to `foo`

var myObject = {
	someFoo: foo
};

foo;				// function foo(){..}

someFoo;			// function foo(){..}

myObject.someFoo;	// function foo(){..}
```

`somefoo`和`myobject.somefoo`只是对同一个函数的两个单独引用,并没有暗示任何特殊或"拥有ℽ任何其他对象的函数ㄢ如果`foo()`上面定义有一个`这`参考里面,`myobject.somefoo` _隐式绑定_将**只有**两个参考文献之间的可观察到的差异ㄢ这两个引用都不是真正意义上的"方法ℽㄢ

**也许有人会争辩**这一功能_成为一个方法_不是在定义时间,而是在运行时调用,取决于调用站点上调用的方式(对象引用上下文或否)

最安全的结论可能是"函数ℽ和"方法ℽ在JavaScript中是可以互换的ㄢ

**注: **6添加`超级的`引用,通常用于`班`(见附录A)ㄢ的方式`超级的`行为(静态绑定而不是后期绑定)`这`)进一步强调了一个函数的概念ㄢ`超级的`绑定某处比"函数ℽ更是一种"方法ℽㄢ但是,这些只是细微的语义(和机械)细微差别ㄢ

即使将函数表达式声明为对象文本的一部分,该函数也不会神奇地出现ㄢ_属于_更多的对象ℴℴ仍然是同一个函数对象的多个引用: 

```js
var myObject = {
	foo: function foo() {
		console.log( "foo" );
	}
};

var someFoo = myObject.foo;

someFoo;		// function foo(){..}

myObject.foo;	// function foo(){..}
```

**注: **在6章中,我们将覆盖一个6短手`福: 功能foo() { ..}`对象文本中的声明语法ㄢ

### 阵列

数组也使用`[ ]`访问表单,但如上所述,它们对存储值的方式和位置有稍微有组织的结构(尽管仍然没有限制什么)_类型_值的存储)ㄢ阵列承担_数值索引_这意味着值存储在位置,通常称为_指数_在非负整数,例如`零`和`四十二`ㄢ

```js
var myArray = [ "foo", 42, "bar" ];

myArray.length;		// 3

myArray[0];			// "foo"

myArray[2];			// "bar"
```

阵列_是_对象,因此即使每个索引都是正整数,您也可以_也_在数组中添加属性: 

```js
var myArray = [ "foo", 42, "bar" ];

myArray.baz = "baz";

myArray.length;	// 3

myArray.baz;	// "baz"
```

注意,添加命名属性(不管`ㄢ`或`[ ]`运算符语法)不更改报告`长度`数组的ㄢ

你_能够_使用一个数组作为一个普通的键/值对象,永远不要添加任何数值索引,但是这是一个坏主意,因为数组的行为和优化是针对它们的预期用途的,同样地,也有普通对象ㄢ使用对象存储键/值对,以及数组来存储数值索引中的值ㄢ

**小心:**如果您试图向数组中添加属性,但属性名_看_与数字一样,它最终将成为数字索引(从而修改数组内容): 

```js
var myArray = [ "foo", 42, "bar" ];

myArray["3"] = "baz";

myArray.length;	// 4

myArray[3];		// "baz"
```

### 复制对象

当开发人员最新使用JavaScript语言时,最常被要求的特性之一是如何复制对象ㄢ看来应该有一个内置的ㄢ`copy()`方法,对吗?事实证明它比那个复杂了一点,因为还不完全清楚,默认情况下应该是复制的算法ㄢ

例如,考虑这个对象: 

```js
function anotherFunction() { /*..*/ }

var anotherObject = {
	c: true
};

var anotherArray = [];

var myObject = {
	a: 2,
	b: anotherObject,	// reference, not a copy!
	c: anotherArray,	// another reference!
	d: anotherFunction
};

anotherArray.push( anotherObject, myObject );
```

A的确切代表应该是什么?_复制_属于`MyObject`?

首先,我们应该回答它是否应该是一个_浅的_或_深的_复制ㄢ一_浅拷贝_到头来`一`将新对象作为值的副本ㄢ`二`,但`B`,`C`,和`D`属性只引用与原始对象中的引用相同的位置ㄢ一_深拷贝_不仅会复制`MyObject`,但`另`和`anotherarray`ㄢ但是我们有问题`anotherarray`所引用的`另`和`MyObject`在里面,所以_那些_也应该复制,而不是参考保存ㄢ由于循环引用,我们有无限循环复制问题ㄢ

我们应该检测一个循环引用并打破循环遍历(让深元素没有完全复制)吗?我们应该完全出错吗?中间有什么?

此外,还不清楚函数的"复制ℽ意味着什么ㄢ有一些黑客喜欢拔出`tostring()`函数的源代码的串行化(在实现中各不相同,在所有引擎中都不可靠,这取决于被检查的函数的类型)ㄢ

那么,我们该如何解决这些棘手的问题呢?各种js框架都各自选择自己的解释并做出自己的决定ㄢ但是JS应该采用哪种(如果有的话)_这个_标准?很长一段时间,没有明确的答案ㄢ

一个子集解决方案是JSON安全的对象(即可以序列化为JSON字符串,然后重新解析为具有相同结构和值的对象),可以很容易地_复制_随着: 

```js
var newObj = JSON.parse( JSON.stringify( someObj ) );
```

当然,这需要您确保对象是JSON安全的ㄢ在某些情况下,这是微不足道的ㄢ对其他人来说,这是不够的ㄢ

同时,浅拷贝是非常容易理解的,有少得多的问题,所以现在已经定义了6`对象(ⅆ)`为了这个任务ㄢ`对象(ⅆ)`需要一个_目标_对象作为第一个参数,以及一个或多个参数_来源_对象作为其后续参数ㄢ遍历所有_枚举_(见下文),_所有的钥匙_(**立即呈现**)上_来源_对象(s)并复制它们(通过`=`仅赋值)_目标_ㄢ同时,在返回_目标_正如你在下面看到的: 

```js
var newObj = Object.assign( {}, myObject );

newObj.a;						// 2
newObj.b === anotherObject;		// true
newObj.c === anotherArray;		// true
newObj.d === anotherFunction;	// true
```

**注: **在下一节中,我们将描述"属性描述符ℽ(属性特性),并展示`对象ㄢdefineproperty(..)`ㄢ发生的重复`对象(ⅆ)`不过是纯粹的`=`样式赋值,所以属性的任何特殊特性(比如`可写`在源对象上**不保存**在目标对象上ㄢ

### 属性说明符

之前ES5,JavaScript语言没有方向

但由于ES5,所有性能方面的描述**属性描述符**ㄢ

考虑这个代码: 

```js
var myObject = {
	a: 2
};

Object.getOwnPropertyDescriptor( myObject, "a" );
// {
//    value: 2,
//    writable: true,
//    enumerable: true,
//    configurable: true
// }
```

正如您所看到的,属性描述符(称为"数据描述符ℽ,因为它只用于保存一个数据值),用于我们的普通对象属性ㄢ`一`不仅仅是它的`价值`属于`二`ㄢ它包括3个其他特征: `可写`,`枚举`,和`可配置`ㄢ

虽然我们可以看到属性描述符特性的默认值是当我们创建一个正常属性时,我们可以使用`对象ㄢdefineproperty(..)`添加一个新属性,或修改现有属性(如果它是`可配置`!)具有所需的特性ㄢ

例如:

```js
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: true,
	enumerable: true
} );

myObject.a; // 2
```

使用`defineproperty(..)`我们添加了普通的,普通的`一`属性`MyObject`用手工明确的方式ㄢ但是,除非您想从其正常行为中修改一个描述符特性,否则一般不会使用这种手动方法ㄢ

#### 可写

您更改属性值的能力由`可写`ㄢ

考虑: 

```js
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: false, // not writable!
	configurable: true,
	enumerable: true
} );

myObject.a = 3;

myObject.a; // 2
```

如你所见,我们修改了`价值`默默的失败ㄢ如果我们尝试`严格模式`我们得到一个错误: 

```js
"use strict";

var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: false, // not writable!
	configurable: true,
	enumerable: true
} );

myObject.a = 3; // TypeError
```

这个`TypeError`告诉我们不能改变不可写的属性ㄢ

**注: **我们将讨论getter和setter不久,但简单,你可以观察到`写: 假`表示不能更改值,这与定义非运算器是相当的ㄢ事实上,你的OP二传手需要投掷一个`TypeError`在调用时,才能真正符合`写: 假`ㄢ

#### 可配置

只要一个属性当前是可配置的,我们就可以使用相同的描述符来修改它的描述符定义ㄢ`defineproperty(..)`效用ㄢ

```js
var myObject = {
	a: 2
};

myObject.a = 3;
myObject.a;					// 3

Object.defineProperty( myObject, "a", {
	value: 4,
	writable: true,
	configurable: false,	// not configurable!
	enumerable: true
} );

myObject.a;					// 4
myObject.a = 5;
myObject.a;					// 5

Object.defineProperty( myObject, "a", {
	value: 6,
	writable: true,
	configurable: true,
	enumerable: true
} ); // TypeError
```

最后的`defineproperty(..)`在一个列表的调用结果,无论`严格模式`如果您试图更改不可配置属性的描述符定义ㄢ注意: 如你所见,改变`可配置`到`假`是一个**单向动作,不能撤消!**

**注: **有一个微妙的例外要注意: 即使财产已经存在ㄢ`配置: 假`,`可写`总是可以改变的`真正的`到`假`没有错误,却没有回头`真正的`如果已经`假`ㄢ

另一件事`配置: 假`防止使用的能力`删除`运算符删除现有属性ㄢ

```js
var myObject = {
	a: 2
};

myObject.a;				// 2
delete myObject.a;
myObject.a;				// undefined

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: false,
	enumerable: true
} );

myObject.a;				// 2
delete myObject.a;
myObject.a;				// 2
```

如你所见,最后一个`删除`调用失败(无声),因为我们做出了`一`属性不可配置ㄢ

`删除`仅用于从对象中直接删除对象属性(可以删除)ㄢ如果对象属性是最后一个剩余_参考_对某些对象/函数,以及您`删除`它移除参考现在未引用的对象/函数可以被垃圾收集ㄢ但是,它是**不**恰当地考虑`删除`作为一种工具来释放分配的内存作为它在其他语言(如C或C++)ㄢ`删除`只是一个对象属性删除操作ℴℴ仅此而已ㄢ

#### 枚举

我们将在这里提到的最终描述符特性(还有两个,我们在讨论激发子/引导程序时很快处理)`枚举`ㄢ

这个名字可能很明显,但这一特性控制如果属性将显示在某些对象属性的枚举,如`对..`环ㄢ设置`假`让它显示在这样的枚举,尽管它仍然是完全可ㄢ设置`真正的`保持现状ㄢ

所有正常用户定义的属性默认为`枚举`因为这是最常见的你想要的ㄢ但是,如果您想从枚举中隐藏一个特殊属性,请将其设置为`枚举: 假`ㄢ

我们将展示在更多的细节性不久,所以保持心理书签这个话题ㄢ

### 不变性

有时需要制造不可更改的属性或对象(偶然或有意)ㄢES5添加处理,在各种不同的微妙的方式支持ㄢ

值得注意的是**全部的**这些方法创建浅不变性ㄢ也就是说,它们只影响对象及其直接属性特性ㄢ如果一个对象对另一个对象(数组ㄡ对象ㄡ函数等)有引用,则_内容_该对象不受影响,并保持可变ㄢ

```js
myImmutableObject.foo; // [1,2,3]
myImmutableObject.foo.push( 4 );
myImmutableObject.foo; // [1,2,3,4]
```

我们在这个片段中假设`myimmutableobject`作为不变的已经被创建和保护ㄢ但是,也要保护的内容`myimmutableobject.foo`(这是它自己的对象-数组),您还需要做`Foo`不可变的,使用以下功能中的一个或多个ㄢ

**注: **在js程序中创建根深蒂固的不可变对象并不常见ㄢ特殊情况当然可以要求它,但作为一般的设计模式,如果您发现自己想要_密封_或_冻结_您的所有对象,您可能想退一步,重新考虑您的程序设计,以更强大的潜在变化的对象的价值观ㄢ

#### 目标不变

结合`写: 假`和`配置: 假`基本上可以创建一个_常数_(不能更改ㄡ重新定义或删除)作为

```js
var myObject = {};

Object.defineProperty( myObject, "FAVORITE_NUMBER", {
	value: 42,
	writable: false,
	configurable: false
} );
```

#### 防止扩展

如果您想阻止对象添加新属性,但另一方面,只剩下对象属性的其余部分,请调用`对象ㄢpreventextensions(..)`: 

```js
var myObject = {
	a: 2
};

Object.preventExtensions( myObject );

myObject.b = 3;
myObject.b; // undefined
```

在`非严格模式`,创造`B`失败地ㄢ在`严格模式`它抛出一个`TypeError`ㄢ

#### 密封

`对象: 密封(ⅆ)`创建一个"密封ℽ对象,这意味着它接受一个现有对象,本质上调用ㄢ`对象ㄢpreventextensions(..)`在它上,也标志着它的所有现有属性`配置: 假`ㄢ

因此,不仅不能添加任何其他属性,而且不能重新配置或删除任何现有属性(尽管您_可以_仍然修改它们的值)ㄢ

#### 冻结

`对象: 冻结(ⅆ)`创建一个冻结对象,这意味着它需要一个现有对象,本质上是调用ㄢ`对象: 密封(ⅆ)`它,但它也标志着所有的"数据访问ℽ性质`写: 假`这样他们的价值观就不能改变了ㄢ

这种方法是最高级别的不变性,可以实现对象本身,因为它可以防止任何更改的对象或其任何直接的性能(虽然,如上所述,任何引用其他对象的内容不受影响)ㄢ

你可以通过调用"冻结ℽ一个对象ㄢ`对象: 冻结(ⅆ)`在对象上,然后递归地遍历它引用的所有对象(这是迄今为止没有受到影响的),并调用`对象: 冻结(ⅆ)`也在他们身上ㄢ但是要小心,因为这会影响你不想影响的其他(共享的)对象ㄢ

### `[得到]`

关于属性访问是如何执行的,有一个微妙但重要的细节ㄢ

考虑: 

```js
var myObject = {
	a: 2
};

myObject.a; // 2
```

这个`一个MyObjectㄢ`是属性访问,但它不_只是_看看`MyObject`为名称的属性`一`似乎是ㄢ

根据规范,上面的代码实际上执行一个`[得到]`操作(有点像函数调用): `[获得]`)上`MyObject`ㄢ默认的内置`[得到]`对象的操作_第一_检查所请求名称的属性的对象,如果找到它,它将相应返回值ㄢ

然而,这`[得到]`算法定义了其他重要行为ㄢ_不_查找请求名称的属性ㄢ我们将在第5章中检查发生了什么ㄢ_下一个_(遍历`[原型]`链,如果有的话)ㄢ

但这是一个重要的结果`[得到]`操作是,如果不能通过任何方法为请求的属性生成一个值,则返回值ㄢ`未定义`ㄢ

```js
var myObject = {
	a: 2
};

myObject.b; // undefined
```

这种行为不同于您引用的行为ㄢ_变量_通过它们的标识符名称ㄢ如果引用不能在可应用的词法范围查找中解决的变量,则结果不是`未定义`因为它是对象属性,而不是`引用错误`抛出ㄢ

```js
var myObject = {
	a: undefined
};

myObject.a; // undefined

myObject.b; // undefined
```

从一个_价值_这两个引用之间没有区别,它们都导致`未定义`ㄢ然而,这`[得到]`下面的操作,虽然一目了然,但可能为"参考ℽ做了更多的"工作ℽㄢ`MyObjectㄢB`比对参考`一个MyObjectㄢ`ㄢ

仅检查值结果,不能区分某个属性是否存在并保留显式值ㄢ`未定义`或财产是否_不_存在`未定义`默认的返回值是`[得到]`未能显式返回某些内容ㄢ不过,我们很快就会看到你_可以_区分这两种情况ㄢ

### `[ⅆ]`

既然有内部定义`[得到]`从属性获取值的操作应该很明显,也有默认值ㄢ`[ⅆ]`操作ㄢ

可能认为,对对象上的属性赋值只会调用`[ⅆ]`在问题对象上设置或创建该属性ㄢ但情况比那更微妙ㄢ

当调用`[ⅆ]`,如何表现不同,基于多项因素,包括(最impactfully)属性是否已在对象上或不ㄢ

如果属性存在,则`[ⅆ]`算法大致检查: 

1.  是财产的访问说明符(参见"干将与二传手ℽ一节)?**如果是的话,打电话给二传手,如果有的话ㄢ**
2.  属性是数据描述符吗?`可写`属于`假`?**如果是这样,默默地失败`非严格模式`,或扔`TypeError`在里面`严格模式`ㄢ**
3.  否则,将值设置为正常属性ㄢ

如果该属性尚未存在于所讨论的对象上,则`[ⅆ]`操作更加细致入微和复杂ㄢ在讨论第5章时,我们将重新讨论这个场景ㄢ`[原型]`让它更清晰ㄢ

### 干将与二传手

默认的`[ⅆ]`和`[得到]`对象的操作完全控制如何将值设置为现有的或新的属性,或者分别从现有的属性检索ㄢ

**注: **使用该语言的未来/高级功能,可以重写默认值ㄢ`[得到]`或`[ⅆ]`整个对象的操作(不仅仅是每个属性)ㄢ这超出了我们在本书中讨论的范围,但将是

ES5介绍了覆盖这些默认的行动的一部分,不在对象级,但每一个属性,通过使用getter和setterㄢ干将是性能,所谓的隐函数来检索一个值ㄢ设置者实际上称为隐藏函数来设置值的属性ㄢ

当你定义一个属性有一个getter或setter或两者,其定义成为一个"访问描述符ℽ(而不是"数据描述符ℽ)ㄢ对于访问的描述符,`价值`和`可写`描述符的特性是未讨论和忽略的,而JS考虑`设置`和`得到`财产的特征(以及`可配置`和`枚举`)ㄢ

考虑: 

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return 2;
	}
};

Object.defineProperty(
	myObject,	// target
	"b",		// property name
	{			// descriptor
		// define a getter for `b`
		get: function(){ return this.a * 2 },

		// make sure `b` shows up as an object property
		enumerable: true
	}
);

myObject.a; // 2

myObject.b; // 4
```

通过对象字面语法`得到a() { ..}`或者通过明确的定义`defineproperty(..)`在这两种情况下,我们在对象上创建了一个属性,该属性实际上不包含一个值,但是它的访问会自动导致对函数的隐藏函数调用,它返回的任何值都是属性访问的结果ㄢ

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return 2;
	}
};

myObject.a = 3;

myObject.a; // 2
```

因为我们只定义了一个`一`如果我们试图确定`一`稍后,set操作不会抛出错误,但只会默默地把任务扔掉ㄢ即使有一个有效的设置,我们的自定义吸气剂也被硬编码为只返回ㄢ`二`因此,设定操作将是毫无意义的ㄢ

为了使这个场景更为合理,属性也应该由决策器定义,它覆盖默认值ㄢ`[ⅆ]`正如您所期望的,每个属性的操作(又名赋值)ㄢ几乎可以肯定,您总是希望声明吸气剂和二传手(只有一个或另一个经常导致意外/令人惊讶的行为): 

```js
var myObject = {
	// define a getter for `a`
	get a() {
		return this._a_;
	},

	// define a setter for `a`
	set a(val) {
		this._a_ = val * 2;
	}
};

myObject.a = 2;

myObject.a; // 4
```

**注: **在本例中,我们实际存储指定的值ㄢ`二`分配的任务(`[ⅆ]`操作)到另一个变量中`_a_`ㄢ这个`_a_`对于这个例子,名字纯粹是惯例,并暗示它的行为没有什么特别之处ℴℴ它是一个正常属性ㄢ

### 存在

我们在前面展示了一个属性访问`一个MyObjectㄢ`可能导致`未定义`如果显式的值`未定义`存储在或`一`属性根本不存在ㄢ因此,如果两种情况下的值相同,我们又如何区分它们呢?

我们可以问一个对象是否有某种属性ㄢ_没有_要求得到那财产的价值: 

```js
var myObject = {
	a: 2
};

("a" in myObject);				// true
("b" in myObject);				// false

myObject.hasOwnProperty( "a" );	// true
myObject.hasOwnProperty( "b" );	// false
```

这个`在里面`运营商将检查物业是否_在里面_对象,或者如果它存在于任何更高级别的`[原型]`链对象遍历(见第5章)ㄢ通过对比,`hasownproperty(..)`检查看是否_只有_ `MyObject`拥有或不拥有财产_不_咨询`[原型]`链ㄢ我们将在第5章中回顾一下这两种操作之间的重要区别ㄢ`[原型]`详细说明ㄢ

`hasownproperty(..)`对所有正常对象都可以通过委托访问ㄢ`object.prototype`(见第5章)ㄢ但是创建一个不链接到的对象是可能的ㄢ`object.prototype`(通过`对象创建(null)`ℴℴ见第5章)ㄢ在这种情况下,方法调用类似`MyObjectㄢhasownproperty(..)`会失败ㄢ

在这种情况下,执行这种检查的一种更健壮的方法是`对象的原型ㄢhasownpropertyㄢ电话(MyObject,"ℽ)`借用基础`hasownproperty(..)`方法与应用_明确的`这`结合_(见第2章)适用于我们`MyObject`ㄢ

**注: **这个`在里面`运算符具有外观,它将检查是否存在_价值_在容器内,但实际上检查属性名的存在性ㄢ对于数组,这种区别是很重要的,就像尝试检查一样ㄢ`4 [ 2, 4, 6 ]`很强,但这不会像预期的那样ㄢ

#### 枚举

此前,我们简要地说明了"枚举ℽ当我们看着`枚举`属性描述符特性ㄢ让我们重新审视一下,并更仔细地研究它ㄢ

```js
var myObject = { };

Object.defineProperty(
	myObject,
	"a",
	// make `a` enumerable, as normal
	{ enumerable: true, value: 2 }
);

Object.defineProperty(
	myObject,
	"b",
	// make `b` NON-enumerable
	{ enumerable: false, value: 3 }
);

myObject.b; // 3
("b" in myObject); // true
myObject.hasOwnProperty( "b" ); // true

// .......

for (var k in myObject) {
	console.log( k, myObject[k] );
}
// "a" 2
```

你会注意到`MyObjectㄢB`事实上,**存在**并且有一个可访问的值,但它不会出现在`对..`循环(但令人惊讶的是)**是**揭示了`在里面`操作员存在检查)ㄢ这是因为"枚举ℽ的基本意思是"如果将对象的属性遍历ℽ包括ㄢ

**注: ** `对..`循环应用于阵列可以给一些意想不到的结果,在一个数组的计数将不仅包括所有的数字指标,也是任何可枚举属性ㄢ这是个好主意ㄢ`对..`环_只有_关于物体和传统`对于`对数组中存储的值进行数值索引迭代的循环ㄢ

另一种方式,可枚举,不可枚举属性可以区分: 

```js
var myObject = { };

Object.defineProperty(
	myObject,
	"a",
	// make `a` enumerable, as normal
	{ enumerable: true, value: 2 }
);

Object.defineProperty(
	myObject,
	"b",
	// make `b` non-enumerable
	{ enumerable: false, value: 3 }
);

myObject.propertyIsEnumerable( "a" ); // true
myObject.propertyIsEnumerable( "b" ); // false

Object.keys( myObject ); // ["a"]
Object.getOwnPropertyNames( myObject ); // ["a", "b"]
```

`propertyisenumerable(..)`测试给定属性名是否存在ㄢ_直接地_关于对象也是`枚举: 真`ㄢ

`对象(键)`返回所有可枚举属性数组,而`对象ㄢgetownpropertynames(..)`返回一个数组_全部的_性能,可数或不ㄢ

而`在里面`vs.`hasownproperty(..)`他们是否合作不同`[原型]`链条或不,`对象(键)`和`对象ㄢgetownpropertynames(..)`同时检查_只有_指定的直接对象ㄢ

有(目前)没有内置的方式获得一个列表**所有属性**这等于是什么`在里面`操作员测试将参考(遍历整个属性)`[原型]`链,如第5章所述)ㄢ通过递归遍历,可以近似这样的实用程序ㄢ`[原型]`对象的链,对于每个级别,从`对象(键)`只有可数性质ㄢ

## 迭代

这个`对..`循环遍历对象的可枚举的属性列表(包括其`[原型]`链)ㄢ但是如果你想迭代这些值呢?

对于数字索引数组,对值的迭代通常用一个标准来完成ㄢ`对于`循环,如: 

```js
var myArray = [1, 2, 3];

for (var i = 0; i < myArray.length; i++) {
	console.log( myArray[i] );
}
// 1 2 3
```

不过,这不是迭代值,而是迭代索引,然后在索引中使用索引引用值,如`MyArray [我]`ㄢ

ES5还增加了阵列的几个迭代的助手,包括`foreach(..)`,`每(ⅆ)`,和`一些(ⅆ)`ㄢ这些助手中的每一个都接受一个函数回调来应用于数组中的每个元素,不同的是它们分别对回调中返回值的响应ㄢ

`foreach(..)`将迭代数组中的所有值,并忽略任何回调返回值ㄢ`每(ⅆ)`一直走到最后_或_回调返回一个`假`(或"falsyℽ)的价值,而`一些(ⅆ)`一直走到最后_或_回调返回一个`真正的`(或"真相ℽ)的价值ㄢ

这些特殊的返回值在`每(ⅆ)`和`一些(ⅆ)`有点像`打破`正常语句`对于`循环,在结束之前,停止迭代ㄢ

如果您用`对..`环,你也只会在价值是间接的,因为它实际上只有在对象的可枚举属性的迭代,让你访问性能手动获得价值ㄢ

**注: **与用数字有序方式迭代数组索引(与此相反)`对于`循环或其他迭代器,在对象属性上的迭代顺序是**没有保证**在不同的JS引擎之间可能会有所不同ㄢ**不依赖**对于任何需要环境一致性的事物,任何观察到的协议都是不可靠的ㄢ

但是,如果您想要直接遍历值,而不是数组索引(或对象属性)呢?还好,6添加`对..`循环语法,用于遍历数组(以及对象,如果对象定义了自己的自定义迭代器): 

```js
var myArray = [ 1, 2, 3 ];

for (var v of myArray) {
	console.log( v );
}
// 1
// 2
// 3
```

这个`对..`循环要求一个迭代器对象(默认的内部函数称为`@ @迭代器`在规格说明中)_事情_将迭代和循环,然后遍历调用迭代器对象的连续的返回值`next()`方法,每次循环迭代一次ㄢ

数组有内置的`@ @迭代器`,所以`对..`如图所示,它们很容易工作ㄢ但是,让我们使用内置的数组手动迭代数组ㄢ`@ @迭代器`看看它是如何工作的: 

```js
var myArray = [ 1, 2, 3 ];
var it = myArray[Symbol.iterator]();

it.next(); // { value:1, done:false }
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { done:true }
```

**注: **我们得到`@ @迭代器` _内部属性_使用6对象`符号`: `symbol.iterator`ㄢ我们简要地提到`符号`本章前面的语义(参见"计算的属性名称ℽ),因此这里也适用同样的推理ㄢ您总是希望引用这些特殊属性ㄢ`符号`名称引用,而不是它可能保存的特殊值ㄢ此外,尽管名字的含义,`@ @迭代器`是**不是迭代器对象**本身,但**函数返回**迭代器对象ℴℴ一个微妙但重要的细节!

正如上面的代码片段所揭示的,迭代器的返回值`next()`调用是表单的对象ㄢ`{值: ⅆ完成了ⅆ}`,在那里`价值`是当前的迭代值,以及`完成`是一个`布尔`这表明是否有更多的迭代ㄢ

通知的价值`三`被退回`做: 假`乍一看,这似乎很奇怪ㄢ你必须打电话给`next()`第四次(其中`对..`前一段代码中的循环自动执行)`做: 真的`并且知道你真的完成了迭代ㄢ这种怪癖的原因超出了范围,我们在这里讨论的,但是它来自ES6生成器的功能语义ㄢ

数组确实自动迭代`对..`循环,规则对象**没有内置的`@ @迭代器`**ㄢ故意遗漏的原因比我们在这里要研究的要复杂得多,但总的来说,最好不要包含一些可能对未来类型的对象造成麻烦的实现ㄢ

它_是_可以定义自己的默认值`@ @迭代器`对于任何您想迭代的对象ㄢ例如:

```js
var myObject = {
	a: 2,
	b: 3
};

Object.defineProperty( myObject, Symbol.iterator, {
	enumerable: false,
	writable: false,
	configurable: true,
	value: function() {
		var o = this;
		var idx = 0;
		var ks = Object.keys( o );
		return {
			next: function() {
				return {
					value: o[ks[idx++]],
					done: (idx > ks.length)
				};
			}
		};
	}
} );

// iterate `myObject` manually
var it = myObject[Symbol.iterator]();
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { value:undefined, done:true }

// iterate `myObject` with `for..of`
for (var v of myObject) {
	console.log( v );
}
// 2
// 3
```

**注: **我们使用`对象ㄢdefineproperty(..)`定义我们的习惯`@ @迭代器`(所以我们可以使它不可数),但使用`符号`作为一个_计算属性名称_(本章前面提到),我们可以直接声明它,比如`VaR MyObject = {: 2,乙: 3,`ㄢ

每一次的`对..`循环调用`next()`在`MyObject`的迭代器对象,内部指针将前进并返回对象属性列表中的下一个值(参见前面关于对象属性/值的迭代排序的说明)ㄢ

我们刚才演示的迭代是一个简单的按值迭代,但是您可以为您的自定义数据结构定义任意复杂的迭代,如您所见ㄢ自定义迭代器ES6的结合`对..`循环是用于处理用户定义对象的强大的新语法工具ㄢ

例如,一个列表`像素`对象(与`X`和`Y`坐标值)可以决定基于线性距离的迭代ㄢ`(0,0)`如果您的迭代器返回期望值,则为"太远ℽ等等ㄢ`{值: ⅆ}`返回值`next()`调用和`{已完成: 真}`在迭代完成的,6`对..`可以迭代它ㄢ

事实上,您甚至可以生成"无限ℽ迭代器,这些迭代器从不"完成ℽ,并且总是返回一个新值(如随机数ㄡ递增值ㄡ唯一标识符等),尽管您可能不会使用具有无限边界的迭代器ㄢ`对..`循环,因为它永远不会结束,并且会挂起你的程序ㄢ

```js
var randoms = {
	[Symbol.iterator]: function() {
		return {
			next: function() {
				return { value: Math.random() };
			}
		};
	}
};

var randoms_pool = [];
for (var n of randoms) {
	randoms_pool.push( n );

	// don't proceed unbounded!
	if (randoms_pool.length === 100) break;
}
```

这个迭代器会生成随机数"永远ℽ,所以我们小心地只拔出100个值,这样我们的程序就不会挂起了ㄢ

## 回顾(TL;DR)

js中的对象都有一个字面形式(例如`varⅆ}`和一种构造形式(如`var =新数组(..)`)ㄢ字面形式几乎总是首选,但是构建的表单在某些情况下提供更多的创建选项ㄢ

很多人错误地宣称"JavaScript中的所有东西都是一个对象ℽ,但这是不正确的ㄢ对象是6个(或7个,取决于您的视角)原始类型ㄢ对象有子类型,包括`功能`也可以是行为专门化的,比如`[对象数组]`作为表示数组对象子类型的内部标签ㄢ

对象是键/值对的集合ㄢ这些值可以作为属性访问,通过`propnameㄢ`或`["propnameℽ]`语法ㄢ每当访问一个属性时,引擎实际上调用内部默认值ㄢ`[得到]`(和操作`[ⅆ]`用于设置值),它不仅直接在对象上查找属性,而且将遍历对象ㄢ`[原型]`链(见第5章)如果找不到ㄢ

属性具有通过属性描述符控制的某些特性,如`可写`和`可配置`ㄢ此外,对象可以有自己的易变性(和他们的属性)控制的不同程度的永恒性使用`对象ㄢpreventextensions(..)`,`对象: 密封(ⅆ)`,和`对象: 冻结(ⅆ)`ㄢ

性能不一定要包含价值--他们可以访问属性ℽ,用getter和setterㄢ他们也可以是_枚举_或者不,控制它们是否出现在`对..`循环迭代,例如ㄢ

你也可以迭代**价值观**数据结构(数组ㄡ对象等)使用6`对..`语法,它查找内置的或自定义的`@ @迭代器`由一个`next()`方法一次一次地通过数据值ㄢ
