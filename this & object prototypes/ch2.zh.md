
# 你不认识JS: _这_与对象的原型

# 2章: `这`现在一切都有意义了!

在第1章中,我们抛弃了各种误解ㄢ`这`反而学会了`这`是每个函数调用的绑定,完全基于它的函数调用ㄢ**打电话给网站**(如何调用函数)ㄢ

## 打电话给网站

了解`这`绑定,我们必须理解调用站点: 在调用函数的代码中的位置(**不在声明的地方**)ㄢ我们必须检查呼叫站点来回答这个问题: 什么是_这_ `这`提及?

查找调用站点通常是: "从函数中调用函数的位置ℽ,但并不总是那么容易,因为某些编码模式可以掩盖_真正的_打电话给网站ㄢ

重要的是要考虑**调用堆栈**(已调用的堆栈函数,以使我们在执行时到达当前时刻)ㄢ我们关心的呼叫站点是_在里面_调用_之前_当前执行函数ㄢ

让我们演示调用堆栈和调用站点: 

```js
function baz() {
    // call-stack is: `baz`
    // so, our call-site is in the global scope

    console.log( "baz" );
    bar(); // <-- call-site for `bar`
}

function bar() {
    // call-stack is: `baz` -> `bar`
    // so, our call-site is in `baz`

    console.log( "bar" );
    foo(); // <-- call-site for `foo`
}

function foo() {
    // call-stack is: `baz` -> `bar` -> `foo`
    // so, our call-site is in `bar`

    console.log( "foo" );
}

baz(); // <-- call-site for `baz`
```

在分析代码以查找实际调用站点(从调用堆栈)时,要小心,因为这是唯一重要的事情ㄢ`这`结合.

**注: **您可以按照顺序查看函数调用链,在脑海中可视化调用堆栈,正如我们对上面的代码片段中的注释所做的那样ㄢ但这是艰苦的,容易出错的ㄢ另一种查看调用堆栈的方法是在浏览器中使用调试器工具ㄢ大多数现代桌面浏览器都有内置的开发工具,其中包括一个JS调试器ㄢ在上面的代码片段中,您可以在工具的第一行中设置断点ㄢ`foo()`函数,或者简单地插入`调试器;`第一行语句ㄢ当您运行该页时,调试器将暂停此位置,并将显示一个函数列表,该函数列表被调用到该行,这将是您的调用堆栈ㄢ所以,如果你想诊断`这`绑定,使用开发工具获取调用堆栈,然后从顶部找到第二个条目,这将显示真正的调用站点ㄢ

## 不规则

我们现在把注意力转向_怎样_调用站点决定在哪里`这`将在函数执行过程中点ㄢ

您必须检查呼叫站点并确定4条规则中的哪一项适用ㄢ首先我们将独立地解释这4条规则,然后我们将说明它们的优先次序,如果多规则的话ㄢ_能够_应用到调用站点ㄢ

### 默认的绑定

我们将要讨论的第一条规则来自函数调用最常见的情况: 独立函数调用ㄢ想想_这_ `这`当其他规则不适用时,将其作为默认catch规则ㄢ

考虑这个代码: 

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 2
```

如果您还没有意识到,首先要注意的是在全局作用域中声明的变量`var a=2`是同一名称的全局对象属性的同义词ㄢ他们不是彼此的副本,他们_是_彼此.把它看作是同一硬币的两面ㄢ

第二,我们看到`foo()`被称为,`一本ㄢ`解析为全局变量`一`ㄢ为什么?因为在这种情况下,_默认的绑定_对于`这`应用于函数调用等ㄢ`这`在全局对象上ㄢ

我们怎么知道_默认的绑定_规则适用于这里吗?我们检查呼叫站点以查看如何`foo()`被称为ㄢ在我们的片段中,`foo()`调用具有一个普通的ㄡ未修饰的函数引用ㄢ我们将演示的其他规则都不适用于此,所以_默认的绑定_适用于代替ㄢ

如果`严格模式`实际上,全局对象不具备_默认的绑定_,所以`这`而是设置为`未定义`ㄢ

```js
function foo() {
	"use strict";

	console.log( this.a );
}

var a = 2;

foo(); // TypeError: `this` is `undefined`
```

一个微妙但重要的细节是: 即使整体`这`绑定规则完全基于调用站点,全局对象是**只有**对符合条件的_默认的绑定_如果**内容**属于`foo()`是**不**运行`严格模式`;的`严格模式`呼叫站点状态`foo()`是无关紧要的ㄢ

```js
function foo() {
	console.log( this.a );
}

var a = 2;

(function(){
	"use strict";

	foo(); // 2
})();
```

**注: **故意混合`严格模式`与非ℴ`严格模式`在您自己的代码中一起通常是不赞成的ㄢ您的整个程序可能也应该是**严格**或**非严格**ㄢ但是,有时包含有不同的第三方库ㄢ**严格**比你自己的代码更重要,所以要小心这些微妙的兼容性细节ㄢ

### 隐式绑定

另一个需要考虑的规则是: 调用站点是否有上下文对象,也称为拥有对象或包含对象_这些_备用条款可能有点误导ㄢ

考虑: 

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 2
```

首先,注意其中的方式`foo()`然后声明为引用属性添加到`obj`ㄢ不管`foo()`最初宣布_在_ `obj`或稍后作为参考添加(如本片段所示),在这两种情况下都不是**功能**真正的"拥有ℽ或"包含ℽ`obj`对象ㄢ

但是,调用站点_使用_这个`obj`语境**参考**功能,所以你_能够_说`obj`对象"拥有ℽ或"包含ℽ**函数参考**在调用函数时ㄢ

任何`foo()`调用,它前面有一个对象引用`obj`ㄢ当有一个函数引用的上下文对象时,_隐式绑定_规则说它是_那个_应该用于函数调用的对象`这`结合.

因为`obj`是的`这`对于`foo()`呼叫,`一本ㄢ`是同义词`一个目标ㄢ`ㄢ

只有对象属性引用链的上/上一级对调用站点起作用ㄢ例如:

```js
function foo() {
	console.log( this.a );
}

var obj2 = {
	a: 42,
	foo: foo
};

var obj1 = {
	a: 2,
	obj2: obj2
};

obj1.obj2.foo(); // 42
```

#### 隐失

最常见的挫折之一`这`绑定创建的是_隐式绑定_函数失去了绑定,这通常意味着返回到_默认的绑定_,无论是全局对象还是`未定义`,根据`严格模式`ㄢ

考虑: 

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var bar = obj.foo; // function reference/alias!

var a = "oops, global"; // `a` also property on global object

bar(); // "oops, global"
```

尽管`酒吧`似乎是一个参考`obj.foo`事实上,它实际上只是另一个参考ㄢ`Foo`本身ㄢ此外,调用站点是最重要的,调用站点是`bar()`这是一个普通的ㄡ未经修饰的电话,因此_默认的绑定_应用.

当我们考虑传递回调函数时,这种更微妙ㄡ更常见ㄡ更出乎意料的方式就发生了: 

```js
function foo() {
	console.log( this.a );
}

function doFoo(fn) {
	// `fn` is just another reference to `foo`

	fn(); // <-- call-site!
}

var obj = {
	a: 2,
	foo: foo
};

var a = "oops, global"; // `a` also property on global object

doFoo( obj.foo ); // "oops, global"
```

参数传递只是一个隐式赋值,由于我们传递了一个函数,所以它是一个隐式引用赋值,因此最终结果与前面的代码段相同ㄢ

如果您传递回调的函数不是自己的函数,而是内置在语言中,该怎么办?没有差别,同样的结果ㄢ

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var a = "oops, global"; // `a` also property on global object

setTimeout( obj.foo, 100 ); // "oops, global"
```

想想这个粗糙的理论伪实现`settimeout()`从JavaScript环境中提供的内置: 

```js
function setTimeout(fn,delay) {
	// wait (somehow) for `delay` milliseconds
	fn(); // <-- call-site!
}
```

这是很常见的,我们的函数回调_失去_他们的`这`绑定,正如我们刚才看到的ㄢ但另一种方式`这`让我们感到惊讶的是,当我们通过回调函数时,我们有意改变`这`为电话ㄢ流行JavaScript库中的事件处理程序非常喜欢强制回调ㄢ`这`例如,指向触发事件的DOM元素ㄢ虽然有时可能是有用的,其他时间可以彻头彻尾的愤怒ㄢ不幸的是,这些工具很少让你选择ㄢ

无论是哪种方式,`这`意外地发生了变化,您实际上无法控制回调函数引用是如何执行的,因此您无法控制调用站点来提供预期绑定ㄢ我们很快就会看到一种"修复ℽ问题的方法ㄢ_固定_这个`这`ㄢ

### 显式绑定

随着_隐式绑定_正如我们刚才看到的,我们必须对所讨论的对象进行变异,使函数本身包含一个引用,并使用这个属性函数引用间接(隐式)绑定ㄢ`这`对象ㄢ

但是,如果要强制函数调用为某个特定对象使用`这`不在对象上放置属性函数引用?

语言中的"所有ℽ函数有一些实用程序可供他们使用(通过它们)`[原型]`-更多关于稍后的内容),这对这个任务是有用的ㄢ具体而言,功能有`打电话(ⅆ)`和`应用(ⅆ)`方法.从技术上讲,JavaScript宿主环境有时提供的功能是非常特别的(一种放置它的好方法!)他们没有这样的功能ㄢ但那是少数ㄢ提供的大部分功能,当然还有所有您将要创建的函数,都有权访问`打电话(ⅆ)`和`apply(..)`ㄢ

这些实用程序是如何工作的?作为第一个参数,它们都作为一个对象使用`这`,然后调用函数`这`明确规定.既然你直接说出你想要什么`这`是的,我们称之为_显式绑定_ㄢ

考虑: 

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

调用`Foo`具有_显式绑定_通过`调用(..)`允许我们强迫它`这`成为`obj`ㄢ

如果传递一个简单的原始值(类型)`一串`,`布尔`,或`数`)为`这`绑定,原始值被包装在对象表单中ㄢ`新建字符串(..)`,`新布尔(ⅆ)`,或`新号码(..)`分别)ㄢ这通常被称为"拳击ℽㄢ

**注: **相对于`这`结合,`打电话(ⅆ)`和`应用(ⅆ)`是相同的ㄢ他们_做_他们的附加参数的行为不同,但这不是我们目前关心的ㄢ

不幸的是,_显式绑定_单是仍然没有提供任何解决以前提到的问题的功能"失去ℽ它的意图ㄢ`这`捆绑,或只是用框架等把它铺好ㄢ

#### 硬绑定

而是周围的变化模式_显式绑定_真的有诀窍ㄢ考虑: 

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

var bar = function() {
	foo.call( obj );
};

bar(); // 2
setTimeout( bar, 100 ); // 2

// `bar` hard binds `foo`'s `this` to `obj`
// so that it cannot be overriden
bar.call( window ); // 2
```

让我们来研究一下这种变化是如何起作用的ㄢ我们创建一个函数`bar()`在内部,手动调用`调用foo(obj)ㄢ`从而强行调用`Foo`具有`obj`结合`这`ㄢ不管以后如何调用函数`酒吧`它总是手动调用ㄢ`Foo`具有`obj`ㄢ这个绑定既显式又强,所以我们称之为_硬绑定_ㄢ

用函数包装函数的最典型的方法_硬绑定_创建传递的任何参数和接收到的任何返回值的传递: 

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = function() {
	return foo.apply( obj, arguments );
};

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

表达此模式的另一种方法是创建一个可重用的助手: 

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

// simple `bind` helper
function bind(fn, obj) {
	return function() {
		return fn.apply( obj, arguments );
	};
}

var obj = {
	a: 2
};

var bar = bind( foo, obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

S_硬绑定_是一种常见的模式,它有一个内置的效用的ES5: `function.prototype.bind`它是这样用的: 

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = foo.bind( obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

`绑定(ⅆ)`返回一个硬编码的函数,用`这`按指定的上下文设置ㄢ

**注: **截至6,硬约束作用产生的`绑定(ⅆ)`有一个`名称`源自原始的属性_目标函数_ㄢ例如:`绑定(..)`应该有一个`bar.name`价值`"绑定富ℽ`,这是应该出现在堆栈跟踪中的函数调用名称ㄢ

#### API调用"上下文ℽ

许多库的功能,以及JavaScript语言和宿主环境中的许多新的内置函数,都提供了一个可选参数,通常称为"上下文ℽ,它被设计成一个用于不必使用的工作ㄢ`绑定(ⅆ)`确保回调函数使用特定的`这`ㄢ

例如:

```js
function foo(el) {
	console.log( el, this.id );
}

var obj = {
	id: "awesome"
};

// use `obj` as `this` for `foo(..)` calls
[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome
```

在内部,这些功能几乎可以肯定地使用ㄢ_显式绑定_通过`打电话(ⅆ)`或`应用(ⅆ)`为你省下麻烦ㄢ

### `新的`结合

第四条也是最后一条规则`这`绑定要求我们重新考虑JavaScript中有关函数和对象的常见误解ㄢ

在传统的面向类的语言中,"构造函数ℽ是附加在类上的特殊方法,当类实例化时使用`新的`运算符,该类的构造函数称为ㄢ这通常看起来像: 

```js
something = new MyClass(..);
```

JavaScript有一`新的`操作符和使用它的代码模式看起来与我们在面向类语言中看到的基本相同;大多数开发人员假定JavaScript的机制在做类似的工作ㄢ然而,确实存在_无连接_以类为导向的功能隐含`新的`js中的用法ㄢ

首先,让我们重新定义JavaScript中的"构造函数ℽ是什么ㄢ在js中,构造函数是**只是功能**那碰巧是用`新的`接线员在他们前面ㄢ他们不重视的课程,他们也不会实例化一个类ㄢ它们甚至不是特殊类型的函数ㄢ它们只是正则函数,本质上是由`新的`在他们的召唤中ㄢ

例如,`数字(..)`函数作为构造函数,引用es5.1规格: 

> 15.7.2数构造函数
>
> 当数被称为一个新的表达是一个构造函数的一部分: 它初始化新创建的对象ㄢ

所以,几乎所有的OL功能,包括内置的对象函数`数字(..)`(参见第3章)可以调用`新的`在前面,这使函数调用_构造函数调用_ㄢ这是一个重要但微妙的区别: 实际上没有"构造函数ℽ之类的东西,而是构造调用ㄢ_属于_功能.

当函数被调用时`新的`在它前面,也称为构造函数调用,下面的事情是自动完成的: 

1.  一个全新的物体被凭空创造(又名,建造)ㄢ
2.  _新构造的对象是`[原型]`-链接_
3.  新构造的对象被设置为`这`该函数调用的绑定
4.  除非函数返回自己的备用**对象**,的`新的`-调用函数调用_自动_返回新构造的对象ㄢ

步骤1, 3和4适用于我们当前的讨论ㄢ我们现在跳过第2步,回到第5章ㄢ

考虑这个代码: 

```js
function foo(a) {
	this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2
```

通过调用`富(ⅆ)`具有`新的`在前面,我们构建了一个新对象,并将这个新对象设置为`这`为了呼唤`富(ⅆ)`ㄢ**所以`新的`函数调用的最后方式`这`可以绑定ㄢ**我们称之为_新的结合_ㄢ

## 一切都井井有条

现在,我们揭开了绑定的4条规则`这`在函数调用中ㄢ_所有_您需要做的是找到呼叫站点并检查它,看看哪个规则适用ㄢ但是,如果调用站点有多个符合条件的规则呢?必须有一个优先次序,这些规则,所以我们接下来将演示什么样的秩序适用规则ㄢ

应该清楚的是_默认的绑定_是4的最低优先级规则吗?ㄢ我们就把那个放在一边ㄢ

哪一个更为先例?,_隐式绑定_或_显式绑定_?让我们来测试它: 

```js
function foo() {
	console.log( this.a );
}

var obj1 = {
	a: 2,
	foo: foo
};

var obj2 = {
	a: 3,
	foo: foo
};

obj1.foo(); // 2
obj2.foo(); // 3

obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
```

所以,_显式绑定_优先于_隐式绑定_这意味着你应该问**第一**如果_显式绑定_检查前应用_隐式绑定_ㄢ

现在,我们只需要弄清楚_新的结合_符合优先顺序ㄢ

```js
function foo(something) {
	this.a = something;
}

var obj1 = {
	foo: foo
};

var obj2 = {};

obj1.foo( 2 );
console.log( obj1.a ); // 2

obj1.foo.call( obj2, 3 );
console.log( obj2.a ); // 3

var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
```

好啊,_新的结合_比先例更_隐式绑定_ㄢ但是你认为呢?_新的结合_或多或少是先例ㄢ_显式绑定_?

**注: ** `新的`和`呼叫`/`应用`不能一起使用,所以`新富ㄢ电话(obj1)`不允许,测试_新的结合_直接针对_显式绑定_ㄢ但我们仍然可以使用_硬绑定_测试这两条规则的优先级ㄢ

在我们在代码清单中探索之前,请回想一下_硬绑定_身体工作,那是`函数ㄢ原型ㄢ绑定(ⅆ)`创建一个新的包装器函数,该函数被硬编码以忽略其自身ㄢ`这`绑定(不管它是什么),U

通过这种推理,似乎可以假定_硬绑定_(这是一种_显式绑定_)比先例更_新的结合_因此不能被覆盖`新的`ㄢ

让我们检查一下: 

```js
function foo(something) {
	this.a = something;
}

var obj1 = {};

var bar = foo.bind( obj1 );
bar( 2 );
console.log( obj1.a ); // 2

var baz = new bar( 3 );
console.log( obj1.a ); // 2
console.log( baz.a ); // 3
```

哇!`酒吧`坚决反对`obj1`,但`新酒吧(3)`做**不**改变`以此,`成为`三`正如我们所预料的ㄢ相反,该_硬约束_(对`obj1`)打电话`酒吧(ⅆ)` **_是_**能够被覆盖`新的`ㄢ自`新的`应用,我们得到了新创建的对象,我们命名`巴兹`事实上,我们看到`巴兹,`有价值`三`ㄢ

如果你回到我们的"假ℽ绑定助手,这应该是令人惊讶的: 

```js
function bind(fn, obj) {
	return function() {
		fn.apply( obj, arguments );
	};
}
```

如果您对帮助程序的代码如何工作的原因进行了分析,那么它就没有办法`新的`运算符调用覆盖硬绑定`obj`正如我们刚才观察到的ㄢ

而内置`函数ㄢ原型ㄢ绑定(ⅆ)`由于ES5比较复杂,相当一部分,事实上ㄢ这里是(略格式化)提供的MDN页polyfill`绑定(ⅆ)`: 

```js
if (!Function.prototype.bind) {
	Function.prototype.bind = function(oThis) {
		if (typeof this !== "function") {
			// closest thing possible to the ECMAScript 5
			// internal IsCallable function
			throw new TypeError( "Function.prototype.bind - what " +
				"is trying to be bound is not callable"
			);
		}

		var aArgs = Array.prototype.slice.call( arguments, 1 ),
			fToBind = this,
			fNOP = function(){},
			fBound = function(){
				return fToBind.apply(
					(
						this instanceof fNOP &&
						oThis ? this : oThis
					),
					aArgs.concat( Array.prototype.slice.call( arguments ) )
				);
			}
		;

		fNOP.prototype = this.prototype;
		fBound.prototype = new fNOP();

		return fBound;
	};
}
```

**注: **这个`绑定(ⅆ)`polyfill上面显示不同于内置`绑定(ⅆ)`在ES5相对于硬绑定功能,将使用`新的`(见下文)为什么有用)ㄢ因为没有一个polyfill不能创建一个函数`原型ㄢ`由于内置的实用工具,有一些微妙的间接近似相同的行为ㄢ如果你打算使用,小心踩`新的`与硬约束函数和你依靠这polyfillㄢ

允许的部分`新的`最重要的是: 

```js
this instanceof fNOP &&
oThis ? this : oThis

// ... and:

fNOP.prototype = this.prototype;
fBound.prototype = new fNOP();
```

我们实际上不会深入解释这种欺骗是如何工作的(它很复杂,超出了我们的范围),但本质上,效用决定了硬绑定函数是否被调用了ㄢ`新的`(使新构造的物体成为它的)`这`)如果是的话,它使用_那个_新创建的`这`而不是先前指定的_硬绑定_对于`这`ㄢ

为什么`新的`能够凌驾_硬绑定_有用吗?

这种行为的主要原因是创建一个函数(可以用于`新的`用于构造对象)本质上忽略了`这` _硬绑定_但它预置函数的一些或全部参数ㄢ能力之一`绑定(ⅆ)`是在第一次之后传递的参数吗?`这`结合参数默认为标准参数的基本功能(技术上称为"局部应用ℽ,这是一个集"讨好ℽ)ㄢ

例如:

```js
function foo(p1,p2) {
	this.val = p1 + p2;
}

// using `null` here because we don't care about
// the `this` hard-binding in this scenario, and
// it will be overridden by the `new` call anyway!
var bar = foo.bind( null, "p1" );

var baz = new bar( "p2" );

baz.val; // p1p2
```

### 确定`这`

现在,我们可以总结一下决定的规则ㄢ`这`从函数调用的站点,按照它们的优先级顺序ㄢ按照这个顺序问这些问题,第一条规则适用时停止ㄢ

1.  调用的函数是`新的`(**新的结合**)?如果是这样的话,`这`是新构建的对象ㄢ

    `VaR的酒吧=新foo()`

2.  调用的函数是`呼叫`或`应用`(**显式绑定**),甚至藏在里面`绑定` _硬绑定_?如果是这样的话,`这`是显式指定的对象ㄢ

    `VaR的酒吧= foo调用(obj2)ㄢ`

3.  函数是用上下文调用的吗?**隐式绑定**,也称为拥有或包含对象?如果是这样的话,`这`是_那个_上下文对象ㄢ

    `var obj1 foo()吧=ㄢ`

4.  否则,默认`这`(**默认的绑定**)ㄢ如果在`严格模式`,接`未定义`否则选择`全球的`对象ㄢ

    `VaR吧= foo()`

够了就要这些ㄢ那是_它所需要的_理解规则`这`正常函数调用的绑定ㄢ好...几乎.

## 结合异常

像往常一样,有一些_例外_遵守规则ㄢ

这个`这`-绑定行为在某些情况下是令人惊讶的,在这里您打算使用不同的绑定,但最终会得到绑定行为ㄢ_默认的绑定_规则(见上一页)ㄢ

### 忽略`这`

如果你通过`无效的`或`未定义`作为一个`这`结合参数`呼叫`,`应用`,或`绑定`这些值被有效地忽略,而不是_默认的绑定_规则适用于调用ㄢ

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo.call( null ); // 2
```

你为什么故意传递类似的东西?`无效的`对于一个`这`结合?

使用起来很普遍ㄢ`应用(ⅆ)`将数组值扩展为函数调用的参数ㄢ同样,`绑定(ⅆ)`可以咖喱参数(预设值),这可能是非常有益的ㄢ

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// spreading out array as parameters
foo.apply( null, [2, 3] ); // a:2, b:3

// currying with `bind(..)`
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
```

这两个实用程序都需要`这`第一个参数的绑定ㄢ如果问题中的函数不关心`这`您需要一个占位符值,以及`无效的`似乎是一个合理的选择,如本片段所示ㄢ

**注: **我们不要盖在这本书中,但6有`ⅆ`传播算子,将让你在语法上"传播ℽ作为参数的数组不需要`apply(..)`,如`富(ⅆⅆ[1,2])`,等于`富(1,2)`ℴℴ语法避免`这`如果不必要绑定ㄢ不幸的是,有没有为讨好ES6句法的替代品,所以`这`参数的`绑定(ⅆ)`呼叫仍需注意ㄢ

然而,总是有一些隐藏的"危险ℽㄢ`无效的`当你不在乎`这`结合.如果您曾经对函数调用(例如,您不控制的第三方库函数)使用该函数,那么该函数_做_Mak`这`参考的_默认的绑定_规则意味着它可能会不经意地引用(或者更糟,变异!)这个`全球的`对象(`窗口`在浏览器中)ㄢ

显然,这样的陷阱会导致各种各样的_很难_诊断/跟踪错误ㄢ

#### 更安全的`这`

也许某种更"安全ℽ的做法是传递一个专门设置的对象ㄢ`这`它保证不会成为一个在程序中产生问题的副作用的对象ㄢ从网络借贷术语(和军队),我们可以创建一个"非军事区ℽ(非军事区)的对象ℴℴ没有什么比一个空的更特殊,非授权(见章节5和6)的对象ㄢ

如果我们总是通过DMZ对象的忽视`这`绑定,我们不认为我们需要关心,我们相信任何隐藏/意外使用的`这`将被限制为空的对象,这使我们的计划`全球的`反对副作用ㄢ

因为这个对象是完全空的,我个人喜欢给它一个变量名ㄢ`ø`(用于空集合的小写数学符号)ㄢ在许多键盘上(如Mac上的美国布局),这个符号很容易输入ㄢ`⌥`+`o`(期权+`o`)ㄢ有些系统还允许你设置特定符号的热键ㄢ如果你不喜欢`ø`符号,或者你的键盘不能像打字那样容易,你当然可以把它叫做你想要的任何东西ㄢ

无论你怎么称呼它,最简单的方法就是把它设置为**完全空**是`对象创建(null)`(见第5章)ㄢ`对象创建(null)`类似于`{ }`但没有代表团`object.prototype`所以它"比ℽ更"空ℽ`{ }`ㄢ

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// our DMZ empty object
var ø = Object.create( null );

// spreading out array as parameters
foo.apply( ø, [2, 3] ); // a:2, b:3

// currying with `bind(..)`
var bar = foo.bind( ø, 2 );
bar( 3 ); // a:2, b:3
```

不仅功能上更"安全ℽ,还有一种文体上的好处ㄢ`ø`它在语义上表达了"我想要`这`比"更清楚ℽ`无效的`可能ㄢ但是,无论你喜欢你的DMZ对象名称ㄢ

### 间接寻址

另一件事要注意的是你可以(有意或不!)为函数创建"间接引用ℽ,在这种情况下,当调用该函数引用时,_默认的绑定_规则也适用ㄢ

最常见的方式之一_间接引用_发生是从一项任务: 

```js
function foo() {
	console.log( this.a );
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };

o.foo(); // 3
(p.foo = o.foo)(); // 2
```

这个_结果值_赋值表达式的`p.foo = o.foo`是对底层函数对象的引用ㄢ因此,有效的调用站点仅仅是`foo()`,不`foo() P.`或`foo() O.`正如你所预料的ㄢ根据上述规则,_默认的绑定_规则适用ㄢ

提醒: 不管您如何使用_默认的绑定_的规则,`严格模式`现状**内容**调用函数使`这`引用ℴℴ而不是函数调用站点ℴℴ决定_默认的绑定_值: 要么`全球的`对象如果非ℴ`严格模式`或`未定义`如果在`严格模式`ㄢ

### 软化的结合

我们早就看到了_硬绑定_是防止函数调用回落到_默认的绑定_通过将规则绑定到某个特定位置而不经意地规则ㄢ`这`(除非你使用`新的`重写它!)问题是,_硬绑定_大大降低了功能的灵活性,避免了手工操作ㄢ`这`覆盖_隐式绑定_甚至以后_显式绑定_尝试.

如果有一种方法可以提供不同的默认值,那就更好了ㄢ_默认的绑定_(不`全球的`或`未定义`,但仍保留手动功能ㄢ`这`绑定通过_隐式绑定_或_显式绑定_技术ㄢ

我们可以构建一个所谓的_软约束_模拟我们想要的行为的实用程序ㄢ

```js
if (!Function.prototype.softBind) {
	Function.prototype.softBind = function(obj) {
		var fn = this,
			curried = [].slice.call( arguments, 1 ),
			bound = function bound() {
				return fn.apply(
					(!this ƜƜ
						(typeof window !== "undefined" &&
							this === window) ƜƜ
						(typeof global !== "undefined" &&
							this === global)
					) ? obj : this,
					curried.concat.apply( curried, arguments )
				);
			};
		bound.prototype = Object.create( fn.prototype );
		return bound;
	};
}
```

这个`softbind(..)`使用这里提供的工作类似于内置的ES5`绑定(ⅆ)`公用事业,除了我们_软约束_行为ㄢ它将指定的函数包装在检查`这`在通话时间,如果它的`全球的`或`未定义`使用预先指定的替换_违约_(`obj`)ㄢ否则`这`未触及ㄢ它还提供了可选的难题(见`绑定(ⅆ)`早期讨论)ㄢ

让我们演示一下它的用法: 

```js
function foo() {
   console.log("name: " + this.name);
}

var obj = { name: "obj" },
    obj2 = { name: "obj2" },
    obj3 = { name: "obj3" };

var fooOBJ = foo.softBind( obj );

fooOBJ(); // name: obj

obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2   <---- look!!!

fooOBJ.call( obj3 ); // name: obj3   <---- look!

setTimeout( obj2.foo, 10 ); // name: obj   <---- falls back to soft-binding
```

软约束版本的`foo()`功能可以手动`这`绑定到`obj2`或`OBJ3`如图所示,但它可以追溯到`obj`如果_默认的绑定_否则将适用ㄢ

## 词汇`这`

正常的功能遵守我们刚才提到的4条规则ㄢ但6介绍一种特殊的功能,不使用这些规则: 箭头功能ㄢ

箭头函数不是由`功能`关键字,但由`= >`所谓的"胖箭头ℽ操作符ㄢ而不是使用四标准`这`规则,箭头函数采用`这`从封闭(函数或全局)范围绑定ㄢ

让我们举例说明箭头函数的词法范围: 

```js
function foo() {
	// return an arrow function
	return (a) => {
		// `this` here is lexically adopted from `foo()`
		console.log( this.a );
	};
}

var obj1 = {
	a: 2
};

var obj2 = {
	a: 3
};

var bar = foo.call( obj1 );
bar.call( obj2 ); // 2, not 3!
```

创建的箭头函数`foo()`词汇捕捉任何`foo()`S`这`是在它的通话时间ㄢ自`foo()`是`这`绑定到`obj1`,`酒吧`(返回箭头函数的引用)也将是`这`绑定到`obj1`ㄢ不能重写箭头函数的词汇绑定(甚至使用`新的`!)ㄢ

最常见的使用情况,将有可能在回调的使用,如事件处理程序

```js
function foo() {
	setTimeout(() => {
		// `this` here is lexically adopted from `foo()`
		console.log( this.a );
	},100);
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

而箭头函数提供了一种替代使用`绑定(ⅆ)`关于确保其功能的`这`看起来很有吸引力,重要的是要注意它们本质上正在破坏传统ㄢ`这`有利于机构更广泛了解词法作用域ㄢpre-es6,我们已经做了一个相当普遍的模式,基本上是从6箭头功能的精神几乎没有区别: 

```js
function foo() {
	var self = this; // lexical capture of `this`
	setTimeout( function(){
		console.log( self.a );
	}, 100 );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

而`自本`箭头函数似乎是不想使用的好的"解决方案ℽㄢ`绑定(ⅆ)`他们本质上是在逃避`这`而不是理解和拥抱它ㄢ

如果你发现自己在写作`这`风格代码,但大多数或所有的时间,你打败了`这`机制与词汇`自本`或箭头功能"把戏ℽ,也许你也应该: 

1.  只使用词法范围,忘记虚假的借口ㄢ`这`风格代码ㄢ

2.  拥抱`这`-完全机制式,包括使用`绑定(ⅆ)`必要时尽量避免`自本`箭头功能"词汇ℽ这个技巧ㄢ

一个程序可以有效地使用这两种代码类型(词汇和`这`但是,在同一个函数中,实际上对于相同类型的查找,混合这两种机制通常要求更难维护代码,并且可能工作太难而不聪明ㄢ

## 回顾(TL;DR)

确定`这`对执行函数的绑定需要找到该函数的直接调用站点ㄢ一旦检查,四个规则可以应用到调用站点,在_这_优先顺序: 

1.  称为`新的`?使用新构建的对象ㄢ

2.  称为`呼叫`或`应用`(或`绑定`)?使用指定的对象ㄢ

3.  具有拥有调用的上下文对象调用吗?使用上下文对象ㄢ

4.  违约:`未定义`在里面`严格模式`,否则全局对象ㄢ

小心偶然的/无意的调用_默认的绑定_规则ㄢ如果你想"安全ℽ地忽略一个`这`结合"DMZℽ对象`ø=对象创建(空)ㄢ`是一个很好的占位符值,可以保护`全球的`来自意外副作用的对象ㄢ

而不是四个标准约束的规则,6箭头的函数使用词法作用域为`这`绑定,这意味着它们采用`这`从封闭函数调用中绑定(无论它是什么)ㄢ它们本质上是一种句法替换ㄢ`自本`在pre-es6编码ㄢ
