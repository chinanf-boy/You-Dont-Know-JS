
# 你不认识JS：_这_与对象的原型

# 2章：`这`现在一切都有意义了！

在第1章中，我们抛弃了各种误解。`这`反而学会了`这`是每个函数调用的绑定，完全基于它的函数调用。**打电话给网站**（如何调用函数）。

## 打电话给网站

了解`这`绑定，我们必须理解调用站点：在调用函数的代码中的位置（**不在声明的地方**）。我们必须检查呼叫站点来回答这个问题：什么是_这_这`提及？`查找调用站点通常是：“从函数中调用函数的位置”，但并不总是那么容易，因为某些编码模式可以掩盖

真正的_打电话给网站。_重要的是要考虑

调用堆栈**（已调用的堆栈函数，以使我们在执行时到达当前时刻）。我们关心的呼叫站点是**在里面_调用_之前_当前执行函数。_让我们演示调用堆栈和调用站点：

在分析代码以查找实际调用站点（从调用堆栈）时，要小心，因为这是唯一重要的事情。

```js
function baz() {
    // call-stack is: `baz`
    // so, our call-site is in the global scope

    console.log( "baz" );
    bar(); // <-- call-site for `bar`
}

function bar() {
    // call-stack is: `baz` -> `bar`
    // so, our call-site is in `baz`

    console.log( "bar" );
    foo(); // <-- call-site for `foo`
}

function foo() {
    // call-stack is: `baz` -> `bar` -> `foo`
    // so, our call-site is in `bar`

    console.log( "foo" );
}

baz(); // <-- call-site for `baz`
```

这`结合.`注：

**您可以按照顺序查看函数调用链，在脑海中可视化调用堆栈，正如我们对上面的代码片段中的注释所做的那样。但这是艰苦的，容易出错的。另一种查看调用堆栈的方法是在浏览器中使用调试器工具。大多数现代桌面浏览器都有内置的开发工具，其中包括一个JS调试器。在上面的代码片段中，您可以在工具的第一行中设置断点。**foo()`函数，或者简单地插入`调试器；`第一行语句。当您运行该页时，调试器将暂停此位置，并将显示一个函数列表，该函数列表被调用到该行，这将是您的调用堆栈。所以，如果你想诊断`这`绑定，使用开发工具获取调用堆栈，然后从顶部找到第二个条目，这将显示真正的调用站点。`不规则

## 我们现在把注意力转向

怎样_调用站点决定在哪里_这`将在函数执行过程中点。`您必须检查呼叫站点并确定4条规则中的哪一项适用。首先我们将独立地解释这4条规则，然后我们将说明它们的优先次序，如果多规则的话。

能够_应用到调用站点。_默认的绑定

### 我们将要讨论的第一条规则来自函数调用最常见的情况：独立函数调用。想想

这_这_当其他规则不适用时，将其作为默认catch规则。`考虑这个代码：`如果您还没有意识到，首先要注意的是在全局作用域中声明的变量

var a＝2

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 2
```

是同一名称的全局对象属性的同义词。他们不是彼此的副本，他们`是`彼此.把它看作是同一硬币的两面。_Secondly, we see that when_foo()

被称为，`一本。`解析为全局变量`一`。为什么？因为在这种情况下，`默认的绑定`对于_这_应用于函数调用等。`这`在全局对象上。`我们怎么知道`默认的绑定

规则适用于这里吗？我们检查呼叫站点以查看如何_foo()_被称为。在我们的片段中，`foo()`调用具有一个普通的、未修饰的函数引用。我们将演示的其他规则都不适用于此，所以`默认的绑定`适用于代替。_如果_严格模式

实际上，全局对象不具备`默认的绑定`，所以_这_而是设置为`未定义`。`一个微妙但重要的细节是：即使整体`这

```js
function foo() {
	"use strict";

	console.log( this.a );
}

var a = 2;

foo(); // TypeError: `this` is `undefined`
```

绑定规则完全基于调用站点，全局对象是`只有`对符合条件的**默认的绑定**如果_内容_属于**foo()**是`不`运行**严格模式**；的`严格模式`呼叫站点状态`foo()`是无关紧要的。`注：`故意混合

```js
function foo() {
	console.log( this.a );
}

var a = 2;

(function(){
	"use strict";

	foo(); // 2
})();
```

**严格模式**与非—`严格模式`在您自己的代码中一起通常是不赞成的。您的整个程序可能也应该是`严格`或**非严格**。但是，有时包含有不同的第三方库。**严格**比你自己的代码更重要，所以要小心这些微妙的兼容性细节。**隐式绑定**另一个需要考虑的规则是：调用站点是否有上下文对象，也称为拥有对象或包含对象

### 这些

备用条款可能有点误导。_考虑：_首先，注意其中的方式

foo()

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 2
```

然后声明为引用属性添加到`obj`。不管`foo()`最初宣布`在`obj_或稍后作为参考添加（如本片段所示），在这两种情况下都不是_功能`真正的“拥有”或“包含”`obj**对象。**但是，调用站点`使用`这个

obj_语境_参考`功能，所以你`能够**说**obj_对象“拥有”或“包含”_函数参考`在调用函数时。`对象“拥有”或“包含”**函数参考**在调用函数时。

无论你选择什么来称呼这个模式，在那一点上`foo()`调用，它前面有一个对象引用`obj`。当有一个函数引用的上下文对象时，_隐式绑定_规则说它是_那个_应该用于函数调用的对象`这`结合.

因为`obj`是的`这`对于`foo()`呼叫，`一本。`是同义词`一个目标。`。

只有对象属性引用链的上/上一级对调用站点起作用。例如:

```js
function foo() {
	console.log( this.a );
}

var obj2 = {
	a: 42,
	foo: foo
};

var obj1 = {
	a: 2,
	obj2: obj2
};

obj1.obj2.foo(); // 42
```

#### 隐失

最常见的挫折之一`这`绑定创建的是_隐式绑定_函数失去了绑定，这通常意味着返回到_默认的绑定_，无论是全局对象还是`未定义`，根据`严格模式`。

考虑：

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var bar = obj.foo; // function reference/alias!

var a = "oops, global"; // `a` also property on global object

bar(); // "oops, global"
```

尽管`酒吧`似乎是一个参考`obj.foo`事实上，它实际上只是另一个参考。`Foo`本身。此外，调用站点是最重要的，调用站点是`bar()`这是一个普通的、未经修饰的电话，因此_默认的绑定_应用.

当我们考虑传递回调函数时，这种更微妙、更常见、更出乎意料的方式就发生了：

```js
function foo() {
	console.log( this.a );
}

function doFoo(fn) {
	// `fn` is just another reference to `foo`

	fn(); // <-- call-site!
}

var obj = {
	a: 2,
	foo: foo
};

var a = "oops, global"; // `a` also property on global object

doFoo( obj.foo ); // "oops, global"
```

参数传递只是一个隐式赋值，由于我们传递了一个函数，所以它是一个隐式引用赋值，因此最终结果与前面的代码段相同。

如果您传递回调的函数不是自己的函数，而是内置在语言中，该怎么办？没有差别，同样的结果。

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var a = "oops, global"; // `a` also property on global object

setTimeout( obj.foo, 100 ); // "oops, global"
```

想想这个粗糙的理论伪实现`settimeout()`从JavaScript环境中提供的内置：

```js
function setTimeout(fn,delay) {
	// wait (somehow) for `delay` milliseconds
	fn(); // <-- call-site!
}
```

这是很常见的，我们的函数回调_失去_他们的`这`绑定，正如我们刚才看到的。但另一种方式`这`让我们感到惊讶的是，当我们通过回调函数时，我们有意改变`这`为电话。流行JavaScript库中的事件处理程序非常喜欢强制回调。`这`例如，指向触发事件的DOM元素。虽然有时可能是有用的，其他时间可以彻头彻尾的愤怒。不幸的是，这些工具很少让你选择。

无论是哪种方式，`这`意外地发生了变化，您实际上无法控制回调函数引用是如何执行的，因此您无法控制调用站点来提供预期绑定。我们很快就会看到一种“修复”问题的方法。_固定_这个`这`。

### 显式绑定

随着_隐式绑定_正如我们刚才看到的，我们必须对所讨论的对象进行变异，使函数本身包含一个引用，并使用这个属性函数引用间接（隐式）绑定。`这`对象。

但是，如果要强制函数调用为某个特定对象使用`这`不在对象上放置属性函数引用？

语言中的“所有”函数有一些实用程序可供他们使用（通过它们）`[原型]`-更多关于稍后的内容），这对这个任务是有用的。具体而言，功能有`打电话（…）`和`应用（…）`方法.从技术上讲，JavaScript宿主环境有时提供的功能是非常特别的（一种放置它的好方法！）他们没有这样的功能。但那是少数。提供的大部分功能，当然还有所有您将要创建的函数，都有权访问`打电话（…）`和`应用（…）`。

这些实用程序是如何工作的？作为第一个参数，它们都作为一个对象使用`这`，然后调用函数`这`明确规定.既然你直接说出你想要什么`这`是的，我们称之为_显式绑定_。

考虑：

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

调用`Foo`具有_显式绑定_通过`调用（..）`允许我们强迫它`这`成为`obj`。

如果传递一个简单的原始值（类型）`一串`，`布尔`，或`数`）为`这`绑定，原始值被包装在对象表单中。`新建字符串（..）`，`新布尔（…）`，或`新号码（..）`分别）。这通常被称为“拳击”。

**注：**相对于`这`结合,`打电话（…）`和`应用（…）`是相同的。他们_做_他们的附加参数的行为不同，但这不是我们目前关心的。

不幸的是，_显式绑定_单是仍然没有提供任何解决以前提到的问题的功能“失去”它的意图。`这`捆绑，或只是用框架等把它铺好。

#### 硬绑定

而是周围的变化模式_显式绑定_真的有诀窍。考虑：

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

var bar = function() {
	foo.call( obj );
};

bar(); // 2
setTimeout( bar, 100 ); // 2

// `bar` hard binds `foo`'s `this` to `obj`
// so that it cannot be overriden
bar.call( window ); // 2
```

让我们来研究一下这种变化是如何起作用的。我们创建一个函数`bar()`在内部，手动调用`调用foo（obj）。`从而强行调用`Foo`具有`obj`结合`这`。不管以后如何调用函数`酒吧`它总是手动调用。`Foo`具有`obj`。这个绑定既显式又强，所以我们称之为_硬绑定_。

用函数包装函数的最典型的方法_硬绑定_创建传递的任何参数和接收到的任何返回值的传递：

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = function() {
	return foo.apply( obj, arguments );
};

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

表达此模式的另一种方法是创建一个可重用的助手：

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

// simple `bind` helper
function bind(fn, obj) {
	return function() {
		return fn.apply( obj, arguments );
	};
}

var obj = {
	a: 2
};

var bar = bind( foo, obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

自_硬绑定_是一种常见的模式，它有一个内置的效用的ES5：`function.prototype.bind`它是这样用的：

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = foo.bind( obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

`绑定（…）`返回一个硬编码的函数，用`这`按指定的上下文设置。

**注：**截至6，硬约束作用产生的`绑定（…）`有一个`名称`源自原始的属性_目标函数_。例如:`绑定（..）`应该有一个`bar.name`价值`“绑定富”`，这是应该出现在堆栈跟踪中的函数调用名称。

#### API调用“上下文”

许多库的功能，以及JavaScript语言和宿主环境中的许多新的内置函数，都提供了一个可选参数，通常称为“上下文”，它被设计成一个用于不必使用的工作。`绑定（…）`确保回调函数使用特定的`这`。

例如:

```js
function foo(el) {
	console.log( el, this.id );
}

var obj = {
	id: "awesome"
};

// use `obj` as `this` for `foo(..)` calls
[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome
```

在内部，这些功能几乎可以肯定地使用。_显式绑定_通过`打电话（…）`或`应用（…）`为你省下麻烦。

### `新的`结合

第四条也是最后一条规则`这`绑定要求我们重新考虑JavaScript中有关函数和对象的常见误解。

在传统的面向类的语言中，“构造函数”是附加在类上的特殊方法，当类实例化时使用`新的`运算符，该类的构造函数称为。这通常看起来像：

```js
something = new MyClass(..);
```

JavaScript有一`新的`操作符和使用它的代码模式看起来与我们在面向类语言中看到的基本相同；大多数开发人员假定JavaScript的机制在做类似的工作。然而，确实存在_无连接_以类为导向的功能隐含`新的`js中的用法。

首先，让我们重新定义JavaScript中的“构造函数”是什么。在js中，构造函数是**只是功能**那碰巧是用`新的`接线员在他们前面。他们不重视的课程，他们也不会实例化一个类。它们甚至不是特殊类型的函数。它们只是正则函数，本质上是由`新的`在他们的召唤中。

例如，`数字（..）`函数作为构造函数，引用es5.1规格：

> 15.7.2数构造函数
>
> 当数被称为一个新的表达是一个构造函数的一部分：它初始化新创建的对象。

所以，几乎所有的OL功能，包括内置的对象函数`数字（..）`（参见第3章）可以调用`新的`在前面，这使函数调用_构造函数调用_。这是一个重要但微妙的区别：实际上没有“构造函数”之类的东西，而是构造调用。_属于_功能.

当函数被调用时`新的`在它前面，也称为构造函数调用，下面的事情是自动完成的：

1.  一个全新的物体被凭空创造（又名，建造）。
2.  _新构造的对象是`[原型]`-链接_
3.  新构造的对象被设置为`这`该函数调用的绑定
4.  除非函数返回自己的备用**对象**，的`新的`-调用函数调用_自动_返回新构造的对象。

步骤1, 3和4适用于我们当前的讨论。我们现在跳过第2步，回到第5章。

考虑这个代码：

```js
function foo(a) {
	this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2
```

通过调用`富（…）`具有`新的`在前面，我们构建了一个新对象，并将这个新对象设置为`这`为了呼唤`富（…）`。**所以`新的`函数调用的最后方式`这`可以绑定。**我们称之为_新的结合_。

## 一切都井井有条

现在，我们揭开了绑定的4条规则`这`在函数调用中。_所有_您需要做的是找到呼叫站点并检查它，看看哪个规则适用。但是，如果调用站点有多个符合条件的规则呢？必须有一个优先次序，这些规则，所以我们接下来将演示什么样的秩序适用规则。

应该清楚的是_默认的绑定_是4的最低优先级规则吗？。我们就把那个放在一边。

哪一个更为先例？，_隐式绑定_或_显式绑定_？让我们来测试它：

```js
function foo() {
	console.log( this.a );
}

var obj1 = {
	a: 2,
	foo: foo
};

var obj2 = {
	a: 3,
	foo: foo
};

obj1.foo(); // 2
obj2.foo(); // 3

obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
```

所以，_显式绑定_优先于_隐式绑定_这意味着你应该问**第一**如果_显式绑定_检查前应用_隐式绑定_。

现在，我们只需要弄清楚_新的结合_符合优先顺序。

```js
function foo(something) {
	this.a = something;
}

var obj1 = {
	foo: foo
};

var obj2 = {};

obj1.foo( 2 );
console.log( obj1.a ); // 2

obj1.foo.call( obj2, 3 );
console.log( obj2.a ); // 3

var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
```

好啊,_新的结合_比先例更_隐式绑定_。但是你认为呢？_新的结合_或多或少是先例。_显式绑定_？

**注：**新的`和`呼叫`/`应用`不能一起使用，所以`新富。电话（obj1）`不允许，测试`新的结合_直接针对_显式绑定_。但我们仍然可以使用_硬绑定_测试这两条规则的优先级。_在我们在代码清单中探索之前，请回想一下

硬绑定_体力劳动_身体工作，那是`函数。原型。绑定（…）`创建一个新的包装器函数，该函数被硬编码以忽略其自身。`这`绑定（不管它是什么），使用我们提供的手册。

通过这种推理，似乎可以假定_硬绑定_（这是一种_显式绑定_）比先例更_新的结合_因此不能被覆盖`新的`。

让我们检查一下：

```js
function foo(something) {
	this.a = something;
}

var obj1 = {};

var bar = foo.bind( obj1 );
bar( 2 );
console.log( obj1.a ); // 2

var baz = new bar( 3 );
console.log( obj1.a ); // 2
console.log( baz.a ); // 3
```

哇！`酒吧`坚决反对`obj1`，但`新酒吧（3）`做**不**改变`以此，`成为`三`正如我们所预料的。相反，该_硬约束_（对`obj1`）打电话`酒吧（…）`是**_能够被覆盖_**新的`。自`新的`应用，我们得到了新创建的对象，我们命名`巴兹`事实上，我们看到`巴兹，`有价值`三`。`如果你回到我们的“假”绑定助手，这应该是令人惊讶的：

如果您对帮助程序的代码如何工作的原因进行了分析，那么它就没有办法

```js
function bind(fn, obj) {
	return function() {
		fn.apply( obj, arguments );
	};
}
```

新的`运算符调用覆盖硬绑定`obj`正如我们刚才观察到的。`而内置

函数。原型。绑定（…）`由于ES5比较复杂，相当一部分，事实上。这里是（略格式化）提供的MDN页polyfill`绑定（…）`：`注：

```js
if (!Function.prototype.bind) {
	Function.prototype.bind = function(oThis) {
		if (typeof this !== "function") {
			// closest thing possible to the ECMAScript 5
			// internal IsCallable function
			throw new TypeError( "Function.prototype.bind - what " +
				"is trying to be bound is not callable"
			);
		}

		var aArgs = Array.prototype.slice.call( arguments, 1 ),
			fToBind = this,
			fNOP = function(){},
			fBound = function(){
				return fToBind.apply(
					(
						this instanceof fNOP &&
						oThis ? this : oThis
					),
					aArgs.concat( Array.prototype.slice.call( arguments ) )
				);
			}
		;

		fNOP.prototype = this.prototype;
		fBound.prototype = new fNOP();

		return fBound;
	};
}
```

**这个**绑定（…）`polyfill上面显示不同于内置`绑定（…）`在ES5相对于硬绑定功能，将使用`新的`（见下文）为什么有用）。因为没有一个polyfill不能创建一个函数`原型。`由于内置的实用工具，有一些微妙的间接近似相同的行为。如果你打算使用，小心踩`新的`与硬约束函数和你依靠这polyfill。`允许的部分

新的`最重要的是：`我们实际上不会深入解释这种欺骗是如何工作的（它很复杂，超出了我们的范围），但本质上，效用决定了硬绑定函数是否被调用了。

```js
this instanceof fNOP &&
oThis ? this : oThis

// ... and:

fNOP.prototype = this.prototype;
fBound.prototype = new fNOP();
```

新的`（使新构造的物体成为它的）`这`）如果是的话，它使用`那个_新创建的_这`而不是先前指定的`硬绑定_对于_这`。`为什么

新的`能够凌驾`硬绑定_有用吗？_这种行为的主要原因是创建一个函数（可以用于

新的`用于构造对象）本质上忽略了`这`硬绑定`但它预置函数的一些或全部参数。能力之一_绑定（…）_是在第一次之后传递的参数吗？`这`结合参数默认为标准参数的基本功能（技术上称为“局部应用”，这是一个集“讨好”）。`例如:`确定

这

```js
function foo(p1,p2) {
	this.val = p1 + p2;
}

// using `null` here because we don't care about
// the `this` hard-binding in this scenario, and
// it will be overridden by the `new` call anyway!
var bar = foo.bind( null, "p1" );

var baz = new bar( "p2" );

baz.val; // p1p2
```

### 现在，我们可以总结一下决定的规则。`这`

从函数调用的站点，按照它们的优先级顺序。按照这个顺序问这些问题，第一条规则适用时停止。`调用的函数是`新的

1.  （`新的结合`）？如果是这样的话，**这**是新构建的对象。`VaR的酒吧=新foo()`调用的函数是

    `呼叫`

2.  或`应用`（`显式绑定`），甚至藏在里面**绑定**硬绑定`？如果是这样的话，`这_是显式指定的对象。_VaR的酒吧= foo调用（obj2）。`函数是用上下文调用的吗？`隐式绑定

    `，也称为拥有或包含对象？如果是这样的话，`

3.  这**是**那个`上下文对象。`var obj1 foo()吧=。_否则，默认_这

    `（`

4.  默认的绑定`）。如果在`严格模式**，接**未定义`否则选择`全球的`对象。`VaR吧= foo()`够了就要这些。那是`它所需要的

    `理解规则`

这_正常函数调用的绑定。好...几乎._结合异常`像往常一样，有一些`例外

## 遵守规则。

这个_这_-绑定行为在某些情况下是令人惊讶的，在这里您打算使用不同的绑定，但最终会得到绑定行为。

默认的绑定`规则（见上一页）。`忽略_这_如果你通过

### 无效的`或`

未定义`作为一个`这`结合参数`呼叫`，`应用`，或`绑定`这些值被有效地忽略，而不是`默认的绑定`规则适用于调用。`你为什么故意传递类似的东西？_无效的_对于一个

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo.call( null ); // 2
```

这`结合？`使用起来很普遍。`应用（…）`将数组值扩展为函数调用的参数。同样，

绑定（…）`可以咖喱参数（预设值），这可能是非常有益的。`这两个实用程序都需要`这`第一个参数的绑定。如果问题中的函数不关心

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// spreading out array as parameters
foo.apply( null, [2, 3] ); // a:2, b:3

// currying with `bind(..)`
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
```

这`您需要一个占位符值，以及`无效的`似乎是一个合理的选择，如本片段所示。`注：`我们不要盖在这本书中，但6有`…

**传播算子，将让你在语法上“传播”作为参数的数组不需要**应用（…）`，如`富（……\[1,2]）`，等于`富（1,2）`——语法避免`这`如果不必要绑定。不幸的是，有没有为讨好ES6句法的替代品，所以`这`参数的`绑定（…）`呼叫仍需注意。`然而，有一个小小的隐藏的“危险”的策略`绑定（…）`呼叫仍需注意。

然而，总是有一些隐藏的“危险”。`无效的`当你不在乎`这`结合.如果您曾经对函数调用（例如，您不控制的第三方库函数）使用该函数，那么该函数_做_做一个`这`参考的_默认的绑定_规则意味着它可能会不经意地引用（或者更糟，变异！）这个`全球的`对象（`窗口`在浏览器中）。

显然，这样的陷阱会导致各种各样的_很难_诊断/跟踪错误。

#### 更安全的`这`

也许某种更“安全”的做法是传递一个专门设置的对象。`这`它保证不会成为一个在程序中产生问题的副作用的对象。从网络借贷术语（和军队），我们可以创建一个“非军事区”（非军事区）的对象——没有什么比一个空的更特殊，非授权（见章节5和6）的对象。

如果我们总是通过DMZ对象的忽视`这`绑定，我们不认为我们需要关心，我们相信任何隐藏/意外使用的`这`将被限制为空的对象，这使我们的计划`全球的`反对副作用。

因为这个对象是完全空的，我个人喜欢给它一个变量名。`ø`（用于空集合的小写数学符号）。在许多键盘上（如Mac上的美国布局），这个符号很容易输入。`⌥`+`o`（期权+`o`）。有些系统还允许你设置特定符号的热键。如果你不喜欢`ø`符号，或者你的键盘不能像打字那样容易，你当然可以把它叫做你想要的任何东西。

无论你怎么称呼它，最简单的方法就是把它设置为**完全空**是`对象创建（null）`（见第5章）。`对象创建（null）`类似于`{ }`但没有代表团`object.prototype`所以它“比”更“空”`{ }`。

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// our DMZ empty object
var ø = Object.create( null );

// spreading out array as parameters
foo.apply( ø, [2, 3] ); // a:2, b:3

// currying with `bind(..)`
var bar = foo.bind( ø, 2 );
bar( 3 ); // a:2, b:3
```

不仅功能上更“安全”，还有一种文体上的好处。`ø`它在语义上表达了“我想要`这`比“更清楚”`无效的`可能。但是，无论你喜欢你的DMZ对象名称。

### 间接寻址

另一件事要注意的是你可以（有意或不！）为函数创建“间接引用”，在这种情况下，当调用该函数引用时，_默认的绑定_规则也适用。

最常见的方式之一_间接引用_发生是从一项任务：

```js
function foo() {
	console.log( this.a );
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };

o.foo(); // 3
(p.foo = o.foo)(); // 2
```

这个_结果值_赋值表达式的`p.foo = o.foo`是对底层函数对象的引用。因此，有效的调用站点仅仅是`foo()`，不`foo() P.`或`foo() O.`正如你所预料的。根据上述规则，_默认的绑定_规则适用。

提醒：不管您如何使用_默认的绑定_的规则，`严格模式`现状**内容**调用函数使`这`引用——而不是函数调用站点——决定_默认的绑定_值：要么`全球的`对象如果非—`严格模式`或`未定义`如果在`严格模式`。

### 软化的结合

我们早就看到了_硬绑定_是防止函数调用回落到_默认的绑定_通过将规则绑定到某个特定位置而不经意地规则。`这`（除非你使用`新的`重写它！）问题是，_硬绑定_大大降低了功能的灵活性，避免了手工操作。`这`覆盖_隐式绑定_甚至以后_显式绑定_尝试.

如果有一种方法可以提供不同的默认值，那就更好了。_默认的绑定_（不`全球的`或`未定义`，但仍保留手动功能。`这`绑定通过_隐式绑定_或_显式绑定_技术。

我们可以构建一个所谓的_软约束_模拟我们想要的行为的实用程序。

```js
if (!Function.prototype.softBind) {
	Function.prototype.softBind = function(obj) {
		var fn = this,
			curried = [].slice.call( arguments, 1 ),
			bound = function bound() {
				return fn.apply(
					(!this ||
						(typeof window !== "undefined" &&
							this === window) ||
						(typeof global !== "undefined" &&
							this === global)
					) ? obj : this,
					curried.concat.apply( curried, arguments )
				);
			};
		bound.prototype = Object.create( fn.prototype );
		return bound;
	};
}
```

这个`softbind（..）`使用这里提供的工作类似于内置的ES5`绑定（…）`公用事业，除了我们_软约束_行为。它将指定的函数包装在检查`这`在通话时间，如果它的`全球的`或`未定义`使用预先指定的替换_违约_（`obj`）。否则`这`未触及。它还提供了可选的难题（见`绑定（…）`早期讨论）。

让我们演示一下它的用法：

```js
function foo() {
   console.log("name: " + this.name);
}

var obj = { name: "obj" },
    obj2 = { name: "obj2" },
    obj3 = { name: "obj3" };

var fooOBJ = foo.softBind( obj );

fooOBJ(); // name: obj

obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2   <---- look!!!

fooOBJ.call( obj3 ); // name: obj3   <---- look!

setTimeout( obj2.foo, 10 ); // name: obj   <---- falls back to soft-binding
```

软约束版本的`foo()`功能可以手动`这`绑定到`obj2`或`OBJ3`如图所示，但它可以追溯到`obj`如果_默认的绑定_否则将适用。

## 词汇`这`

正常的功能遵守我们刚才提到的4条规则。但6介绍一种特殊的功能，不使用这些规则：箭头功能。

箭头函数不是由`功能`关键字，但由`= >`所谓的“胖箭头”操作符。而不是使用四标准`这`规则，箭头函数采用`这`从封闭（函数或全局）范围绑定。

让我们举例说明箭头函数的词法范围：

```js
function foo() {
	// return an arrow function
	return (a) => {
		// `this` here is lexically adopted from `foo()`
		console.log( this.a );
	};
}

var obj1 = {
	a: 2
};

var obj2 = {
	a: 3
};

var bar = foo.call( obj1 );
bar.call( obj2 ); // 2, not 3!
```

创建的箭头函数`foo()`词汇捕捉任何`foo()`S`这`是在它的通话时间。`foo()`是`这`绑定到`obj1`，`酒吧`（返回箭头函数的引用）也将是`这`绑定到`obj1`。不能重写箭头函数的词汇绑定（甚至使用`新的`！）。

最常见的使用情况，将有可能在回调的使用，如事件处理程序或定时器：

```js
function foo() {
	setTimeout(() => {
		// `this` here is lexically adopted from `foo()`
		console.log( this.a );
	},100);
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

而箭头函数提供了一种替代使用`绑定（…）`关于确保其功能的`这`看起来很有吸引力，重要的是要注意它们本质上正在破坏传统。`这`有利于机构更广泛了解词法作用域。pre-es6，我们已经做了一个相当普遍的模式，基本上是从6箭头功能的精神几乎没有区别：

```js
function foo() {
	var self = this; // lexical capture of `this`
	setTimeout( function(){
		console.log( self.a );
	}, 100 );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

而`自本`箭头函数似乎是不想使用的好的“解决方案”。`绑定（…）`他们本质上是在逃避`这`而不是理解和拥抱它。

如果你发现自己在写作`这`风格代码，但大多数或所有的时间，你打败了`这`机制与词汇`自本`或箭头功能“把戏”，也许你也应该：

1.  只使用词法范围，忘记虚假的借口。`这`风格代码。

2.  拥抱`这`-完全机制式，包括使用`绑定（…）`必要时尽量避免`自本`箭头功能“词汇”这个技巧。

一个程序可以有效地使用这两种代码类型（词汇和`这`但是，在同一个函数中，实际上对于相同类型的查找，混合这两种机制通常要求更难维护代码，并且可能工作太难而不聪明。

## 回顾（TL；DR）

确定`这`对执行函数的绑定需要找到该函数的直接调用站点。一旦检查，四个规则可以应用到调用站点，在_这_优先顺序：

1.  称为`新的`？使用新构建的对象。

2.  称为`呼叫`或`应用`（或`绑定`）？使用指定的对象。

3.  具有拥有调用的上下文对象调用吗？使用上下文对象。

4.  违约:`未定义`在里面`严格模式`，否则全局对象。

小心偶然的/无意的调用_默认的绑定_规则。如果你想“安全”地忽略一个`这`结合“DMZ”对象`ø=对象创建（空）。`是一个很好的占位符值，可以保护`全球的`来自意外副作用的对象。

而不是四个标准约束的规则，6箭头的函数使用词法作用域为`这`绑定，这意味着它们采用`这`从封闭函数调用中绑定（无论它是什么）。它们本质上是一种句法替换。`自本`在pre-es6编码。
